; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.24215.1 

	TITLE	G:\Projects\Lotion\Lotion\player.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRTD
INCLUDELIB OLDNAMES

PUBLIC	?jumpPress@@3_NA				; jumpPress
PUBLIC	?floatingMovement@@3_NA				; floatingMovement
_BSS	SEGMENT
?jumpPress@@3_NA DB 01H DUP (?)				; jumpPress
?floatingMovement@@3_NA DB 01H DUP (?)			; floatingMovement
_BSS	ENDS
PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	?abs@@YANN@Z					; abs
PUBLIC	??2@YAPAXIPAX@Z					; operator new
PUBLIC	??0_Container_proxy@std@@QAE@XZ			; std::_Container_proxy::_Container_proxy
PUBLIC	??0_Container_base12@std@@QAE@XZ		; std::_Container_base12::_Container_base12
PUBLIC	??1_Container_base12@std@@QAE@XZ		; std::_Container_base12::~_Container_base12
PUBLIC	?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ ; std::_Container_base12::_Getpfirst
PUBLIC	?_Orphan_all@_Container_base12@std@@QAEXXZ	; std::_Container_base12::_Orphan_all
PUBLIC	??0_Iterator_base12@std@@QAE@XZ			; std::_Iterator_base12::_Iterator_base12
PUBLIC	??0_Iterator_base12@std@@QAE@ABU01@@Z		; std::_Iterator_base12::_Iterator_base12
PUBLIC	??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z	; std::_Iterator_base12::operator=
PUBLIC	??1_Iterator_base12@std@@QAE@XZ			; std::_Iterator_base12::~_Iterator_base12
PUBLIC	?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt
PUBLIC	?_Clrcont@_Iterator_base12@std@@QAEXXZ		; std::_Iterator_base12::_Clrcont
PUBLIC	?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
PUBLIC	?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ	; std::_Iterator_base12::_Getpnext
PUBLIC	?_Orphan_me@_Iterator_base12@std@@QAEXXZ	; std::_Iterator_base12::_Orphan_me
PUBLIC	?_Allocate@std@@YAPAXII_N@Z			; std::_Allocate
PUBLIC	?_Deallocate@std@@YAXPAXII@Z			; std::_Deallocate
PUBLIC	?midpoint@Tile@@QAE?AVVector2@@XZ		; Tile::midpoint
PUBLIC	??8Tile@@QBEHABU0@@Z				; Tile::operator==
PUBLIC	?top@Tile@@QAENXZ				; Tile::top
PUBLIC	?bottom@Tile@@QAENXZ				; Tile::bottom
PUBLIC	?left@Tile@@QAENXZ				; Tile::left
PUBLIC	?right@Tile@@QAENXZ				; Tile::right
PUBLIC	??0?$allocator@UTile@@@std@@QAE@XZ		; std::allocator<Tile>::allocator<Tile>
PUBLIC	?deallocate@?$allocator@UTile@@@std@@QAEXPAUTile@@I@Z ; std::allocator<Tile>::deallocate
PUBLIC	?allocate@?$allocator@UTile@@@std@@QAEPAUTile@@I@Z ; std::allocator<Tile>::allocate
PUBLIC	?max_size@?$allocator@UTile@@@std@@QBEIXZ	; std::allocator<Tile>::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@UTile@@@std@@@std@@SAIABV?$allocator@UTile@@@2@@Z ; std::allocator_traits<std::allocator<Tile> >::max_size
PUBLIC	??0?$_Wrap_alloc@V?$allocator@UTile@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<Tile> >::_Wrap_alloc<std::allocator<Tile> >
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@UTile@@@std@@@std@@QAEPAUTile@@I@Z ; std::_Wrap_alloc<std::allocator<Tile> >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@UTile@@@std@@@std@@QAEXPAUTile@@I@Z ; std::_Wrap_alloc<std::allocator<Tile> >::deallocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@UTile@@@std@@@std@@QBEIU_Nil@2@@Z ; std::_Wrap_alloc<std::allocator<Tile> >::max_size
PUBLIC	??0?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >
PUBLIC	??1?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::~_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >
PUBLIC	?_Alloc_proxy@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Alloc_proxy
PUBLIC	?_Free_proxy@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Free_proxy
PUBLIC	?_Getpfirst@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QBEPAPAU_Iterator_base12@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Getpfirst
PUBLIC	?_Myproxy@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Myproxy
PUBLIC	?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Orphan_all
PUBLIC	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@UTile@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Getal
PUBLIC	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@UTile@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Getal
PUBLIC	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UTile@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Get_data
PUBLIC	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@UTile@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Get_data
PUBLIC	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAEAAPAUTile@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Myfirst
PUBLIC	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QBEABQAUTile@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Myfirst
PUBLIC	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAEAAPAUTile@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Mylast
PUBLIC	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QBEABQAUTile@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Mylast
PUBLIC	?_Myend@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAEAAPAUTile@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Myend
PUBLIC	?_Myend@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QBEABQAUTile@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Myend
PUBLIC	??0?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<Tile> >::_Vector_val<std::_Simple_types<Tile> >
PUBLIC	??1?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<Tile> >::~_Vector_val<std::_Simple_types<Tile> >
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UTile@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@UTile@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Tile> >,std::_Vector_val<std::_Simple_types<Tile> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UTile@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@UTile@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Tile> >,std::_Vector_val<std::_Simple_types<Tile> >,1>::_Get_first
PUBLIC	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UTile@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UTile@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Tile> >,std::_Vector_val<std::_Simple_types<Tile> >,1>::_Get_second
PUBLIC	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UTile@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@UTile@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Tile> >,std::_Vector_val<std::_Simple_types<Tile> >,1>::_Get_second
PUBLIC	??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UTile@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@2@$00@std@@QAE@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Tile> >,std::_Vector_val<std::_Simple_types<Tile> >,1>::~_Compressed_pair<std::_Wrap_alloc<std::allocator<Tile> >,std::_Vector_val<std::_Simple_types<Tile> >,1>
PUBLIC	??0?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QAE@XZ ; std::vector<Tile,std::allocator<Tile> >::vector<Tile,std::allocator<Tile> >
PUBLIC	??1?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QAE@XZ ; std::vector<Tile,std::allocator<Tile> >::~vector<Tile,std::allocator<Tile> >
PUBLIC	?capacity@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QBEIXZ ; std::vector<Tile,std::allocator<Tile> >::capacity
PUBLIC	?_Unused_capacity@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QBEIXZ ; std::vector<Tile,std::allocator<Tile> >::_Unused_capacity
PUBLIC	?begin@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@2@XZ ; std::vector<Tile,std::allocator<Tile> >::begin
PUBLIC	?end@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@2@XZ ; std::vector<Tile,std::allocator<Tile> >::end
PUBLIC	?_Make_iter@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@2@@Z ; std::vector<Tile,std::allocator<Tile> >::_Make_iter
PUBLIC	?size@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QBEIXZ ; std::vector<Tile,std::allocator<Tile> >::size
PUBLIC	?max_size@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QBEIXZ ; std::vector<Tile,std::allocator<Tile> >::max_size
PUBLIC	?push_back@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QAEXABUTile@@@Z ; std::vector<Tile,std::allocator<Tile> >::push_back
PUBLIC	?erase@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@2@0@Z ; std::vector<Tile,std::allocator<Tile> >::erase
PUBLIC	?clear@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QAEXXZ ; std::vector<Tile,std::allocator<Tile> >::clear
PUBLIC	?_Destroy@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@IAEXPAUTile@@0@Z ; std::vector<Tile,std::allocator<Tile> >::_Destroy
PUBLIC	?_Grow_to@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@IBEII@Z ; std::vector<Tile,std::allocator<Tile> >::_Grow_to
PUBLIC	?_Inside@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@IBE_NPBUTile@@@Z ; std::vector<Tile,std::allocator<Tile> >::_Inside
PUBLIC	?_Reallocate@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@IAEXI@Z ; std::vector<Tile,std::allocator<Tile> >::_Reallocate
PUBLIC	?_Reserve@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@IAEXI@Z ; std::vector<Tile,std::allocator<Tile> >::_Reserve
PUBLIC	?_Tidy@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@IAEXXZ ; std::vector<Tile,std::allocator<Tile> >::_Tidy
PUBLIC	?_Xlen@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@IBEXXZ ; std::vector<Tile,std::allocator<Tile> >::_Xlen
PUBLIC	?_Orphan_range@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@IBEXPAUTile@@0@Z ; std::vector<Tile,std::allocator<Tile> >::_Orphan_range
PUBLIC	?__autoclassinit2@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QAEXI@Z ; std::vector<Tile,std::allocator<Tile> >::__autoclassinit2
PUBLIC	??0?$_Iterator012@Urandom_access_iterator_tag@std@@UTile@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,Tile,int,Tile const *,Tile const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,Tile,int,Tile const *,Tile const &,std::_Iterator_base12>
PUBLIC	??1?$_Iterator012@Urandom_access_iterator_tag@std@@UTile@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,Tile,int,Tile const *,Tile const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,Tile,int,Tile const *,Tile const &,std::_Iterator_base12>
PUBLIC	??0?$_Iterator012@Urandom_access_iterator_tag@std@@UTile@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z ; std::_Iterator012<std::random_access_iterator_tag,Tile,int,Tile const *,Tile const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,Tile,int,Tile const *,Tile const &,std::_Iterator_base12>
PUBLIC	??0?$_Iterator012@Urandom_access_iterator_tag@std@@UTile@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@$$QAU01@@Z ; std::_Iterator012<std::random_access_iterator_tag,Tile,int,Tile const *,Tile const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,Tile,int,Tile const *,Tile const &,std::_Iterator_base12>
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAE@PAUTile@@PBU_Container_base12@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Tile> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Tile> > >
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QBEABUTile@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Tile> > >::operator*
PUBLIC	??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Tile> > >::operator++
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Tile> > >::operator==
PUBLIC	??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Tile> > >::operator!=
PUBLIC	??M?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Tile> > >::operator<
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Tile> > >::_Compat
PUBLIC	??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Tile> > >::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Tile> > >
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Tile> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Tile> > >
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAE@$$QAV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Tile> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Tile> > >
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAE@PAUTile@@PBU_Container_base12@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Tile> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<Tile> > >
PUBLIC	?_Rechecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAEAAV12@PAUTile@@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Tile> > >::_Rechecked
PUBLIC	?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QBEPAUTile@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Tile> > >::_Unchecked
PUBLIC	??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QBEAAUTile@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Tile> > >::operator*
PUBLIC	??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Tile> > >::operator++
PUBLIC	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Tile> > >::~_Vector_iterator<std::_Vector_val<std::_Simple_types<Tile> > >
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Tile> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<Tile> > >
PUBLIC	?__autoclassinit2@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAEXI@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Tile> > >::__autoclassinit2
PUBLIC	?GetDirection@PushTile@@QAEHV?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@Z ; PushTile::GetDirection
PUBLIC	??0?$allocator@UPushTile@@@std@@QAE@ABV01@@Z	; std::allocator<PushTile>::allocator<PushTile>
PUBLIC	?deallocate@?$allocator@UPushTile@@@std@@QAEXPAUPushTile@@I@Z ; std::allocator<PushTile>::deallocate
PUBLIC	?allocate@?$allocator@UPushTile@@@std@@QAEPAUPushTile@@I@Z ; std::allocator<PushTile>::allocate
PUBLIC	?max_size@?$allocator@UPushTile@@@std@@QBEIXZ	; std::allocator<PushTile>::max_size
PUBLIC	?max_size@?$allocator_traits@V?$allocator@UPushTile@@@std@@@std@@SAIABV?$allocator@UPushTile@@@2@@Z ; std::allocator_traits<std::allocator<PushTile> >::max_size
PUBLIC	?select_on_container_copy_construction@?$allocator_traits@V?$allocator@UPushTile@@@std@@@std@@SA?AV?$allocator@UPushTile@@@2@ABV32@@Z ; std::allocator_traits<std::allocator<PushTile> >::select_on_container_copy_construction
PUBLIC	?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@std@@QBE?AU12@U_Nil@2@@Z ; std::_Wrap_alloc<std::allocator<PushTile> >::select_on_container_copy_construction
PUBLIC	??0?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@std@@QAE@$$QAU01@@Z ; std::_Wrap_alloc<std::allocator<PushTile> >::_Wrap_alloc<std::allocator<PushTile> >
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@std@@QAEPAUPushTile@@I@Z ; std::_Wrap_alloc<std::allocator<PushTile> >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@std@@QAEXPAUPushTile@@I@Z ; std::_Wrap_alloc<std::allocator<PushTile> >::deallocate
PUBLIC	?max_size@?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@std@@QBEIU_Nil@2@@Z ; std::_Wrap_alloc<std::allocator<PushTile> >::max_size
PUBLIC	??1?$_Vector_alloc@U?$_Vec_base_types@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<std::_Vec_base_types<PushTile,std::allocator<PushTile> > >::~_Vector_alloc<std::_Vec_base_types<PushTile,std::allocator<PushTile> > >
PUBLIC	?_Alloc_proxy@?$_Vector_alloc@U?$_Vec_base_types@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<std::_Vec_base_types<PushTile,std::allocator<PushTile> > >::_Alloc_proxy
PUBLIC	?_Free_proxy@?$_Vector_alloc@U?$_Vec_base_types@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<std::_Vec_base_types<PushTile,std::allocator<PushTile> > >::_Free_proxy
PUBLIC	?_Myproxy@?$_Vector_alloc@U?$_Vec_base_types@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<PushTile,std::allocator<PushTile> > >::_Myproxy
PUBLIC	?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<std::_Vec_base_types<PushTile,std::allocator<PushTile> > >::_Orphan_all
PUBLIC	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<PushTile,std::allocator<PushTile> > >::_Getal
PUBLIC	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<PushTile,std::allocator<PushTile> > >::_Getal
PUBLIC	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<PushTile,std::allocator<PushTile> > >::_Get_data
PUBLIC	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<PushTile,std::allocator<PushTile> > >::_Get_data
PUBLIC	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@std@@QAEAAPAUPushTile@@XZ ; std::_Vector_alloc<std::_Vec_base_types<PushTile,std::allocator<PushTile> > >::_Myfirst
PUBLIC	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@std@@QBEABQAUPushTile@@XZ ; std::_Vector_alloc<std::_Vec_base_types<PushTile,std::allocator<PushTile> > >::_Myfirst
PUBLIC	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@std@@QAEAAPAUPushTile@@XZ ; std::_Vector_alloc<std::_Vec_base_types<PushTile,std::allocator<PushTile> > >::_Mylast
PUBLIC	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@std@@QBEABQAUPushTile@@XZ ; std::_Vector_alloc<std::_Vec_base_types<PushTile,std::allocator<PushTile> > >::_Mylast
PUBLIC	?_Myend@?$_Vector_alloc@U?$_Vec_base_types@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@std@@QAEAAPAUPushTile@@XZ ; std::_Vector_alloc<std::_Vec_base_types<PushTile,std::allocator<PushTile> > >::_Myend
PUBLIC	??0?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<PushTile> >::_Vector_val<std::_Simple_types<PushTile> >
PUBLIC	??1?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<PushTile> >::~_Vector_val<std::_Simple_types<PushTile> >
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<PushTile> >,std::_Vector_val<std::_Simple_types<PushTile> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<PushTile> >,std::_Vector_val<std::_Simple_types<PushTile> >,1>::_Get_first
PUBLIC	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<PushTile> >,std::_Vector_val<std::_Simple_types<PushTile> >,1>::_Get_second
PUBLIC	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<PushTile> >,std::_Vector_val<std::_Simple_types<PushTile> >,1>::_Get_second
PUBLIC	??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@2@$00@std@@QAE@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<PushTile> >,std::_Vector_val<std::_Simple_types<PushTile> >,1>::~_Compressed_pair<std::_Wrap_alloc<std::allocator<PushTile> >,std::_Vector_val<std::_Simple_types<PushTile> >,1>
PUBLIC	??0?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@QAE@ABV01@@Z ; std::vector<PushTile,std::allocator<PushTile> >::vector<PushTile,std::allocator<PushTile> >
PUBLIC	??1?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@QAE@XZ ; std::vector<PushTile,std::allocator<PushTile> >::~vector<PushTile,std::allocator<PushTile> >
PUBLIC	?begin@?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@2@XZ ; std::vector<PushTile,std::allocator<PushTile> >::begin
PUBLIC	?begin@?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@2@XZ ; std::vector<PushTile,std::allocator<PushTile> >::begin
PUBLIC	?end@?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@2@XZ ; std::vector<PushTile,std::allocator<PushTile> >::end
PUBLIC	?end@?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@2@XZ ; std::vector<PushTile,std::allocator<PushTile> >::end
PUBLIC	?size@?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@QBEIXZ ; std::vector<PushTile,std::allocator<PushTile> >::size
PUBLIC	?max_size@?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@QBEIXZ ; std::vector<PushTile,std::allocator<PushTile> >::max_size
PUBLIC	?_Buy@?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@IAE_NI@Z ; std::vector<PushTile,std::allocator<PushTile> >::_Buy
PUBLIC	?_Destroy@?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@IAEXPAUPushTile@@0@Z ; std::vector<PushTile,std::allocator<PushTile> >::_Destroy
PUBLIC	?_Tidy@?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@IAEXXZ ; std::vector<PushTile,std::allocator<PushTile> >::_Tidy
PUBLIC	?_Xlen@?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@IBEXXZ ; std::vector<PushTile,std::allocator<PushTile> >::_Xlen
PUBLIC	??0?$_Iterator012@Urandom_access_iterator_tag@std@@UPushTile@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,PushTile,int,PushTile const *,PushTile const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,PushTile,int,PushTile const *,PushTile const &,std::_Iterator_base12>
PUBLIC	??1?$_Iterator012@Urandom_access_iterator_tag@std@@UPushTile@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,PushTile,int,PushTile const *,PushTile const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,PushTile,int,PushTile const *,PushTile const &,std::_Iterator_base12>
PUBLIC	??0?$_Iterator012@Urandom_access_iterator_tag@std@@UPushTile@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z ; std::_Iterator012<std::random_access_iterator_tag,PushTile,int,PushTile const *,PushTile const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,PushTile,int,PushTile const *,PushTile const &,std::_Iterator_base12>
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@QAE@PAUPushTile@@PBU_Container_base12@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PushTile> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PushTile> > >
PUBLIC	?_Unchecked@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@QBEPBUPushTile@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PushTile> > >::_Unchecked
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@QBEABUPushTile@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PushTile> > >::operator*
PUBLIC	??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PushTile> > >::operator++
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PushTile> > >::operator==
PUBLIC	??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PushTile> > >::operator!=
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PushTile> > >::_Compat
PUBLIC	??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PushTile> > >::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PushTile> > >
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PushTile> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PushTile> > >
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@QAE@PAUPushTile@@PBU_Container_base12@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<PushTile> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<PushTile> > >
PUBLIC	??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@QBEAAUPushTile@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<PushTile> > >::operator*
PUBLIC	??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<PushTile> > >::operator++
PUBLIC	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<PushTile> > >::~_Vector_iterator<std::_Vector_val<std::_Simple_types<PushTile> > >
PUBLIC	?__autoclassinit2@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@QAEXI@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<PushTile> > >::__autoclassinit2
PUBLIC	?midpoint@Player@@QAE?AVVector2@@XZ		; Player::midpoint
PUBLIC	?top@Player@@QAENXZ				; Player::top
PUBLIC	?bottom@Player@@QAENXZ				; Player::bottom
PUBLIC	?left@Player@@QAENXZ				; Player::left
PUBLIC	?right@Player@@QAENXZ				; Player::right
PUBLIC	??0Player@@QAE@XZ				; Player::Player
PUBLIC	?UpdatePlayer@@YAXH@Z				; UpdatePlayer
PUBLIC	?DrawPlayer@@YAXXZ				; DrawPlayer
PUBLIC	?ResetPlayer@@YAXXZ				; ResetPlayer
PUBLIC	?CheckCollisionTop@@YA_NUTile@@@Z		; CheckCollisionTop
PUBLIC	?CheckCollisionBottom@@YA_NUTile@@@Z		; CheckCollisionBottom
PUBLIC	?CheckCollisionLeft@@YA_NUTile@@@Z		; CheckCollisionLeft
PUBLIC	?CheckCollisionRight@@YA_NUTile@@@Z		; CheckCollisionRight
PUBLIC	?CheckCollision@@YA_NUTile@@@Z			; CheckCollision
PUBLIC	?HandleCollision@@YAXUTile@@@Z			; HandleCollision
PUBLIC	?HandleBasicCollision@@YAXUTile@@@Z		; HandleBasicCollision
PUBLIC	?FloatingMovement@@YAXM@Z			; FloatingMovement
PUBLIC	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@H@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Get_data
PUBLIC	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEAAPAHXZ ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Myfirst
PUBLIC	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEAAPAHXZ ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Mylast
PUBLIC	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@H@std@@@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@H@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<int> >,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_second
PUBLIC	?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ ; std::vector<int,std::allocator<int> >::begin
PUBLIC	?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ ; std::vector<int,std::allocator<int> >::end
PUBLIC	??0?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base12>
PUBLIC	??1?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base12>
PUBLIC	??0?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@ABU01@@Z ; std::_Iterator012<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base12>
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int> > >
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int> > >::operator==
PUBLIC	??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int> > >::operator!=
PUBLIC	??M?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int> > >::operator<
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int> > >::_Compat
PUBLIC	??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int> > >::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int> > >
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int> > >
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >
PUBLIC	?_Rechecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAEAAV12@PAH@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >::_Rechecked
PUBLIC	?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBEPAHXZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >::_Unchecked
PUBLIC	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >::~_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >
PUBLIC	??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@W4<unnamed-enum-SDLK_UNKNOWN>@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@V10@0ABW4<unnamed-enum-SDLK_UNKNOWN>@@@Z ; std::find<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >,enum <unnamed-enum-SDLK_UNKNOWN> >
PUBLIC	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UAirTile@@V?$allocator@UAirTile@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UAirTile@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<AirTile,std::allocator<AirTile> > >::_Get_data
PUBLIC	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UAirTile@@V?$allocator@UAirTile@@@std@@@std@@@std@@QAEAAPAUAirTile@@XZ ; std::_Vector_alloc<std::_Vec_base_types<AirTile,std::allocator<AirTile> > >::_Myfirst
PUBLIC	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UAirTile@@V?$allocator@UAirTile@@@std@@@std@@@std@@QAEAAPAUAirTile@@XZ ; std::_Vector_alloc<std::_Vec_base_types<AirTile,std::allocator<AirTile> > >::_Mylast
PUBLIC	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UAirTile@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UAirTile@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UAirTile@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<AirTile> >,std::_Vector_val<std::_Simple_types<AirTile> >,1>::_Get_second
PUBLIC	?begin@?$vector@UAirTile@@V?$allocator@UAirTile@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UAirTile@@@std@@@std@@@2@XZ ; std::vector<AirTile,std::allocator<AirTile> >::begin
PUBLIC	?end@?$vector@UAirTile@@V?$allocator@UAirTile@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UAirTile@@@std@@@std@@@2@XZ ; std::vector<AirTile,std::allocator<AirTile> >::end
PUBLIC	??0?$_Iterator012@Urandom_access_iterator_tag@std@@UAirTile@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,AirTile,int,AirTile const *,AirTile const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,AirTile,int,AirTile const *,AirTile const &,std::_Iterator_base12>
PUBLIC	??1?$_Iterator012@Urandom_access_iterator_tag@std@@UAirTile@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,AirTile,int,AirTile const *,AirTile const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,AirTile,int,AirTile const *,AirTile const &,std::_Iterator_base12>
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UAirTile@@@std@@@std@@@std@@QAE@PAUAirTile@@PBU_Container_base12@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<AirTile> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<AirTile> > >
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UAirTile@@@std@@@std@@@std@@QBEABUAirTile@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<AirTile> > >::operator*
PUBLIC	??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UAirTile@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<AirTile> > >::operator++
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UAirTile@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<AirTile> > >::operator==
PUBLIC	??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UAirTile@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<AirTile> > >::operator!=
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UAirTile@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<AirTile> > >::_Compat
PUBLIC	??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UAirTile@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<AirTile> > >::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<AirTile> > >
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UAirTile@@@std@@@std@@@std@@QAE@PAUAirTile@@PBU_Container_base12@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<AirTile> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<AirTile> > >
PUBLIC	??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UAirTile@@@std@@@std@@@std@@QBEAAUAirTile@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<AirTile> > >::operator*
PUBLIC	??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UAirTile@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<AirTile> > >::operator++
PUBLIC	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UAirTile@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<AirTile> > >::~_Vector_iterator<std::_Vector_val<std::_Simple_types<AirTile> > >
PUBLIC	?__autoclassinit2@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UAirTile@@@std@@@std@@@std@@QAEXI@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<AirTile> > >::__autoclassinit2
PUBLIC	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UMovingTile@@V?$allocator@UMovingTile@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UMovingTile@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<MovingTile,std::allocator<MovingTile> > >::_Get_data
PUBLIC	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UMovingTile@@V?$allocator@UMovingTile@@@std@@@std@@@std@@QAEAAPAUMovingTile@@XZ ; std::_Vector_alloc<std::_Vec_base_types<MovingTile,std::allocator<MovingTile> > >::_Myfirst
PUBLIC	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UMovingTile@@V?$allocator@UMovingTile@@@std@@@std@@@std@@QAEAAPAUMovingTile@@XZ ; std::_Vector_alloc<std::_Vec_base_types<MovingTile,std::allocator<MovingTile> > >::_Mylast
PUBLIC	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UMovingTile@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UMovingTile@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UMovingTile@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<MovingTile> >,std::_Vector_val<std::_Simple_types<MovingTile> >,1>::_Get_second
PUBLIC	?begin@?$vector@UMovingTile@@V?$allocator@UMovingTile@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UMovingTile@@@std@@@std@@@2@XZ ; std::vector<MovingTile,std::allocator<MovingTile> >::begin
PUBLIC	?end@?$vector@UMovingTile@@V?$allocator@UMovingTile@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UMovingTile@@@std@@@std@@@2@XZ ; std::vector<MovingTile,std::allocator<MovingTile> >::end
PUBLIC	??0?$_Iterator012@Urandom_access_iterator_tag@std@@UMovingTile@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,MovingTile,int,MovingTile const *,MovingTile const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,MovingTile,int,MovingTile const *,MovingTile const &,std::_Iterator_base12>
PUBLIC	??1?$_Iterator012@Urandom_access_iterator_tag@std@@UMovingTile@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ ; std::_Iterator012<std::random_access_iterator_tag,MovingTile,int,MovingTile const *,MovingTile const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,MovingTile,int,MovingTile const *,MovingTile const &,std::_Iterator_base12>
PUBLIC	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UMovingTile@@@std@@@std@@@std@@QAE@PAUMovingTile@@PBU_Container_base12@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<MovingTile> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<MovingTile> > >
PUBLIC	??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UMovingTile@@@std@@@std@@@std@@QBEABUMovingTile@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<MovingTile> > >::operator*
PUBLIC	??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UMovingTile@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<MovingTile> > >::operator++
PUBLIC	??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UMovingTile@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<MovingTile> > >::operator==
PUBLIC	??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UMovingTile@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<MovingTile> > >::operator!=
PUBLIC	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UMovingTile@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<MovingTile> > >::_Compat
PUBLIC	??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UMovingTile@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<MovingTile> > >::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<MovingTile> > >
PUBLIC	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UMovingTile@@@std@@@std@@@std@@QAE@PAUMovingTile@@PBU_Container_base12@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<MovingTile> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<MovingTile> > >
PUBLIC	??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UMovingTile@@@std@@@std@@@std@@QBEAAUMovingTile@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<MovingTile> > >::operator*
PUBLIC	??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UMovingTile@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<MovingTile> > >::operator++
PUBLIC	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UMovingTile@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<MovingTile> > >::~_Vector_iterator<std::_Vector_val<std::_Simple_types<MovingTile> > >
PUBLIC	?__autoclassinit2@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UMovingTile@@@std@@@std@@@std@@QAEXI@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<MovingTile> > >::__autoclassinit2
PUBLIC	??$remove@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@UTile@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@0@V10@0ABUTile@@@Z ; std::remove<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Tile> > >,Tile>
PUBLIC	??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@UTile@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@0@V10@0ABUTile@@@Z ; std::find<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Tile> > >,Tile>
PUBLIC	??$?0U?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@std@@X@?$_Vector_alloc@U?$_Vec_base_types@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@1@@Z ; std::_Vector_alloc<std::_Vec_base_types<PushTile,std::allocator<PushTile> > >::_Vector_alloc<std::_Vec_base_types<PushTile,std::allocator<PushTile> > ><std::_Wrap_alloc<std::allocator<PushTile> >,void>
PUBLIC	??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@@?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@IAEPAUPushTile@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@1@0PAU2@@Z ; std::vector<PushTile,std::allocator<PushTile> >::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PushTile> > > >
PUBLIC	??$_Move_unchecked@PAUTile@@PAU1@@std@@YAPAUTile@@PAU1@00@Z ; std::_Move_unchecked<Tile *,Tile *>
PUBLIC	??$addressof@$$CBUTile@@@std@@YAPBUTile@@ABU1@@Z ; std::addressof<Tile const >
PUBLIC	??$_Unfancy@UTile@@@std@@YAPAUTile@@PAU1@@Z	; std::_Unfancy<Tile>
PUBLIC	??$construct@UTile@@AAU1@@?$_Wrap_alloc@V?$allocator@UTile@@@std@@@std@@QAEXPAUTile@@AAU2@@Z ; std::_Wrap_alloc<std::allocator<Tile> >::construct<Tile,Tile &>
PUBLIC	??$construct@UTile@@ABU1@@?$_Wrap_alloc@V?$allocator@UTile@@@std@@@std@@QAEXPAUTile@@ABU2@@Z ; std::_Wrap_alloc<std::allocator<Tile> >::construct<Tile,Tile const &>
PUBLIC	??$?0V?$allocator@UPushTile@@@std@@@?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@std@@QAE@$$QAV?$allocator@UPushTile@@@1@@Z ; std::_Wrap_alloc<std::allocator<PushTile> >::_Wrap_alloc<std::allocator<PushTile> ><std::allocator<PushTile> >
PUBLIC	??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UTile@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Tile> >,std::_Vector_val<std::_Simple_types<Tile> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<Tile> >,std::_Vector_val<std::_Simple_types<Tile> >,1><>
PUBLIC	??$_Destroy_range@V?$allocator@UTile@@@std@@PAUTile@@@std@@YAXPAUTile@@0AAU?$_Wrap_alloc@V?$allocator@UTile@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<Tile>,Tile *>
PUBLIC	?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::deallocate
PUBLIC	?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate
PUBLIC	?address@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QBEPAU_Container_proxy@2@AAU32@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::address
PUBLIC	?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::allocate
PUBLIC	?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::deallocate
PUBLIC	??$?0AAU?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAU?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::_Wrap_alloc<std::allocator<std::_Container_proxy> ><std::_Wrap_alloc<std::allocator<PushTile> > &>
PUBLIC	??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::destroy<std::_Container_proxy>
PUBLIC	??$_Destroy_range@V?$allocator@UPushTile@@@std@@PAUPushTile@@@std@@YAXPAUPushTile@@0AAU?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<PushTile>,PushTile *>
PUBLIC	??$?0AAU?$_Wrap_alloc@V?$allocator@UTile@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAU?$_Wrap_alloc@V?$allocator@UTile@@@std@@@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::_Wrap_alloc<std::allocator<std::_Container_proxy> ><std::_Wrap_alloc<std::allocator<Tile> > &>
PUBLIC	??$_Unfancy@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@PAU10@@Z ; std::_Unfancy<std::_Container_proxy>
PUBLIC	??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::construct<std::_Container_proxy,std::_Container_proxy>
PUBLIC	??$_Umove@PAUTile@@@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@IAEPAUTile@@PAU2@00@Z ; std::vector<Tile,std::allocator<Tile> >::_Umove<Tile *>
PUBLIC	?pointer_to@?$pointer_traits@PAU_Container_proxy@std@@@std@@SAPAU_Container_proxy@2@AAU32@@Z ; std::pointer_traits<std::_Container_proxy *>::pointer_to
PUBLIC	??$addressof@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@AAU10@@Z ; std::addressof<std::_Container_proxy>
PUBLIC	??$_Debug_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0PB_WI@Z ; std::_Debug_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > > >
PUBLIC	??$_Unchecked@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@YAPAHV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@@Z ; std::_Unchecked<std::_Vector_val<std::_Simple_types<int> > >
PUBLIC	??$_Find_unchecked@PAHW4<unnamed-enum-SDLK_UNKNOWN>@@@std@@YAPAHPAH0ABW4<unnamed-enum-SDLK_UNKNOWN>@@@Z ; std::_Find_unchecked<int *,enum <unnamed-enum-SDLK_UNKNOWN> >
PUBLIC	??$_Rechecked@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@YAAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@AAV10@PAH@Z ; std::_Rechecked<std::_Vector_val<std::_Simple_types<int> > >
PUBLIC	??$_Debug_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@0@0PB_WI@Z ; std::_Debug_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Tile> > > >
PUBLIC	??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@YAPAUTile@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@0@@Z ; std::_Unchecked<std::_Vector_val<std::_Simple_types<Tile> > >
PUBLIC	??$_Remove_unchecked@PAUTile@@U1@@std@@YAPAUTile@@PAU1@0ABU1@@Z ; std::_Remove_unchecked<Tile *,Tile>
PUBLIC	??$_Rechecked@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@YAAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@0@AAV10@PAUTile@@@Z ; std::_Rechecked<std::_Vector_val<std::_Simple_types<Tile> > >
PUBLIC	??$_Find_unchecked@PAUTile@@U1@@std@@YAPAUTile@@PAU1@0ABU1@@Z ; std::_Find_unchecked<Tile *,Tile>
PUBLIC	??$forward@U?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@0@AAU10@@Z ; std::forward<std::_Wrap_alloc<std::allocator<PushTile> > >
PUBLIC	??$?0U?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@1@@Z ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<PushTile> >,std::_Vector_val<std::_Simple_types<PushTile> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<PushTile> >,std::_Vector_val<std::_Simple_types<PushTile> >,1><std::_Wrap_alloc<std::allocator<PushTile> > >
PUBLIC	??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@PAUPushTile@@V?$allocator@UPushTile@@@2@@std@@YAPAUPushTile@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@0@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@0@@Z ; std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PushTile> > >,PushTile *,std::allocator<PushTile> >
PUBLIC	??$_Ptr_move_cat@UTile@@U1@@std@@YA?AU_Trivially_copyable_ptr_iterator_tag@0@ABQAUTile@@0@Z ; std::_Ptr_move_cat<Tile,Tile>
PUBLIC	??$_Move_unchecked1@PAUTile@@PAU1@@std@@YAPAUTile@@PAU1@00U_Trivially_copyable_ptr_iterator_tag@0@@Z ; std::_Move_unchecked1<Tile *,Tile *>
PUBLIC	??$forward@AAUTile@@@std@@YAAAUTile@@AAU1@@Z	; std::forward<Tile &>
PUBLIC	??$construct@UTile@@AAU1@@?$allocator_traits@V?$allocator@UTile@@@std@@@std@@SAXAAV?$allocator@UTile@@@1@PAUTile@@AAU3@@Z ; std::allocator_traits<std::allocator<Tile> >::construct<Tile,Tile &>
PUBLIC	??$forward@ABUTile@@@std@@YAABUTile@@ABU1@@Z	; std::forward<Tile const &>
PUBLIC	??$construct@UTile@@ABU1@@?$allocator_traits@V?$allocator@UTile@@@std@@@std@@SAXAAV?$allocator@UTile@@@1@PAUTile@@ABU3@@Z ; std::allocator_traits<std::allocator<Tile> >::construct<Tile,Tile const &>
PUBLIC	??$forward@V?$allocator@UPushTile@@@std@@@std@@YA$$QAV?$allocator@UPushTile@@@0@AAV10@@Z ; std::forward<std::allocator<PushTile> >
PUBLIC	??$_Destroy_range1@V?$allocator@UTile@@@std@@PAUTile@@@std@@YAXPAUTile@@0AAU?$_Wrap_alloc@V?$allocator@UTile@@@std@@@0@U?$integral_constant@_N$00@0@@Z ; std::_Destroy_range1<std::allocator<Tile>,Tile *>
PUBLIC	??$forward@AAU?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@std@@@std@@YAAAU?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@0@AAU10@@Z ; std::forward<std::_Wrap_alloc<std::allocator<PushTile> > &>
PUBLIC	??$?0UPushTile@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@UPushTile@@@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><PushTile>
PUBLIC	??$destroy@U_Container_proxy@std@@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@@Z ; std::allocator_traits<std::allocator<std::_Container_proxy> >::destroy<std::_Container_proxy>
PUBLIC	??$_Destroy_range1@V?$allocator@UPushTile@@@std@@PAUPushTile@@@std@@YAXPAUPushTile@@0AAU?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@0@U?$integral_constant@_N$00@0@@Z ; std::_Destroy_range1<std::allocator<PushTile>,PushTile *>
PUBLIC	??$forward@AAU?$_Wrap_alloc@V?$allocator@UTile@@@std@@@std@@@std@@YAAAU?$_Wrap_alloc@V?$allocator@UTile@@@std@@@0@AAU10@@Z ; std::forward<std::_Wrap_alloc<std::allocator<Tile> > &>
PUBLIC	??$?0UTile@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@UTile@@@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><Tile>
PUBLIC	??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>
PUBLIC	??$construct@U_Container_proxy@std@@U12@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@$$QAU31@@Z ; std::allocator_traits<std::allocator<std::_Container_proxy> >::construct<std::_Container_proxy,std::_Container_proxy>
PUBLIC	??$_Uninitialized_move@PAUTile@@PAU1@V?$allocator@UTile@@@std@@@std@@YAPAUTile@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UTile@@@std@@@0@@Z ; std::_Uninitialized_move<Tile *,Tile *,std::allocator<Tile> >
PUBLIC	??$_Debug_range2@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z ; std::_Debug_range2<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > > >
PUBLIC	??$_Find_unchecked1@PAHW4<unnamed-enum-SDLK_UNKNOWN>@@@std@@YAPAHPAH0ABW4<unnamed-enum-SDLK_UNKNOWN>@@U?$integral_constant@_N$0A@@0@@Z ; std::_Find_unchecked1<int *,enum <unnamed-enum-SDLK_UNKNOWN> >
PUBLIC	??$_Debug_range2@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z ; std::_Debug_range2<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Tile> > > >
PUBLIC	??$move@AAUTile@@@std@@YA$$QAUTile@@AAU1@@Z	; std::move<Tile &>
PUBLIC	??$_Find_unchecked1@PAUTile@@U1@@std@@YAPAUTile@@PAU1@0ABU1@U?$integral_constant@_N$0A@@0@@Z ; std::_Find_unchecked1<Tile *,Tile>
PUBLIC	??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@YAPBUPushTile@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@0@@Z ; std::_Unchecked<std::_Vector_val<std::_Simple_types<PushTile> > >
PUBLIC	??$_Unchecked@PAUPushTile@@@std@@YAPAUPushTile@@PAU1@@Z ; std::_Unchecked<PushTile *>
PUBLIC	??$_Uninitialized_copy_al_unchecked@PBUPushTile@@PAU1@V?$allocator@UPushTile@@@std@@@std@@YAPAUPushTile@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@0@@Z ; std::_Uninitialized_copy_al_unchecked<PushTile const *,PushTile *,std::allocator<PushTile> >
PUBLIC	??$_Rechecked@PAUPushTile@@PAU1@@std@@YAAAPAUPushTile@@AAPAU1@PAU1@@Z ; std::_Rechecked<PushTile *,PushTile *>
PUBLIC	??$_Copy_memmove@PAUTile@@PAU1@@std@@YAPAUTile@@PAU1@00@Z ; std::_Copy_memmove<Tile *,Tile *>
PUBLIC	??$construct@UTile@@AAU1@@?$allocator@UTile@@@std@@QAEXPAUTile@@AAU2@@Z ; std::allocator<Tile>::construct<Tile,Tile &>
PUBLIC	??$construct@UTile@@ABU1@@?$allocator@UTile@@@std@@QAEXPAUTile@@ABU2@@Z ; std::allocator<Tile>::construct<Tile,Tile const &>
PUBLIC	??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>
PUBLIC	??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>
PUBLIC	??$_Unchecked@PAUTile@@@std@@YAPAUTile@@PAU1@@Z	; std::_Unchecked<Tile *>
PUBLIC	??$_Uninitialized_move_al_unchecked@PAUTile@@PAU1@V?$allocator@UTile@@@std@@@std@@YAPAUTile@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UTile@@@std@@@0@@Z ; std::_Uninitialized_move_al_unchecked<Tile *,Tile *,std::allocator<Tile> >
PUBLIC	??$_Rechecked@PAUTile@@PAU1@@std@@YAAAPAUTile@@AAPAU1@PAU1@@Z ; std::_Rechecked<Tile *,Tile *>
PUBLIC	??$move@AAU?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@0@AAU10@@Z ; std::move<std::_Wrap_alloc<std::allocator<PushTile> > &>
PUBLIC	??$_Debug_pointer@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YAXAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@PB_WI@Z ; std::_Debug_pointer<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > > >
PUBLIC	??$_Debug_pointer@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@@std@@YAXAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@0@PB_WI@Z ; std::_Debug_pointer<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Tile> > > >
PUBLIC	??$_Ptr_copy_cat@$$CBUPushTile@@U1@@std@@YA?AU_Trivially_copyable_ptr_iterator_tag@0@ABQBUPushTile@@ABQAU2@@Z ; std::_Ptr_copy_cat<PushTile const ,PushTile>
PUBLIC	??$_Unfancy@UPushTile@@@std@@YAPAUPushTile@@PAU1@@Z ; std::_Unfancy<PushTile>
PUBLIC	??$_Uninitialized_copy_al_unchecked1@PBUPushTile@@PAU1@V?$allocator@UPushTile@@@std@@@std@@YAPAUPushTile@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ; std::_Uninitialized_copy_al_unchecked1<PushTile const *,PushTile *,std::allocator<PushTile> >
PUBLIC	??$?0U?$integral_constant@_N$00@std@@@_Any_tag@std@@QAE@$$QAU?$integral_constant@_N$00@1@@Z ; std::_Any_tag::_Any_tag<std::integral_constant<bool,1> >
PUBLIC	??$_Uninitialized_move_al_unchecked1@PAUTile@@PAU1@V?$allocator@UTile@@@std@@@std@@YAPAUTile@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UTile@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ; std::_Uninitialized_move_al_unchecked1<Tile *,Tile *,std::allocator<Tile> >
PUBLIC	??$construct@UPushTile@@ABU1@@?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@std@@QAEXPAUPushTile@@ABU2@@Z ; std::_Wrap_alloc<std::allocator<PushTile> >::construct<PushTile,PushTile const &>
PUBLIC	??$construct@UTile@@U1@@?$_Wrap_alloc@V?$allocator@UTile@@@std@@@std@@QAEXPAUTile@@$$QAU2@@Z ; std::_Wrap_alloc<std::allocator<Tile> >::construct<Tile,Tile>
PUBLIC	??$forward@ABUPushTile@@@std@@YAABUPushTile@@ABU1@@Z ; std::forward<PushTile const &>
PUBLIC	??$construct@UPushTile@@ABU1@@?$allocator_traits@V?$allocator@UPushTile@@@std@@@std@@SAXAAV?$allocator@UPushTile@@@1@PAUPushTile@@ABU3@@Z ; std::allocator_traits<std::allocator<PushTile> >::construct<PushTile,PushTile const &>
PUBLIC	??$forward@UTile@@@std@@YA$$QAUTile@@AAU1@@Z	; std::forward<Tile>
PUBLIC	??$construct@UTile@@U1@@?$allocator_traits@V?$allocator@UTile@@@std@@@std@@SAXAAV?$allocator@UTile@@@1@PAUTile@@$$QAU3@@Z ; std::allocator_traits<std::allocator<Tile> >::construct<Tile,Tile>
PUBLIC	??$construct@UPushTile@@ABU1@@?$allocator@UPushTile@@@std@@QAEXPAUPushTile@@ABU2@@Z ; std::allocator<PushTile>::construct<PushTile,PushTile const &>
PUBLIC	??$construct@UTile@@U1@@?$allocator@UTile@@@std@@QAEXPAUTile@@$$QAU2@@Z ; std::allocator<Tile>::construct<Tile,Tile>
PUBLIC	??_C@_1JA@MHADJNIL@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; `string'
PUBLIC	??_C@_1DC@POOIKBAO@?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5?$AAC?$AAO?$AAR?$AAR?$AAU?$AAP?$AAT?$AAE?$AAD?$AA?$CB?$AA?$AA@ ; `string'
PUBLIC	?__LINE__Var@?0??_Allocate@std@@YAPAXII_N@Z@4JA	; `std::_Allocate'::`1'::__LINE__Var
PUBLIC	??_C@_0BE@LMNLACIC@_Ptr_container?5?$CB?$DN?50?$AA@ ; `string'
PUBLIC	??_C@_1DG@HGDKEBPG@?$AA?$CC?$AA_?$AAP?$AAt?$AAr?$AA_?$AAc?$AAo?$AAn?$AAt?$AAa?$AAi?$AAn?$AAe?$AAr?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0?$AA?$CC?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA0?$AA?$AA@ ; `string'
PUBLIC	??_C@_17CNPHIMPH@?$AA?$CF?$AAl?$AAs?$AA?$AA@	; `string'
PUBLIC	??_C@_1JA@DKOIEICI@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; `string'
PUBLIC	??_C@_1BO@NKFMJPA@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@ ; `string'
PUBLIC	??_C@_09GLJCAGLP@_Ptr?5?$CB?$DN?50?$AA@		; `string'
PUBLIC	??_C@_1CC@GKJLLHIM@?$AA?$CC?$AA_?$AAP?$AAt?$AAr?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0?$AA?$CC?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA0?$AA?$AA@ ; `string'
PUBLIC	?__LINE__Var@?0??_Deallocate@std@@YAXPAXII@Z@4JA ; `std::_Deallocate'::`1'::__LINE__Var
PUBLIC	??_C@_0BN@HMCJOMKN@_Count?5?$DM?$DN?5?$CIsize_t?$CJ?$CI?91?$CJ?5?1?5_Sz?$AA@ ; `string'
PUBLIC	??_C@_1EI@MLOBABC@?$AA?$CC?$AA_?$AAC?$AAo?$AAu?$AAn?$AAt?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA?$CI?$AAs?$AAi?$AAz?$AAe?$AA_?$AAt?$AA?$CJ?$AA?$CI?$AA?9?$AA1?$AA?$CJ?$AA?5?$AA?1?$AA?5?$AA_?$AAS?$AAz?$AA?$CC?$AA?5?$AA?$CG@ ; `string'
PUBLIC	??_C@_1CC@LOFJFFDB@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAD?$AAe?$AAa?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_0DD@GBGGGKGG@?$CI_Ptr_user?5?$CG?5?$CI_BIG_ALLOCATION_AL@ ; `string'
PUBLIC	??_C@_1HE@CDMBFOKC@?$AA?$CC?$AA?$CI?$AA_?$AAP?$AAt?$AAr?$AA_?$AAu?$AAs?$AAe?$AAr?$AA?5?$AA?$CG?$AA?5?$AA?$CI?$AA_?$AAB?$AAI?$AAG?$AA_?$AAA?$AAL?$AAL?$AAO?$AAC?$AAA?$AAT?$AAI?$AAO?$AAN?$AA_?$AAA@ ; `string'
PUBLIC	??_C@_0EI@NOJHEJCJ@reinterpret_cast?$DMuintptr_t?5?$CK?$DO?$CI_P@ ; `string'
PUBLIC	??_C@_1JO@EKLKIEHP@?$AA?$CC?$AAr?$AAe?$AAi?$AAn?$AAt?$AAe?$AAr?$AAp?$AAr?$AAe?$AAt?$AA_?$AAc?$AAa?$AAs?$AAt?$AA?$DM?$AAu?$AAi?$AAn?$AAt?$AAp?$AAt?$AAr?$AA_?$AAt?$AA?5?$AA?$CK?$AA?$DO?$AA?$CI?$AA_@ ; `string'
PUBLIC	??_C@_0BL@OCKMEJON@_Ptr_container?5?$DM?5_Ptr_user?$AA@ ; `string'
PUBLIC	??_C@_1EE@PDHAHDDC@?$AA?$CC?$AA_?$AAP?$AAt?$AAr?$AA_?$AAc?$AAo?$AAn?$AAt?$AAa?$AAi?$AAn?$AAe?$AAr?$AA?5?$AA?$DM?$AA?5?$AA_?$AAP?$AAt?$AAr?$AA_?$AAu?$AAs?$AAe?$AAr?$AA?$CC?$AA?5?$AA?$CG?$AA?$CG?$AA?5@ ; `string'
PUBLIC	??_C@_0DB@GLFJLNCE@2?5?$CK?5sizeof?$CIvoid?5?$CK?$CJ?5?$DM?$DN?5_Ptr_user?5@ ; `string'
PUBLIC	??_C@_1HA@NAPGMHAO@?$AA?$CC?$AA2?$AA?5?$AA?$CK?$AA?5?$AAs?$AAi?$AAz?$AAe?$AAo?$AAf?$AA?$CI?$AAv?$AAo?$AAi?$AAd?$AA?5?$AA?$CK?$AA?$CJ?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA_?$AAP?$AAt?$AAr?$AA_?$AAu?$AAs?$AAe?$AAr@ ; `string'
PUBLIC	??_C@_0CN@BLHJCAL@_Ptr_user?5?9?5_Ptr_container?5?$DM?$DN?5_N@ ; `string'
PUBLIC	??_C@_1GI@DHJGPFNI@?$AA?$CC?$AA_?$AAP?$AAt?$AAr?$AA_?$AAu?$AAs?$AAe?$AAr?$AA?5?$AA?9?$AA?5?$AA_?$AAP?$AAt?$AAr?$AA_?$AAc?$AAo?$AAn?$AAt?$AAa?$AAi?$AAn?$AAe?$AAr?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA_@ ; `string'
PUBLIC	?player@@3UPlayer@@A				; player
PUBLIC	?groundTileList@@3V?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@A ; groundTileList
PUBLIC	??_C@_0BG@EIAGFEK@?4?4?1Content?1player?4bmp?$AA@ ; `string'
PUBLIC	??_C@_1IM@NCODKBJH@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; `string'
PUBLIC	??_C@_1EI@HGIDLLCM@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAe?$AAr?$AAa?$AAs?$AAe?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAo?$AAu?$AAt?$AAs?$AAi?$AAd?$AAe?$AA?5?$AAr?$AAa@ ; `string'
PUBLIC	??_C@_1EE@EJDKCLKB@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAi?$AAn?$AAc?$AAr?$AAe?$AAm?$AAe?$AAn?$AAt?$AAa?$AAb?$AAl@ ; `string'
PUBLIC	??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@ ; `string'
PUBLIC	??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@ ; `string'
PUBLIC	??_C@_1OC@EGHAOCGO@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ ; `string'
PUBLIC	??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@ ; `string'
PUBLIC	??_C@_1EG@FOHJJHAC@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe?$AAn?$AAc?$AAa?$AAb@ ; `string'
PUBLIC	??_C@_1OA@POONEEJK@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ ; `string'
PUBLIC	??_C@_1NM@NIBONEGJ@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ ; `string'
PUBLIC	??_C@_1NK@FNOHGEBE@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ ; `string'
PUBLIC	??_C@_1DM@HINDPMBP@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AAs?$AA?5?$AAi?$AAn?$AAc?$AAo?$AAm?$AAp?$AAa?$AAt?$AAi?$AAb?$AAl?$AAe?$AA?$AA@ ; `string'
PUBLIC	??_C@_0CI@FNPHFCCM@Standard?5C?$CL?$CL?5Libraries?5Invalid?5A@ ; `string'
PUBLIC	??_C@_1FO@GJIHNDLM@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5@ ; `string'
PUBLIC	??_C@_1LO@MGELDLOO@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ ; `string'
PUBLIC	??_C@_1NO@MMDDECIN@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ ; `string'
PUBLIC	??_C@_1NM@EONCPDKK@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ ; `string'
PUBLIC	??_C@_1MO@FIOFHBNA@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ ; `string'
PUBLIC	??_C@_1NG@NCMKFBLG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ ; `string'
PUBLIC	??_C@_1NE@MNCPAIHH@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ ; `string'
PUBLIC	??_C@_1NK@NBKKOKHK@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ ; `string'
PUBLIC	??_C@_1NE@PKGEKJGN@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ ; `string'
PUBLIC	??_C@_1NG@COIFKLBO@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ ; `string'
PUBLIC	??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ ; `string'
PUBLIC	??_C@_1JC@ELNBGKIG@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ ; `string'
PUBLIC	??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ ; `string'
PUBLIC	__real@0000000000000000
PUBLIC	__real@3ffc000000000000
PUBLIC	__real@4000000000000000
PUBLIC	__real@4004000000000000
PUBLIC	__real@4008000000000000
PUBLIC	__real@4014000000000000
PUBLIC	__real@402399999999999a
PUBLIC	__real@4049000000000000
PUBLIC	__real@4050400000000000
PUBLIC	__real@447a0000
PUBLIC	__xmm@80000000000000008000000000000000
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAX@Z:PROC				; operator delete
EXTRN	_atexit:PROC
EXTRN	__imp___invalid_parameter:PROC
EXTRN	__imp_??0_Lockit@std@@QAE@H@Z:PROC
EXTRN	__imp_??1_Lockit@std@@QAE@XZ:PROC
EXTRN	_fabs:PROC
EXTRN	__imp__memmove:PROC
EXTRN	__imp___CrtDbgReportW:PROC
EXTRN	__imp_?_Debug_message@std@@YAXPB_W0I@Z:PROC
EXTRN	__imp_?_Xbad_alloc@std@@YAXXZ:PROC
EXTRN	__imp_?_Xlength_error@std@@YAXPBD@Z:PROC
EXTRN	??0Vector2@@QAE@XZ:PROC				; Vector2::Vector2
EXTRN	??0Vector2@@QAE@NN@Z:PROC			; Vector2::Vector2
EXTRN	?LoadTexture@@YAIPBD@Z:PROC			; LoadTexture
EXTRN	?DrawRect@@YAXIVVector2@@HH@Z:PROC		; DrawRect
EXTRN	@_RTC_CheckStackVars@8:PROC
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	__RTC_CheckEsp:PROC
EXTRN	__RTC_InitBase:PROC
EXTRN	__RTC_Shutdown:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	_memset:PROC
EXTRN	?keyList@@3V?$vector@HV?$allocator@H@std@@@std@@A:BYTE ; keyList
EXTRN	?pressKeyList@@3V?$vector@HV?$allocator@H@std@@@std@@A:BYTE ; pressKeyList
EXTRN	?tileMap@@3V?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@A:BYTE ; tileMap
EXTRN	?movingTileMap@@3V?$vector@UMovingTile@@V?$allocator@UMovingTile@@@std@@@std@@A:BYTE ; movingTileMap
EXTRN	?airTileMap@@3V?$vector@UAirTile@@V?$allocator@UAirTile@@@std@@@std@@A:BYTE ; airTileMap
EXTRN	?spawnTile@@3USpawnTile@@A:BYTE			; spawnTile
EXTRN	?pushTileMap@@3V?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@A:BYTE ; pushTileMap
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
_BSS	SEGMENT
	ALIGN	4

?player@@3UPlayer@@A DB 040H DUP (?)			; player
?groundTileList@@3V?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@A DB 010H DUP (?) ; groundTileList
_BSS	ENDS
CRT$XCU	SEGMENT
?player$initializer$@@3P6AXXZA DD FLAT:??__Eplayer@@YAXXZ ; player$initializer$
CRT$XCU	ENDS
;	COMDAT __xmm@80000000000000008000000000000000
CONST	SEGMENT
__xmm@80000000000000008000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	080H, 00H, 00H, 00H, 00H, 00H, 00H, 00H, 080H
CONST	ENDS
;	COMDAT __real@447a0000
CONST	SEGMENT
__real@447a0000 DD 0447a0000r			; 1000
CONST	ENDS
;	COMDAT __real@4050400000000000
CONST	SEGMENT
__real@4050400000000000 DQ 04050400000000000r	; 65
CONST	ENDS
;	COMDAT __real@4049000000000000
CONST	SEGMENT
__real@4049000000000000 DQ 04049000000000000r	; 50
CONST	ENDS
;	COMDAT __real@402399999999999a
CONST	SEGMENT
__real@402399999999999a DQ 0402399999999999ar	; 9.8
CONST	ENDS
;	COMDAT __real@4014000000000000
CONST	SEGMENT
__real@4014000000000000 DQ 04014000000000000r	; 5
CONST	ENDS
;	COMDAT __real@4008000000000000
CONST	SEGMENT
__real@4008000000000000 DQ 04008000000000000r	; 3
CONST	ENDS
;	COMDAT __real@4004000000000000
CONST	SEGMENT
__real@4004000000000000 DQ 04004000000000000r	; 2.5
CONST	ENDS
;	COMDAT __real@4000000000000000
CONST	SEGMENT
__real@4000000000000000 DQ 04000000000000000r	; 2
CONST	ENDS
;	COMDAT __real@3ffc000000000000
CONST	SEGMENT
__real@3ffc000000000000 DQ 03ffc000000000000r	; 1.75
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT rtc$TMZ
rtc$TMZ	SEGMENT
__RTC_Shutdown.rtc$TMZ DD FLAT:__RTC_Shutdown
rtc$TMZ	ENDS
;	COMDAT rtc$IMZ
rtc$IMZ	SEGMENT
__RTC_InitBase.rtc$IMZ DD FLAT:__RTC_InitBase
rtc$IMZ	ENDS
;	COMDAT ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@ DB 'i'
	DB	00H, 'n', 00H, 'v', 00H, 'a', 00H, 'l', 00H, 'i', 00H, 'd', 00H
	DB	' ', 00H, 'i', 00H, 't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't'
	DB	00H, 'o', 00H, 'r', 00H, ' ', 00H, 'r', 00H, 'a', 00H, 'n', 00H
	DB	'g', 00H, 'e', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1JC@ELNBGKIG@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
CONST	SEGMENT
??_C@_1JC@ELNBGKIG@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ DB 'c'
	DB	00H, ':', 00H, '\', 00H, 'p', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'f', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 's', 00H, ' ', 00H, '(', 00H, 'x', 00H, '8', 00H
	DB	'6', 00H, ')', 00H, '\', 00H, 'm', 00H, 'i', 00H, 'c', 00H, 'r'
	DB	00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H, ' ', 00H
	DB	'v', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l', 00H, ' '
	DB	00H, 's', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H
	DB	' ', 00H, '1', 00H, '4', 00H, '.', 00H, '0', 00H, '\', 00H, 'v'
	DB	00H, 'c', 00H, '\', 00H, 'i', 00H, 'n', 00H, 'c', 00H, 'l', 00H
	DB	'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'a', 00H, 'l', 00H, 'g'
	DB	00H, 'o', 00H, 'r', 00H, 'i', 00H, 't', 00H, 'h', 00H, 'm', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@ DB 'vector<T> too long'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_1NG@COIFKLBO@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
CONST	SEGMENT
??_C@_1NG@COIFKLBO@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'V', 00H
	DB	'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, '_', 00H, 'c'
	DB	00H, 'o', 00H, 'n', 00H, 's', 00H, 't', 00H, '_', 00H, 'i', 00H
	DB	't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r'
	DB	00H, '<', 00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H
	DB	' ', 00H, 's', 00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_'
	DB	00H, 'V', 00H, 'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H
	DB	'_', 00H, 'v', 00H, 'a', 00H, 'l', 00H, '<', 00H, 's', 00H, 't'
	DB	00H, 'r', 00H, 'u', 00H, 'c', 00H, 't', 00H, ' ', 00H, 's', 00H
	DB	't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'S', 00H, 'i'
	DB	00H, 'm', 00H, 'p', 00H, 'l', 00H, 'e', 00H, '_', 00H, 't', 00H
	DB	'y', 00H, 'p', 00H, 'e', 00H, 's', 00H, '<', 00H, 's', 00H, 't'
	DB	00H, 'r', 00H, 'u', 00H, 'c', 00H, 't', 00H, ' ', 00H, 'P', 00H
	DB	'u', 00H, 's', 00H, 'h', 00H, 'T', 00H, 'i', 00H, 'l', 00H, 'e'
	DB	00H, '>', 00H, ' ', 00H, '>', 00H, ' ', 00H, '>', 00H, ':', 00H
	DB	':', 00H, '_', 00H, 'C', 00H, 'o', 00H, 'm', 00H, 'p', 00H, 'a'
	DB	00H, 't', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1NE@PKGEKJGN@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
CONST	SEGMENT
??_C@_1NE@PKGEKJGN@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'V', 00H
	DB	'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, '_', 00H, 'c'
	DB	00H, 'o', 00H, 'n', 00H, 's', 00H, 't', 00H, '_', 00H, 'i', 00H
	DB	't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r'
	DB	00H, '<', 00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H
	DB	' ', 00H, 's', 00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_'
	DB	00H, 'V', 00H, 'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H
	DB	'_', 00H, 'v', 00H, 'a', 00H, 'l', 00H, '<', 00H, 's', 00H, 't'
	DB	00H, 'r', 00H, 'u', 00H, 'c', 00H, 't', 00H, ' ', 00H, 's', 00H
	DB	't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'S', 00H, 'i'
	DB	00H, 'm', 00H, 'p', 00H, 'l', 00H, 'e', 00H, '_', 00H, 't', 00H
	DB	'y', 00H, 'p', 00H, 'e', 00H, 's', 00H, '<', 00H, 's', 00H, 't'
	DB	00H, 'r', 00H, 'u', 00H, 'c', 00H, 't', 00H, ' ', 00H, 'A', 00H
	DB	'i', 00H, 'r', 00H, 'T', 00H, 'i', 00H, 'l', 00H, 'e', 00H, '>'
	DB	00H, ' ', 00H, '>', 00H, ' ', 00H, '>', 00H, ':', 00H, ':', 00H
	DB	'_', 00H, 'C', 00H, 'o', 00H, 'm', 00H, 'p', 00H, 'a', 00H, 't'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1NK@NBKKOKHK@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
CONST	SEGMENT
??_C@_1NK@NBKKOKHK@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'V', 00H
	DB	'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, '_', 00H, 'c'
	DB	00H, 'o', 00H, 'n', 00H, 's', 00H, 't', 00H, '_', 00H, 'i', 00H
	DB	't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r'
	DB	00H, '<', 00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H
	DB	' ', 00H, 's', 00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_'
	DB	00H, 'V', 00H, 'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H
	DB	'_', 00H, 'v', 00H, 'a', 00H, 'l', 00H, '<', 00H, 's', 00H, 't'
	DB	00H, 'r', 00H, 'u', 00H, 'c', 00H, 't', 00H, ' ', 00H, 's', 00H
	DB	't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'S', 00H, 'i'
	DB	00H, 'm', 00H, 'p', 00H, 'l', 00H, 'e', 00H, '_', 00H, 't', 00H
	DB	'y', 00H, 'p', 00H, 'e', 00H, 's', 00H, '<', 00H, 's', 00H, 't'
	DB	00H, 'r', 00H, 'u', 00H, 'c', 00H, 't', 00H, ' ', 00H, 'M', 00H
	DB	'o', 00H, 'v', 00H, 'i', 00H, 'n', 00H, 'g', 00H, 'T', 00H, 'i'
	DB	00H, 'l', 00H, 'e', 00H, '>', 00H, ' ', 00H, '>', 00H, ' ', 00H
	DB	'>', 00H, ':', 00H, ':', 00H, '_', 00H, 'C', 00H, 'o', 00H, 'm'
	DB	00H, 'p', 00H, 'a', 00H, 't', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1NE@MNCPAIHH@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
CONST	SEGMENT
??_C@_1NE@MNCPAIHH@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'V', 00H
	DB	'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, '_', 00H, 'c'
	DB	00H, 'o', 00H, 'n', 00H, 's', 00H, 't', 00H, '_', 00H, 'i', 00H
	DB	't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r'
	DB	00H, '<', 00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H
	DB	' ', 00H, 's', 00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_'
	DB	00H, 'V', 00H, 'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H
	DB	'_', 00H, 'v', 00H, 'a', 00H, 'l', 00H, '<', 00H, 's', 00H, 't'
	DB	00H, 'r', 00H, 'u', 00H, 'c', 00H, 't', 00H, ' ', 00H, 's', 00H
	DB	't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'S', 00H, 'i'
	DB	00H, 'm', 00H, 'p', 00H, 'l', 00H, 'e', 00H, '_', 00H, 't', 00H
	DB	'y', 00H, 'p', 00H, 'e', 00H, 's', 00H, '<', 00H, 's', 00H, 't'
	DB	00H, 'r', 00H, 'u', 00H, 'c', 00H, 't', 00H, ' ', 00H, 'T', 00H
	DB	'i', 00H, 'l', 00H, 'e', 00H, '>', 00H, ' ', 00H, '>', 00H, ' '
	DB	00H, '>', 00H, ':', 00H, ':', 00H, 'o', 00H, 'p', 00H, 'e', 00H
	DB	'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r', 00H, ' ', 00H, '*'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1NG@NCMKFBLG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
CONST	SEGMENT
??_C@_1NG@NCMKFBLG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'V', 00H
	DB	'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, '_', 00H, 'c'
	DB	00H, 'o', 00H, 'n', 00H, 's', 00H, 't', 00H, '_', 00H, 'i', 00H
	DB	't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r'
	DB	00H, '<', 00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H
	DB	' ', 00H, 's', 00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_'
	DB	00H, 'V', 00H, 'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H
	DB	'_', 00H, 'v', 00H, 'a', 00H, 'l', 00H, '<', 00H, 's', 00H, 't'
	DB	00H, 'r', 00H, 'u', 00H, 'c', 00H, 't', 00H, ' ', 00H, 's', 00H
	DB	't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'S', 00H, 'i'
	DB	00H, 'm', 00H, 'p', 00H, 'l', 00H, 'e', 00H, '_', 00H, 't', 00H
	DB	'y', 00H, 'p', 00H, 'e', 00H, 's', 00H, '<', 00H, 's', 00H, 't'
	DB	00H, 'r', 00H, 'u', 00H, 'c', 00H, 't', 00H, ' ', 00H, 'T', 00H
	DB	'i', 00H, 'l', 00H, 'e', 00H, '>', 00H, ' ', 00H, '>', 00H, ' '
	DB	00H, '>', 00H, ':', 00H, ':', 00H, 'o', 00H, 'p', 00H, 'e', 00H
	DB	'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r', 00H, ' ', 00H, '+'
	DB	00H, '+', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1MO@FIOFHBNA@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
CONST	SEGMENT
??_C@_1MO@FIOFHBNA@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'V', 00H
	DB	'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, '_', 00H, 'c'
	DB	00H, 'o', 00H, 'n', 00H, 's', 00H, 't', 00H, '_', 00H, 'i', 00H
	DB	't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r'
	DB	00H, '<', 00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H
	DB	' ', 00H, 's', 00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_'
	DB	00H, 'V', 00H, 'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H
	DB	'_', 00H, 'v', 00H, 'a', 00H, 'l', 00H, '<', 00H, 's', 00H, 't'
	DB	00H, 'r', 00H, 'u', 00H, 'c', 00H, 't', 00H, ' ', 00H, 's', 00H
	DB	't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'S', 00H, 'i'
	DB	00H, 'm', 00H, 'p', 00H, 'l', 00H, 'e', 00H, '_', 00H, 't', 00H
	DB	'y', 00H, 'p', 00H, 'e', 00H, 's', 00H, '<', 00H, 's', 00H, 't'
	DB	00H, 'r', 00H, 'u', 00H, 'c', 00H, 't', 00H, ' ', 00H, 'T', 00H
	DB	'i', 00H, 'l', 00H, 'e', 00H, '>', 00H, ' ', 00H, '>', 00H, ' '
	DB	00H, '>', 00H, ':', 00H, ':', 00H, '_', 00H, 'C', 00H, 'o', 00H
	DB	'm', 00H, 'p', 00H, 'a', 00H, 't', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1NM@EONCPDKK@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
CONST	SEGMENT
??_C@_1NM@EONCPDKK@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'V', 00H
	DB	'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, '_', 00H, 'c'
	DB	00H, 'o', 00H, 'n', 00H, 's', 00H, 't', 00H, '_', 00H, 'i', 00H
	DB	't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r'
	DB	00H, '<', 00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H
	DB	' ', 00H, 's', 00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_'
	DB	00H, 'V', 00H, 'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H
	DB	'_', 00H, 'v', 00H, 'a', 00H, 'l', 00H, '<', 00H, 's', 00H, 't'
	DB	00H, 'r', 00H, 'u', 00H, 'c', 00H, 't', 00H, ' ', 00H, 's', 00H
	DB	't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'S', 00H, 'i'
	DB	00H, 'm', 00H, 'p', 00H, 'l', 00H, 'e', 00H, '_', 00H, 't', 00H
	DB	'y', 00H, 'p', 00H, 'e', 00H, 's', 00H, '<', 00H, 's', 00H, 't'
	DB	00H, 'r', 00H, 'u', 00H, 'c', 00H, 't', 00H, ' ', 00H, 'P', 00H
	DB	'u', 00H, 's', 00H, 'h', 00H, 'T', 00H, 'i', 00H, 'l', 00H, 'e'
	DB	00H, '>', 00H, ' ', 00H, '>', 00H, ' ', 00H, '>', 00H, ':', 00H
	DB	':', 00H, 'o', 00H, 'p', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't'
	DB	00H, 'o', 00H, 'r', 00H, ' ', 00H, '*', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1NO@MMDDECIN@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
CONST	SEGMENT
??_C@_1NO@MMDDECIN@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'V', 00H
	DB	'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, '_', 00H, 'c'
	DB	00H, 'o', 00H, 'n', 00H, 's', 00H, 't', 00H, '_', 00H, 'i', 00H
	DB	't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r'
	DB	00H, '<', 00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H
	DB	' ', 00H, 's', 00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_'
	DB	00H, 'V', 00H, 'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H
	DB	'_', 00H, 'v', 00H, 'a', 00H, 'l', 00H, '<', 00H, 's', 00H, 't'
	DB	00H, 'r', 00H, 'u', 00H, 'c', 00H, 't', 00H, ' ', 00H, 's', 00H
	DB	't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'S', 00H, 'i'
	DB	00H, 'm', 00H, 'p', 00H, 'l', 00H, 'e', 00H, '_', 00H, 't', 00H
	DB	'y', 00H, 'p', 00H, 'e', 00H, 's', 00H, '<', 00H, 's', 00H, 't'
	DB	00H, 'r', 00H, 'u', 00H, 'c', 00H, 't', 00H, ' ', 00H, 'P', 00H
	DB	'u', 00H, 's', 00H, 'h', 00H, 'T', 00H, 'i', 00H, 'l', 00H, 'e'
	DB	00H, '>', 00H, ' ', 00H, '>', 00H, ' ', 00H, '>', 00H, ':', 00H
	DB	':', 00H, 'o', 00H, 'p', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't'
	DB	00H, 'o', 00H, 'r', 00H, ' ', 00H, '+', 00H, '+', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1LO@MGELDLOO@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
CONST	SEGMENT
??_C@_1LO@MGELDLOO@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'V', 00H
	DB	'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, '_', 00H, 'c'
	DB	00H, 'o', 00H, 'n', 00H, 's', 00H, 't', 00H, '_', 00H, 'i', 00H
	DB	't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r'
	DB	00H, '<', 00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H
	DB	' ', 00H, 's', 00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_'
	DB	00H, 'V', 00H, 'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H
	DB	'_', 00H, 'v', 00H, 'a', 00H, 'l', 00H, '<', 00H, 's', 00H, 't'
	DB	00H, 'r', 00H, 'u', 00H, 'c', 00H, 't', 00H, ' ', 00H, 's', 00H
	DB	't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'S', 00H, 'i'
	DB	00H, 'm', 00H, 'p', 00H, 'l', 00H, 'e', 00H, '_', 00H, 't', 00H
	DB	'y', 00H, 'p', 00H, 'e', 00H, 's', 00H, '<', 00H, 'i', 00H, 'n'
	DB	00H, 't', 00H, '>', 00H, ' ', 00H, '>', 00H, ' ', 00H, '>', 00H
	DB	':', 00H, ':', 00H, '_', 00H, 'C', 00H, 'o', 00H, 'm', 00H, 'p'
	DB	00H, 'a', 00H, 't', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1FO@GJIHNDLM@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5@
CONST	SEGMENT
??_C@_1FO@GJIHNDLM@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5@ DB '"'
	DB	00H, 'S', 00H, 't', 00H, 'a', 00H, 'n', 00H, 'd', 00H, 'a', 00H
	DB	'r', 00H, 'd', 00H, ' ', 00H, 'C', 00H, '+', 00H, '+', 00H, ' '
	DB	00H, 'L', 00H, 'i', 00H, 'b', 00H, 'r', 00H, 'a', 00H, 'r', 00H
	DB	'i', 00H, 'e', 00H, 's', 00H, ' ', 00H, 'I', 00H, 'n', 00H, 'v'
	DB	00H, 'a', 00H, 'l', 00H, 'i', 00H, 'd', 00H, ' ', 00H, 'A', 00H
	DB	'r', 00H, 'g', 00H, 'u', 00H, 'm', 00H, 'e', 00H, 'n', 00H, 't'
	DB	00H, '"', 00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H, '0', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@FNPHFCCM@Standard?5C?$CL?$CL?5Libraries?5Invalid?5A@
CONST	SEGMENT
??_C@_0CI@FNPHFCCM@Standard?5C?$CL?$CL?5Libraries?5Invalid?5A@ DB 'Standa'
	DB	'rd C++ Libraries Invalid Argument', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1DM@HINDPMBP@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AAs?$AA?5?$AAi?$AAn?$AAc?$AAo?$AAm?$AAp?$AAa?$AAt?$AAi?$AAb?$AAl?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1DM@HINDPMBP@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AAs?$AA?5?$AAi?$AAn?$AAc?$AAo?$AAm?$AAp?$AAa?$AAt?$AAi?$AAb?$AAl?$AAe?$AA?$AA@ DB 'v'
	DB	00H, 'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, ' ', 00H
	DB	'i', 00H, 't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o'
	DB	00H, 'r', 00H, 's', 00H, ' ', 00H, 'i', 00H, 'n', 00H, 'c', 00H
	DB	'o', 00H, 'm', 00H, 'p', 00H, 'a', 00H, 't', 00H, 'i', 00H, 'b'
	DB	00H, 'l', 00H, 'e', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1NK@FNOHGEBE@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
CONST	SEGMENT
??_C@_1NK@FNOHGEBE@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'V', 00H
	DB	'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, '_', 00H, 'c'
	DB	00H, 'o', 00H, 'n', 00H, 's', 00H, 't', 00H, '_', 00H, 'i', 00H
	DB	't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r'
	DB	00H, '<', 00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H
	DB	' ', 00H, 's', 00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_'
	DB	00H, 'V', 00H, 'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H
	DB	'_', 00H, 'v', 00H, 'a', 00H, 'l', 00H, '<', 00H, 's', 00H, 't'
	DB	00H, 'r', 00H, 'u', 00H, 'c', 00H, 't', 00H, ' ', 00H, 's', 00H
	DB	't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'S', 00H, 'i'
	DB	00H, 'm', 00H, 'p', 00H, 'l', 00H, 'e', 00H, '_', 00H, 't', 00H
	DB	'y', 00H, 'p', 00H, 'e', 00H, 's', 00H, '<', 00H, 's', 00H, 't'
	DB	00H, 'r', 00H, 'u', 00H, 'c', 00H, 't', 00H, ' ', 00H, 'A', 00H
	DB	'i', 00H, 'r', 00H, 'T', 00H, 'i', 00H, 'l', 00H, 'e', 00H, '>'
	DB	00H, ' ', 00H, '>', 00H, ' ', 00H, '>', 00H, ':', 00H, ':', 00H
	DB	'o', 00H, 'p', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o'
	DB	00H, 'r', 00H, ' ', 00H, '*', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1NM@NIBONEGJ@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
CONST	SEGMENT
??_C@_1NM@NIBONEGJ@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'V', 00H
	DB	'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, '_', 00H, 'c'
	DB	00H, 'o', 00H, 'n', 00H, 's', 00H, 't', 00H, '_', 00H, 'i', 00H
	DB	't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r'
	DB	00H, '<', 00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H
	DB	' ', 00H, 's', 00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_'
	DB	00H, 'V', 00H, 'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H
	DB	'_', 00H, 'v', 00H, 'a', 00H, 'l', 00H, '<', 00H, 's', 00H, 't'
	DB	00H, 'r', 00H, 'u', 00H, 'c', 00H, 't', 00H, ' ', 00H, 's', 00H
	DB	't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'S', 00H, 'i'
	DB	00H, 'm', 00H, 'p', 00H, 'l', 00H, 'e', 00H, '_', 00H, 't', 00H
	DB	'y', 00H, 'p', 00H, 'e', 00H, 's', 00H, '<', 00H, 's', 00H, 't'
	DB	00H, 'r', 00H, 'u', 00H, 'c', 00H, 't', 00H, ' ', 00H, 'A', 00H
	DB	'i', 00H, 'r', 00H, 'T', 00H, 'i', 00H, 'l', 00H, 'e', 00H, '>'
	DB	00H, ' ', 00H, '>', 00H, ' ', 00H, '>', 00H, ':', 00H, ':', 00H
	DB	'o', 00H, 'p', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o'
	DB	00H, 'r', 00H, ' ', 00H, '+', 00H, '+', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1OA@POONEEJK@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
CONST	SEGMENT
??_C@_1OA@POONEEJK@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'V', 00H
	DB	'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, '_', 00H, 'c'
	DB	00H, 'o', 00H, 'n', 00H, 's', 00H, 't', 00H, '_', 00H, 'i', 00H
	DB	't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r'
	DB	00H, '<', 00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H
	DB	' ', 00H, 's', 00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_'
	DB	00H, 'V', 00H, 'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H
	DB	'_', 00H, 'v', 00H, 'a', 00H, 'l', 00H, '<', 00H, 's', 00H, 't'
	DB	00H, 'r', 00H, 'u', 00H, 'c', 00H, 't', 00H, ' ', 00H, 's', 00H
	DB	't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'S', 00H, 'i'
	DB	00H, 'm', 00H, 'p', 00H, 'l', 00H, 'e', 00H, '_', 00H, 't', 00H
	DB	'y', 00H, 'p', 00H, 'e', 00H, 's', 00H, '<', 00H, 's', 00H, 't'
	DB	00H, 'r', 00H, 'u', 00H, 'c', 00H, 't', 00H, ' ', 00H, 'M', 00H
	DB	'o', 00H, 'v', 00H, 'i', 00H, 'n', 00H, 'g', 00H, 'T', 00H, 'i'
	DB	00H, 'l', 00H, 'e', 00H, '>', 00H, ' ', 00H, '>', 00H, ' ', 00H
	DB	'>', 00H, ':', 00H, ':', 00H, 'o', 00H, 'p', 00H, 'e', 00H, 'r'
	DB	00H, 'a', 00H, 't', 00H, 'o', 00H, 'r', 00H, ' ', 00H, '*', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1EG@FOHJJHAC@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe?$AAn?$AAc?$AAa?$AAb@
CONST	SEGMENT
??_C@_1EG@FOHJJHAC@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe?$AAn?$AAc?$AAa?$AAb@ DB 'v'
	DB	00H, 'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, ' ', 00H
	DB	'i', 00H, 't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o'
	DB	00H, 'r', 00H, ' ', 00H, 'n', 00H, 'o', 00H, 't', 00H, ' ', 00H
	DB	'd', 00H, 'e', 00H, 'r', 00H, 'e', 00H, 'f', 00H, 'e', 00H, 'r'
	DB	00H, 'e', 00H, 'n', 00H, 'c', 00H, 'a', 00H, 'b', 00H, 'l', 00H
	DB	'e', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@
CONST	SEGMENT
??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@ DB '"'
	DB	00H, 'o', 00H, 'u', 00H, 't', 00H, ' ', 00H, 'o', 00H, 'f', 00H
	DB	' ', 00H, 'r', 00H, 'a', 00H, 'n', 00H, 'g', 00H, 'e', 00H, '"'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1OC@EGHAOCGO@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
CONST	SEGMENT
??_C@_1OC@EGHAOCGO@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'V', 00H
	DB	'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, '_', 00H, 'c'
	DB	00H, 'o', 00H, 'n', 00H, 's', 00H, 't', 00H, '_', 00H, 'i', 00H
	DB	't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H, 'r'
	DB	00H, '<', 00H, 'c', 00H, 'l', 00H, 'a', 00H, 's', 00H, 's', 00H
	DB	' ', 00H, 's', 00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_'
	DB	00H, 'V', 00H, 'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H
	DB	'_', 00H, 'v', 00H, 'a', 00H, 'l', 00H, '<', 00H, 's', 00H, 't'
	DB	00H, 'r', 00H, 'u', 00H, 'c', 00H, 't', 00H, ' ', 00H, 's', 00H
	DB	't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'S', 00H, 'i'
	DB	00H, 'm', 00H, 'p', 00H, 'l', 00H, 'e', 00H, '_', 00H, 't', 00H
	DB	'y', 00H, 'p', 00H, 'e', 00H, 's', 00H, '<', 00H, 's', 00H, 't'
	DB	00H, 'r', 00H, 'u', 00H, 'c', 00H, 't', 00H, ' ', 00H, 'M', 00H
	DB	'o', 00H, 'v', 00H, 'i', 00H, 'n', 00H, 'g', 00H, 'T', 00H, 'i'
	DB	00H, 'l', 00H, 'e', 00H, '>', 00H, ' ', 00H, '>', 00H, ' ', 00H
	DB	'>', 00H, ':', 00H, ':', 00H, 'o', 00H, 'p', 00H, 'e', 00H, 'r'
	DB	00H, 'a', 00H, 't', 00H, 'o', 00H, 'r', 00H, ' ', 00H, '+', 00H
	DB	'+', 00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@
CONST	SEGMENT
??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@ DB '"'
	DB	00H, 'S', 00H, 't', 00H, 'a', 00H, 'n', 00H, 'd', 00H, 'a', 00H
	DB	'r', 00H, 'd', 00H, ' ', 00H, 'C', 00H, '+', 00H, '+', 00H, ' '
	DB	00H, 'L', 00H, 'i', 00H, 'b', 00H, 'r', 00H, 'a', 00H, 'r', 00H
	DB	'i', 00H, 'e', 00H, 's', 00H, ' ', 00H, 'O', 00H, 'u', 00H, 't'
	DB	00H, ' ', 00H, 'o', 00H, 'f', 00H, ' ', 00H, 'R', 00H, 'a', 00H
	DB	'n', 00H, 'g', 00H, 'e', 00H, '"', 00H, ' ', 00H, '&', 00H, '&'
	DB	00H, ' ', 00H, '0', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@
CONST	SEGMENT
??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@ DB 'Stand'
	DB	'ard C++ Libraries Out of Range', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_1EE@EJDKCLKB@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAi?$AAn?$AAc?$AAr?$AAe?$AAm?$AAe?$AAn?$AAt?$AAa?$AAb?$AAl@
CONST	SEGMENT
??_C@_1EE@EJDKCLKB@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAi?$AAn?$AAc?$AAr?$AAe?$AAm?$AAe?$AAn?$AAt?$AAa?$AAb?$AAl@ DB 'v'
	DB	00H, 'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, ' ', 00H
	DB	'i', 00H, 't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o'
	DB	00H, 'r', 00H, ' ', 00H, 'n', 00H, 'o', 00H, 't', 00H, ' ', 00H
	DB	'i', 00H, 'n', 00H, 'c', 00H, 'r', 00H, 'e', 00H, 'm', 00H, 'e'
	DB	00H, 'n', 00H, 't', 00H, 'a', 00H, 'b', 00H, 'l', 00H, 'e', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1EI@HGIDLLCM@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAe?$AAr?$AAa?$AAs?$AAe?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAo?$AAu?$AAt?$AAs?$AAi?$AAd?$AAe?$AA?5?$AAr?$AAa@
CONST	SEGMENT
??_C@_1EI@HGIDLLCM@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAe?$AAr?$AAa?$AAs?$AAe?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAo?$AAu?$AAt?$AAs?$AAi?$AAd?$AAe?$AA?5?$AAr?$AAa@ DB 'v'
	DB	00H, 'e', 00H, 'c', 00H, 't', 00H, 'o', 00H, 'r', 00H, ' ', 00H
	DB	'e', 00H, 'r', 00H, 'a', 00H, 's', 00H, 'e', 00H, ' ', 00H, 'i'
	DB	00H, 't', 00H, 'e', 00H, 'r', 00H, 'a', 00H, 't', 00H, 'o', 00H
	DB	'r', 00H, ' ', 00H, 'o', 00H, 'u', 00H, 't', 00H, 's', 00H, 'i'
	DB	00H, 'd', 00H, 'e', 00H, ' ', 00H, 'r', 00H, 'a', 00H, 'n', 00H
	DB	'g', 00H, 'e', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_1IM@NCODKBJH@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
CONST	SEGMENT
??_C@_1IM@NCODKBJH@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ DB 'c'
	DB	00H, ':', 00H, '\', 00H, 'p', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'f', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 's', 00H, ' ', 00H, '(', 00H, 'x', 00H, '8', 00H
	DB	'6', 00H, ')', 00H, '\', 00H, 'm', 00H, 'i', 00H, 'c', 00H, 'r'
	DB	00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H, ' ', 00H
	DB	'v', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l', 00H, ' '
	DB	00H, 's', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H
	DB	' ', 00H, '1', 00H, '4', 00H, '.', 00H, '0', 00H, '\', 00H, 'v'
	DB	00H, 'c', 00H, '\', 00H, 'i', 00H, 'n', 00H, 'c', 00H, 'l', 00H
	DB	'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'v', 00H, 'e', 00H, 'c'
	DB	00H, 't', 00H, 'o', 00H, 'r', 00H, 00H, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@EIAGFEK@?4?4?1Content?1player?4bmp?$AA@
CONST	SEGMENT
??_C@_0BG@EIAGFEK@?4?4?1Content?1player?4bmp?$AA@ DB '../Content/player.b'
	DB	'mp', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1GI@DHJGPFNI@?$AA?$CC?$AA_?$AAP?$AAt?$AAr?$AA_?$AAu?$AAs?$AAe?$AAr?$AA?5?$AA?9?$AA?5?$AA_?$AAP?$AAt?$AAr?$AA_?$AAc?$AAo?$AAn?$AAt?$AAa?$AAi?$AAn?$AAe?$AAr?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA_@
CONST	SEGMENT
??_C@_1GI@DHJGPFNI@?$AA?$CC?$AA_?$AAP?$AAt?$AAr?$AA_?$AAu?$AAs?$AAe?$AAr?$AA?5?$AA?9?$AA?5?$AA_?$AAP?$AAt?$AAr?$AA_?$AAc?$AAo?$AAn?$AAt?$AAa?$AAi?$AAn?$AAe?$AAr?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA_@ DB '"'
	DB	00H, '_', 00H, 'P', 00H, 't', 00H, 'r', 00H, '_', 00H, 'u', 00H
	DB	's', 00H, 'e', 00H, 'r', 00H, ' ', 00H, '-', 00H, ' ', 00H, '_'
	DB	00H, 'P', 00H, 't', 00H, 'r', 00H, '_', 00H, 'c', 00H, 'o', 00H
	DB	'n', 00H, 't', 00H, 'a', 00H, 'i', 00H, 'n', 00H, 'e', 00H, 'r'
	DB	00H, ' ', 00H, '<', 00H, '=', 00H, ' ', 00H, '_', 00H, 'N', 00H
	DB	'O', 00H, 'N', 00H, '_', 00H, 'U', 00H, 'S', 00H, 'E', 00H, 'R'
	DB	00H, '_', 00H, 'S', 00H, 'I', 00H, 'Z', 00H, 'E', 00H, '"', 00H
	DB	' ', 00H, '&', 00H, '&', 00H, ' ', 00H, '0', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@BLHJCAL@_Ptr_user?5?9?5_Ptr_container?5?$DM?$DN?5_N@
CONST	SEGMENT
??_C@_0CN@BLHJCAL@_Ptr_user?5?9?5_Ptr_container?5?$DM?$DN?5_N@ DB '_Ptr_u'
	DB	'ser - _Ptr_container <= _NON_USER_SIZE', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1HA@NAPGMHAO@?$AA?$CC?$AA2?$AA?5?$AA?$CK?$AA?5?$AAs?$AAi?$AAz?$AAe?$AAo?$AAf?$AA?$CI?$AAv?$AAo?$AAi?$AAd?$AA?5?$AA?$CK?$AA?$CJ?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA_?$AAP?$AAt?$AAr?$AA_?$AAu?$AAs?$AAe?$AAr@
CONST	SEGMENT
??_C@_1HA@NAPGMHAO@?$AA?$CC?$AA2?$AA?5?$AA?$CK?$AA?5?$AAs?$AAi?$AAz?$AAe?$AAo?$AAf?$AA?$CI?$AAv?$AAo?$AAi?$AAd?$AA?5?$AA?$CK?$AA?$CJ?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA_?$AAP?$AAt?$AAr?$AA_?$AAu?$AAs?$AAe?$AAr@ DB '"'
	DB	00H, '2', 00H, ' ', 00H, '*', 00H, ' ', 00H, 's', 00H, 'i', 00H
	DB	'z', 00H, 'e', 00H, 'o', 00H, 'f', 00H, '(', 00H, 'v', 00H, 'o'
	DB	00H, 'i', 00H, 'd', 00H, ' ', 00H, '*', 00H, ')', 00H, ' ', 00H
	DB	'<', 00H, '=', 00H, ' ', 00H, '_', 00H, 'P', 00H, 't', 00H, 'r'
	DB	00H, '_', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'r', 00H, ' ', 00H
	DB	'-', 00H, ' ', 00H, '_', 00H, 'P', 00H, 't', 00H, 'r', 00H, '_'
	DB	00H, 'c', 00H, 'o', 00H, 'n', 00H, 't', 00H, 'a', 00H, 'i', 00H
	DB	'n', 00H, 'e', 00H, 'r', 00H, '"', 00H, ' ', 00H, '&', 00H, '&'
	DB	00H, ' ', 00H, '0', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@GLFJLNCE@2?5?$CK?5sizeof?$CIvoid?5?$CK?$CJ?5?$DM?$DN?5_Ptr_user?5@
CONST	SEGMENT
??_C@_0DB@GLFJLNCE@2?5?$CK?5sizeof?$CIvoid?5?$CK?$CJ?5?$DM?$DN?5_Ptr_user?5@ DB '2'
	DB	' * sizeof(void *) <= _Ptr_user - _Ptr_container', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1EE@PDHAHDDC@?$AA?$CC?$AA_?$AAP?$AAt?$AAr?$AA_?$AAc?$AAo?$AAn?$AAt?$AAa?$AAi?$AAn?$AAe?$AAr?$AA?5?$AA?$DM?$AA?5?$AA_?$AAP?$AAt?$AAr?$AA_?$AAu?$AAs?$AAe?$AAr?$AA?$CC?$AA?5?$AA?$CG?$AA?$CG?$AA?5@
CONST	SEGMENT
??_C@_1EE@PDHAHDDC@?$AA?$CC?$AA_?$AAP?$AAt?$AAr?$AA_?$AAc?$AAo?$AAn?$AAt?$AAa?$AAi?$AAn?$AAe?$AAr?$AA?5?$AA?$DM?$AA?5?$AA_?$AAP?$AAt?$AAr?$AA_?$AAu?$AAs?$AAe?$AAr?$AA?$CC?$AA?5?$AA?$CG?$AA?$CG?$AA?5@ DB '"'
	DB	00H, '_', 00H, 'P', 00H, 't', 00H, 'r', 00H, '_', 00H, 'c', 00H
	DB	'o', 00H, 'n', 00H, 't', 00H, 'a', 00H, 'i', 00H, 'n', 00H, 'e'
	DB	00H, 'r', 00H, ' ', 00H, '<', 00H, ' ', 00H, '_', 00H, 'P', 00H
	DB	't', 00H, 'r', 00H, '_', 00H, 'u', 00H, 's', 00H, 'e', 00H, 'r'
	DB	00H, '"', 00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H, '0', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@OCKMEJON@_Ptr_container?5?$DM?5_Ptr_user?$AA@
CONST	SEGMENT
??_C@_0BL@OCKMEJON@_Ptr_container?5?$DM?5_Ptr_user?$AA@ DB '_Ptr_containe'
	DB	'r < _Ptr_user', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1JO@EKLKIEHP@?$AA?$CC?$AAr?$AAe?$AAi?$AAn?$AAt?$AAe?$AAr?$AAp?$AAr?$AAe?$AAt?$AA_?$AAc?$AAa?$AAs?$AAt?$AA?$DM?$AAu?$AAi?$AAn?$AAt?$AAp?$AAt?$AAr?$AA_?$AAt?$AA?5?$AA?$CK?$AA?$DO?$AA?$CI?$AA_@
CONST	SEGMENT
??_C@_1JO@EKLKIEHP@?$AA?$CC?$AAr?$AAe?$AAi?$AAn?$AAt?$AAe?$AAr?$AAp?$AAr?$AAe?$AAt?$AA_?$AAc?$AAa?$AAs?$AAt?$AA?$DM?$AAu?$AAi?$AAn?$AAt?$AAp?$AAt?$AAr?$AA_?$AAt?$AA?5?$AA?$CK?$AA?$DO?$AA?$CI?$AA_@ DB '"'
	DB	00H, 'r', 00H, 'e', 00H, 'i', 00H, 'n', 00H, 't', 00H, 'e', 00H
	DB	'r', 00H, 'p', 00H, 'r', 00H, 'e', 00H, 't', 00H, '_', 00H, 'c'
	DB	00H, 'a', 00H, 's', 00H, 't', 00H, '<', 00H, 'u', 00H, 'i', 00H
	DB	'n', 00H, 't', 00H, 'p', 00H, 't', 00H, 'r', 00H, '_', 00H, 't'
	DB	00H, ' ', 00H, '*', 00H, '>', 00H, '(', 00H, '_', 00H, 'P', 00H
	DB	't', 00H, 'r', 00H, '_', 00H, 'p', 00H, 't', 00H, 'r', 00H, ')'
	DB	00H, '[', 00H, '-', 00H, '1', 00H, ']', 00H, ' ', 00H, '=', 00H
	DB	'=', 00H, ' ', 00H, '_', 00H, 'B', 00H, 'I', 00H, 'G', 00H, '_'
	DB	00H, 'A', 00H, 'L', 00H, 'L', 00H, 'O', 00H, 'C', 00H, 'A', 00H
	DB	'T', 00H, 'I', 00H, 'O', 00H, 'N', 00H, '_', 00H, 'S', 00H, 'E'
	DB	00H, 'N', 00H, 'T', 00H, 'I', 00H, 'N', 00H, 'E', 00H, 'L', 00H
	DB	'"', 00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H, '0', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0EI@NOJHEJCJ@reinterpret_cast?$DMuintptr_t?5?$CK?$DO?$CI_P@
CONST	SEGMENT
??_C@_0EI@NOJHEJCJ@reinterpret_cast?$DMuintptr_t?5?$CK?$DO?$CI_P@ DB 'rei'
	DB	'nterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] == _BIG_ALLOCATION_S'
	DB	'ENTINEL', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1HE@CDMBFOKC@?$AA?$CC?$AA?$CI?$AA_?$AAP?$AAt?$AAr?$AA_?$AAu?$AAs?$AAe?$AAr?$AA?5?$AA?$CG?$AA?5?$AA?$CI?$AA_?$AAB?$AAI?$AAG?$AA_?$AAA?$AAL?$AAL?$AAO?$AAC?$AAA?$AAT?$AAI?$AAO?$AAN?$AA_?$AAA@
CONST	SEGMENT
??_C@_1HE@CDMBFOKC@?$AA?$CC?$AA?$CI?$AA_?$AAP?$AAt?$AAr?$AA_?$AAu?$AAs?$AAe?$AAr?$AA?5?$AA?$CG?$AA?5?$AA?$CI?$AA_?$AAB?$AAI?$AAG?$AA_?$AAA?$AAL?$AAL?$AAO?$AAC?$AAA?$AAT?$AAI?$AAO?$AAN?$AA_?$AAA@ DB '"'
	DB	00H, '(', 00H, '_', 00H, 'P', 00H, 't', 00H, 'r', 00H, '_', 00H
	DB	'u', 00H, 's', 00H, 'e', 00H, 'r', 00H, ' ', 00H, '&', 00H, ' '
	DB	00H, '(', 00H, '_', 00H, 'B', 00H, 'I', 00H, 'G', 00H, '_', 00H
	DB	'A', 00H, 'L', 00H, 'L', 00H, 'O', 00H, 'C', 00H, 'A', 00H, 'T'
	DB	00H, 'I', 00H, 'O', 00H, 'N', 00H, '_', 00H, 'A', 00H, 'L', 00H
	DB	'I', 00H, 'G', 00H, 'N', 00H, 'M', 00H, 'E', 00H, 'N', 00H, 'T'
	DB	00H, ' ', 00H, '-', 00H, ' ', 00H, '1', 00H, ')', 00H, ')', 00H
	DB	' ', 00H, '=', 00H, '=', 00H, ' ', 00H, '0', 00H, '"', 00H, ' '
	DB	00H, '&', 00H, '&', 00H, ' ', 00H, '0', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@GBGGGKGG@?$CI_Ptr_user?5?$CG?5?$CI_BIG_ALLOCATION_AL@
CONST	SEGMENT
??_C@_0DD@GBGGGKGG@?$CI_Ptr_user?5?$CG?5?$CI_BIG_ALLOCATION_AL@ DB '(_Ptr'
	DB	'_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CC@LOFJFFDB@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAD?$AAe?$AAa?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1CC@LOFJFFDB@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAD?$AAe?$AAa?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAe?$AA?$AA@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'D', 00H
	DB	'e', 00H, 'a', 00H, 'l', 00H, 'l', 00H, 'o', 00H, 'c', 00H, 'a'
	DB	00H, 't', 00H, 'e', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_1EI@MLOBABC@?$AA?$CC?$AA_?$AAC?$AAo?$AAu?$AAn?$AAt?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA?$CI?$AAs?$AAi?$AAz?$AAe?$AA_?$AAt?$AA?$CJ?$AA?$CI?$AA?9?$AA1?$AA?$CJ?$AA?5?$AA?1?$AA?5?$AA_?$AAS?$AAz?$AA?$CC?$AA?5?$AA?$CG@
CONST	SEGMENT
??_C@_1EI@MLOBABC@?$AA?$CC?$AA_?$AAC?$AAo?$AAu?$AAn?$AAt?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA?$CI?$AAs?$AAi?$AAz?$AAe?$AA_?$AAt?$AA?$CJ?$AA?$CI?$AA?9?$AA1?$AA?$CJ?$AA?5?$AA?1?$AA?5?$AA_?$AAS?$AAz?$AA?$CC?$AA?5?$AA?$CG@ DB '"'
	DB	00H, '_', 00H, 'C', 00H, 'o', 00H, 'u', 00H, 'n', 00H, 't', 00H
	DB	' ', 00H, '<', 00H, '=', 00H, ' ', 00H, '(', 00H, 's', 00H, 'i'
	DB	00H, 'z', 00H, 'e', 00H, '_', 00H, 't', 00H, ')', 00H, '(', 00H
	DB	'-', 00H, '1', 00H, ')', 00H, ' ', 00H, '/', 00H, ' ', 00H, '_'
	DB	00H, 'S', 00H, 'z', 00H, '"', 00H, ' ', 00H, '&', 00H, '&', 00H
	DB	' ', 00H, '0', 00H, 00H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@HMCJOMKN@_Count?5?$DM?$DN?5?$CIsize_t?$CJ?$CI?91?$CJ?5?1?5_Sz?$AA@
CONST	SEGMENT
??_C@_0BN@HMCJOMKN@_Count?5?$DM?$DN?5?$CIsize_t?$CJ?$CI?91?$CJ?5?1?5_Sz?$AA@ DB '_'
	DB	'Count <= (size_t)(-1) / _Sz', 00H		; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??_Deallocate@std@@YAXPAXII@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??_Deallocate@std@@YAXPAXII@Z@4JA DD 05cH ; `std::_Deallocate'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1CC@GKJLLHIM@?$AA?$CC?$AA_?$AAP?$AAt?$AAr?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0?$AA?$CC?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1CC@GKJLLHIM@?$AA?$CC?$AA_?$AAP?$AAt?$AAr?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0?$AA?$CC?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA0?$AA?$AA@ DB '"'
	DB	00H, '_', 00H, 'P', 00H, 't', 00H, 'r', 00H, ' ', 00H, '!', 00H
	DB	'=', 00H, ' ', 00H, '0', 00H, '"', 00H, ' ', 00H, '&', 00H, '&'
	DB	00H, ' ', 00H, '0', 00H, 00H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09GLJCAGLP@_Ptr?5?$CB?$DN?50?$AA@
CONST	SEGMENT
??_C@_09GLJCAGLP@_Ptr?5?$CB?$DN?50?$AA@ DB '_Ptr != 0', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@
CONST	SEGMENT
??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@ DB '"'
	DB	00H, 'i', 00H, 'n', 00H, 'v', 00H, 'a', 00H, 'l', 00H, 'i', 00H
	DB	'd', 00H, ' ', 00H, 'a', 00H, 'r', 00H, 'g', 00H, 'u', 00H, 'm'
	DB	00H, 'e', 00H, 'n', 00H, 't', 00H, '"', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1BO@NKFMJPA@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAe?$AA?$AA@
CONST	SEGMENT
??_C@_1BO@NKFMJPA@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAe?$AA?$AA@ DB 's'
	DB	00H, 't', 00H, 'd', 00H, ':', 00H, ':', 00H, '_', 00H, 'A', 00H
	DB	'l', 00H, 'l', 00H, 'o', 00H, 'c', 00H, 'a', 00H, 't', 00H, 'e'
	DB	00H, 00H, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_1JA@DKOIEICI@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
CONST	SEGMENT
??_C@_1JA@DKOIEICI@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ DB 'c'
	DB	00H, ':', 00H, '\', 00H, 'p', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'f', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 's', 00H, ' ', 00H, '(', 00H, 'x', 00H, '8', 00H
	DB	'6', 00H, ')', 00H, '\', 00H, 'm', 00H, 'i', 00H, 'c', 00H, 'r'
	DB	00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H, ' ', 00H
	DB	'v', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l', 00H, ' '
	DB	00H, 's', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H
	DB	' ', 00H, '1', 00H, '4', 00H, '.', 00H, '0', 00H, '\', 00H, 'v'
	DB	00H, 'c', 00H, '\', 00H, 'i', 00H, 'n', 00H, 'c', 00H, 'l', 00H
	DB	'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'x', 00H, 'm', 00H, 'e'
	DB	00H, 'm', 00H, 'o', 00H, 'r', 00H, 'y', 00H, '0', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_17CNPHIMPH@?$AA?$CF?$AAl?$AAs?$AA?$AA@
CONST	SEGMENT
??_C@_17CNPHIMPH@?$AA?$CF?$AAl?$AAs?$AA?$AA@ DB '%', 00H, 'l', 00H, 's', 00H
	DB	00H, 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_1DG@HGDKEBPG@?$AA?$CC?$AA_?$AAP?$AAt?$AAr?$AA_?$AAc?$AAo?$AAn?$AAt?$AAa?$AAi?$AAn?$AAe?$AAr?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0?$AA?$CC?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA0?$AA?$AA@
CONST	SEGMENT
??_C@_1DG@HGDKEBPG@?$AA?$CC?$AA_?$AAP?$AAt?$AAr?$AA_?$AAc?$AAo?$AAn?$AAt?$AAa?$AAi?$AAn?$AAe?$AAr?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0?$AA?$CC?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA0?$AA?$AA@ DB '"'
	DB	00H, '_', 00H, 'P', 00H, 't', 00H, 'r', 00H, '_', 00H, 'c', 00H
	DB	'o', 00H, 'n', 00H, 't', 00H, 'a', 00H, 'i', 00H, 'n', 00H, 'e'
	DB	00H, 'r', 00H, ' ', 00H, '!', 00H, '=', 00H, ' ', 00H, '0', 00H
	DB	'"', 00H, ' ', 00H, '&', 00H, '&', 00H, ' ', 00H, '0', 00H, 00H
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@LMNLACIC@_Ptr_container?5?$CB?$DN?50?$AA@
CONST	SEGMENT
??_C@_0BE@LMNLACIC@_Ptr_container?5?$CB?$DN?50?$AA@ DB '_Ptr_container !='
	DB	' 0', 00H					; `string'
CONST	ENDS
;	COMDAT ?__LINE__Var@?0??_Allocate@std@@YAPAXII_N@Z@4JA
_DATA	SEGMENT
?__LINE__Var@?0??_Allocate@std@@YAPAXII_N@Z@4JA DD 030H	; `std::_Allocate'::`1'::__LINE__Var
_DATA	ENDS
;	COMDAT ??_C@_1DC@POOIKBAO@?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5?$AAC?$AAO?$AAR?$AAR?$AAU?$AAP?$AAT?$AAE?$AAD?$AA?$CB?$AA?$AA@
CONST	SEGMENT
??_C@_1DC@POOIKBAO@?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5?$AAC?$AAO?$AAR?$AAR?$AAU?$AAP?$AAT?$AAE?$AAD?$AA?$CB?$AA?$AA@ DB 'I'
	DB	00H, 'T', 00H, 'E', 00H, 'R', 00H, 'A', 00H, 'T', 00H, 'O', 00H
	DB	'R', 00H, ' ', 00H, 'L', 00H, 'I', 00H, 'S', 00H, 'T', 00H, ' '
	DB	00H, 'C', 00H, 'O', 00H, 'R', 00H, 'R', 00H, 'U', 00H, 'P', 00H
	DB	'T', 00H, 'E', 00H, 'D', 00H, '!', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_1JA@MHADJNIL@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
CONST	SEGMENT
??_C@_1JA@MHADJNIL@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@ DB 'c'
	DB	00H, ':', 00H, '\', 00H, 'p', 00H, 'r', 00H, 'o', 00H, 'g', 00H
	DB	'r', 00H, 'a', 00H, 'm', 00H, ' ', 00H, 'f', 00H, 'i', 00H, 'l'
	DB	00H, 'e', 00H, 's', 00H, ' ', 00H, '(', 00H, 'x', 00H, '8', 00H
	DB	'6', 00H, ')', 00H, '\', 00H, 'm', 00H, 'i', 00H, 'c', 00H, 'r'
	DB	00H, 'o', 00H, 's', 00H, 'o', 00H, 'f', 00H, 't', 00H, ' ', 00H
	DB	'v', 00H, 'i', 00H, 's', 00H, 'u', 00H, 'a', 00H, 'l', 00H, ' '
	DB	00H, 's', 00H, 't', 00H, 'u', 00H, 'd', 00H, 'i', 00H, 'o', 00H
	DB	' ', 00H, '1', 00H, '4', 00H, '.', 00H, '0', 00H, '\', 00H, 'v'
	DB	00H, 'c', 00H, '\', 00H, 'i', 00H, 'n', 00H, 'c', 00H, 'l', 00H
	DB	'u', 00H, 'd', 00H, 'e', 00H, '\', 00H, 'x', 00H, 'u', 00H, 't'
	DB	00H, 'i', 00H, 'l', 00H, 'i', 00H, 't', 00H, 'y', 00H, 00H, 00H ; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Uninitialized_move_al_unchecked1@PAUTile@@PAU1@V?$allocator@UTile@@@std@@@std@@YAPAUTile@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UTile@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninitialized_move_al_unchecked1@PAUTile@@PAU1@V?$allocator@UTile@@@std@@@std@@YAPAUTile@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UTile@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z$0
__unwindtable$??$_Uninitialized_move_al_unchecked1@PAUTile@@PAU1@V?$allocator@UTile@@@std@@@std@@YAPAUTile@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UTile@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninitialized_move_al_unchecked1@PAUTile@@PAU1@V?$allocator@UTile@@@std@@@std@@YAPAUTile@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UTile@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninitialized_move_al_unchecked1@PAUTile@@PAU1@V?$allocator@UTile@@@std@@@std@@YAPAUTile@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UTile@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z$2
__ehfuncinfo$??$_Uninitialized_move_al_unchecked1@PAUTile@@PAU1@V?$allocator@UTile@@@std@@@std@@YAPAUTile@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UTile@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninitialized_move_al_unchecked1@PAUTile@@PAU1@V?$allocator@UTile@@@std@@@std@@YAPAUTile@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UTile@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninitialized_move_al_unchecked1@PAUTile@@PAU1@V?$allocator@UTile@@@std@@@std@@YAPAUTile@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UTile@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??$_Uninitialized_copy_al_unchecked1@PBUPushTile@@PAU1@V?$allocator@UPushTile@@@std@@@std@@YAPAUPushTile@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??$_Uninitialized_copy_al_unchecked1@PBUPushTile@@PAU1@V?$allocator@UPushTile@@@std@@@std@@YAPAUPushTile@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z$0
__unwindtable$??$_Uninitialized_copy_al_unchecked1@PBUPushTile@@PAU1@V?$allocator@UPushTile@@@std@@@std@@YAPAUPushTile@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$??$_Uninitialized_copy_al_unchecked1@PBUPushTile@@PAU1@V?$allocator@UPushTile@@@std@@@std@@YAPAUPushTile@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$??$_Uninitialized_copy_al_unchecked1@PBUPushTile@@PAU1@V?$allocator@UPushTile@@@std@@@std@@YAPAUPushTile@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z$2
__ehfuncinfo$??$_Uninitialized_copy_al_unchecked1@PBUPushTile@@PAU1@V?$allocator@UPushTile@@@std@@@std@@YAPAUPushTile@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninitialized_copy_al_unchecked1@PBUPushTile@@PAU1@V?$allocator@UPushTile@@@std@@@std@@YAPAUPushTile@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??$_Uninitialized_copy_al_unchecked1@PBUPushTile@@PAU1@V?$allocator@UPushTile@@@std@@@std@@YAPAUPushTile@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@YAPBUPushTile@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@YAPBUPushTile@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@0@@Z$0
__ehfuncinfo$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@YAPBUPushTile@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@YAPBUPushTile@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Debug_range2@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Debug_range2@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Debug_range2@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z$1
__ehfuncinfo$??$_Debug_range2@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Debug_range2@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Debug_range2@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Debug_range2@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Debug_range2@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z$1
__ehfuncinfo$??$_Debug_range2@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Debug_range2@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@PAUPushTile@@V?$allocator@UPushTile@@@2@@std@@YAPAUPushTile@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@0@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@PAUPushTile@@V?$allocator@UPushTile@@@2@@std@@YAPAUPushTile@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@0@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@0@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@PAUPushTile@@V?$allocator@UPushTile@@@2@@std@@YAPAUPushTile@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@0@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@0@@Z$1
__ehfuncinfo$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@PAUPushTile@@V?$allocator@UPushTile@@@2@@std@@YAPAUPushTile@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@0@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@0@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@PAUPushTile@@V?$allocator@UPushTile@@@2@@std@@YAPAUPushTile@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@0@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@YAPAUTile@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@YAPAUTile@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@0@@Z$0
__ehfuncinfo$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@YAPAUTile@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@YAPAUTile@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Debug_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@0@0PB_WI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Debug_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@0@0PB_WI@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Debug_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@0@0PB_WI@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??$_Debug_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@0@0PB_WI@Z$2
__ehfuncinfo$??$_Debug_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@0@0PB_WI@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$_Debug_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@0@0PB_WI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@YAPAHV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@YAPAHV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@@Z$0
__ehfuncinfo$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@YAPAHV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@YAPAHV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Debug_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0PB_WI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Debug_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0PB_WI@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Debug_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0PB_WI@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??$_Debug_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0PB_WI@Z$2
__ehfuncinfo$??$_Debug_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0PB_WI@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$_Debug_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0PB_WI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@@?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@IAEPAUPushTile@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@1@0PAU2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@@?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@IAEPAUPushTile@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@1@0PAU2@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@@?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@IAEPAUPushTile@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@1@0PAU2@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@@?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@IAEPAUPushTile@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@1@0PAU2@@Z$2
__ehfuncinfo$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@@?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@IAEPAUPushTile@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@1@0PAU2@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@@?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@IAEPAUPushTile@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@1@0PAU2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$?0U?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@std@@X@?$_Vector_alloc@U?$_Vec_base_types@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$?0U?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@std@@X@?$_Vector_alloc@U?$_Vec_base_types@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@1@@Z$0
__ehfuncinfo$??$?0U?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@std@@X@?$_Vector_alloc@U?$_Vec_base_types@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??$?0U?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@std@@X@?$_Vector_alloc@U?$_Vec_base_types@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@UTile@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@0@V10@0ABUTile@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@UTile@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@0@V10@0ABUTile@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@UTile@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@0@V10@0ABUTile@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@UTile@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@0@V10@0ABUTile@@@Z$2
__ehfuncinfo$??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@UTile@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@0@V10@0ABUTile@@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@UTile@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@0@V10@0ABUTile@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$remove@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@UTile@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@0@V10@0ABUTile@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$remove@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@UTile@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@0@V10@0ABUTile@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$remove@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@UTile@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@0@V10@0ABUTile@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??$remove@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@UTile@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@0@V10@0ABUTile@@@Z$2
__ehfuncinfo$??$remove@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@UTile@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@0@V10@0ABUTile@@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$remove@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@UTile@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@0@V10@0ABUTile@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UMovingTile@@@std@@@std@@@std@@QAE@PAUMovingTile@@PBU_Container_base12@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UMovingTile@@@std@@@std@@@std@@QAE@PAUMovingTile@@PBU_Container_base12@1@@Z$0
__ehfuncinfo$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UMovingTile@@@std@@@std@@@std@@QAE@PAUMovingTile@@PBU_Container_base12@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UMovingTile@@@std@@@std@@@std@@QAE@PAUMovingTile@@PBU_Container_base12@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?end@?$vector@UMovingTile@@V?$allocator@UMovingTile@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UMovingTile@@@std@@@std@@@2@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?begin@?$vector@UMovingTile@@V?$allocator@UMovingTile@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UMovingTile@@@std@@@std@@@2@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UAirTile@@@std@@@std@@@std@@QAE@PAUAirTile@@PBU_Container_base12@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UAirTile@@@std@@@std@@@std@@QAE@PAUAirTile@@PBU_Container_base12@1@@Z$0
__ehfuncinfo$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UAirTile@@@std@@@std@@@std@@QAE@PAUAirTile@@PBU_Container_base12@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UAirTile@@@std@@@std@@@std@@QAE@PAUAirTile@@PBU_Container_base12@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?end@?$vector@UAirTile@@V?$allocator@UAirTile@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UAirTile@@@std@@@std@@@2@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?begin@?$vector@UAirTile@@V?$allocator@UAirTile@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UAirTile@@@std@@@std@@@2@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@W4<unnamed-enum-SDLK_UNKNOWN>@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@V10@0ABW4<unnamed-enum-SDLK_UNKNOWN>@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@W4<unnamed-enum-SDLK_UNKNOWN>@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@V10@0ABW4<unnamed-enum-SDLK_UNKNOWN>@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@W4<unnamed-enum-SDLK_UNKNOWN>@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@V10@0ABW4<unnamed-enum-SDLK_UNKNOWN>@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@W4<unnamed-enum-SDLK_UNKNOWN>@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@V10@0ABW4<unnamed-enum-SDLK_UNKNOWN>@@@Z$2
__ehfuncinfo$??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@W4<unnamed-enum-SDLK_UNKNOWN>@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@V10@0ABW4<unnamed-enum-SDLK_UNKNOWN>@@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@W4<unnamed-enum-SDLK_UNKNOWN>@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@V10@0ABW4<unnamed-enum-SDLK_UNKNOWN>@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z$0
__ehfuncinfo$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?FloatingMovement@@YAXM@Z DD 019930522H
	DD	010H
	DD	FLAT:__unwindtable$?FloatingMovement@@YAXM@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?FloatingMovement@@YAXM@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?FloatingMovement@@YAXM@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?FloatingMovement@@YAXM@Z$3
	DD	01H
	DD	FLAT:__unwindfunclet$?FloatingMovement@@YAXM@Z$4
	DD	02H
	DD	FLAT:__unwindfunclet$?FloatingMovement@@YAXM@Z$7
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?FloatingMovement@@YAXM@Z$8
	DD	04H
	DD	FLAT:__unwindfunclet$?FloatingMovement@@YAXM@Z$11
	DD	05H
	DD	FLAT:__unwindfunclet$?FloatingMovement@@YAXM@Z$12
	DD	06H
	DD	FLAT:__unwindfunclet$?FloatingMovement@@YAXM@Z$15
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?FloatingMovement@@YAXM@Z$16
	DD	08H
	DD	FLAT:__unwindfunclet$?FloatingMovement@@YAXM@Z$19
	DD	09H
	DD	FLAT:__unwindfunclet$?FloatingMovement@@YAXM@Z$20
	DD	0aH
	DD	FLAT:__unwindfunclet$?FloatingMovement@@YAXM@Z$23
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?FloatingMovement@@YAXM@Z$24
	DD	0cH
	DD	FLAT:__unwindfunclet$?FloatingMovement@@YAXM@Z$27
	DD	0dH
	DD	FLAT:__unwindfunclet$?FloatingMovement@@YAXM@Z$28
	DD	0eH
	DD	FLAT:__unwindfunclet$?FloatingMovement@@YAXM@Z$31
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?HandleCollision@@YAXUTile@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?HandleCollision@@YAXUTile@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?HandleCollision@@YAXUTile@@@Z$3
__ehfuncinfo$?HandleCollision@@YAXUTile@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?HandleCollision@@YAXUTile@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?UpdatePlayer@@YAXH@Z DD 019930522H
	DD	023H
	DD	FLAT:__unwindtable$?UpdatePlayer@@YAXH@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?UpdatePlayer@@YAXH@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?UpdatePlayer@@YAXH@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?UpdatePlayer@@YAXH@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?UpdatePlayer@@YAXH@Z$6
	DD	02H
	DD	FLAT:__unwindfunclet$?UpdatePlayer@@YAXH@Z$9
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?UpdatePlayer@@YAXH@Z$10
	DD	04H
	DD	FLAT:__unwindfunclet$?UpdatePlayer@@YAXH@Z$13
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?UpdatePlayer@@YAXH@Z$14
	DD	06H
	DD	FLAT:__unwindfunclet$?UpdatePlayer@@YAXH@Z$17
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?UpdatePlayer@@YAXH@Z$18
	DD	08H
	DD	FLAT:__unwindfunclet$?UpdatePlayer@@YAXH@Z$21
	DD	09H
	DD	FLAT:__unwindfunclet$?UpdatePlayer@@YAXH@Z$22
	DD	0aH
	DD	FLAT:__unwindfunclet$?UpdatePlayer@@YAXH@Z$25
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?UpdatePlayer@@YAXH@Z$26
	DD	0cH
	DD	FLAT:__unwindfunclet$?UpdatePlayer@@YAXH@Z$29
	DD	0dH
	DD	FLAT:__unwindfunclet$?UpdatePlayer@@YAXH@Z$30
	DD	0eH
	DD	FLAT:__unwindfunclet$?UpdatePlayer@@YAXH@Z$33
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?UpdatePlayer@@YAXH@Z$34
	DD	010H
	DD	FLAT:__unwindfunclet$?UpdatePlayer@@YAXH@Z$35
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?UpdatePlayer@@YAXH@Z$36
	DD	012H
	DD	FLAT:__unwindfunclet$?UpdatePlayer@@YAXH@Z$39
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?UpdatePlayer@@YAXH@Z$40
	DD	014H
	DD	FLAT:__unwindfunclet$?UpdatePlayer@@YAXH@Z$43
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?UpdatePlayer@@YAXH@Z$44
	DD	016H
	DD	FLAT:__unwindfunclet$?UpdatePlayer@@YAXH@Z$45
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?UpdatePlayer@@YAXH@Z$46
	DD	018H
	DD	FLAT:__unwindfunclet$?UpdatePlayer@@YAXH@Z$47
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?UpdatePlayer@@YAXH@Z$48
	DD	01aH
	DD	FLAT:__unwindfunclet$?UpdatePlayer@@YAXH@Z$49
	DD	01bH
	DD	FLAT:__unwindfunclet$?UpdatePlayer@@YAXH@Z$50
	DD	01aH
	DD	FLAT:__unwindfunclet$?UpdatePlayer@@YAXH@Z$51
	DD	01dH
	DD	FLAT:__unwindfunclet$?UpdatePlayer@@YAXH@Z$52
	DD	01eH
	DD	FLAT:__unwindfunclet$?UpdatePlayer@@YAXH@Z$53
	DD	01fH
	DD	FLAT:__unwindfunclet$?UpdatePlayer@@YAXH@Z$54
	DD	020H
	DD	FLAT:__unwindfunclet$?UpdatePlayer@@YAXH@Z$57
	DD	01fH
	DD	FLAT:__unwindfunclet$?UpdatePlayer@@YAXH@Z$57
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@QAE@PAUPushTile@@PBU_Container_base12@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@QAE@PAUPushTile@@PBU_Container_base12@1@@Z$0
__ehfuncinfo$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@QAE@PAUPushTile@@PBU_Container_base12@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@QAE@PAUPushTile@@PBU_Container_base12@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?end@?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@2@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?end@?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@2@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?begin@?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@2@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?begin@?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@2@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$??0?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@QAE@ABV01@@Z$5 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$??0?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@QAE@ABV01@@Z$0
__tryblocktable$??0?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@QAE@ABV01@@Z DD 01H
	DD	01H
	DD	02H
	DD	01H
	DD	FLAT:__catchsym$??0?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@QAE@ABV01@@Z$5
__unwindtable$??0?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@QAE@ABV01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@QAE@ABV01@@Z$2
	DD	00H
	DD	00H
	DD	00H
	DD	00H
__ehfuncinfo$??0?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@QAE@ABV01@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$??0?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@QAE@ABV01@@Z
	DD	01H
	DD	FLAT:__tryblocktable$??0?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@QAE@ABV01@@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$_Vector_alloc@U?$_Vec_base_types@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?GetDirection@PushTile@@QAEHV?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?GetDirection@PushTile@@QAEHV?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?GetDirection@PushTile@@QAEHV?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?GetDirection@PushTile@@QAEHV?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@Z$2
__ehfuncinfo$?GetDirection@PushTile@@QAEHV?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@Z DD 019930522H
	DD	03H
	DD	FLAT:__unwindtable$?GetDirection@PushTile@@QAEHV?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAE@PAUTile@@PBU_Container_base12@1@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAE@PAUTile@@PBU_Container_base12@1@@Z$0
__ehfuncinfo$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAE@PAUTile@@PBU_Container_base12@1@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAE@PAUTile@@PBU_Container_base12@1@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Orphan_range@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@IBEXPAUTile@@0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Orphan_range@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@IBEXPAUTile@@0@Z$0
__ehfuncinfo$?_Orphan_range@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@IBEXPAUTile@@0@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Orphan_range@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@IBEXPAUTile@@0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?_Reallocate@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@IAEXI@Z$2 DD 040H
	DD	00H
	DD	00H
	DD	FLAT:__catch$?_Reallocate@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@IAEXI@Z$0
__unwindtable$?_Reallocate@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@IAEXI@Z DD 0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
__tryblocktable$?_Reallocate@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@IAEXI@Z DD 00H
	DD	00H
	DD	01H
	DD	01H
	DD	FLAT:__catchsym$?_Reallocate@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@IAEXI@Z$2
__ehfuncinfo$?_Reallocate@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@IAEXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Reallocate@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@IAEXI@Z
	DD	01H
	DD	FLAT:__tryblocktable$?_Reallocate@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@IAEXI@Z
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?clear@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QAEXXZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?erase@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@2@0@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?erase@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@2@0@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?erase@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@2@0@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?erase@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@2@0@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$?erase@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@2@0@Z$1
	DD	01H
	DD	FLAT:__unwindfunclet$?erase@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@2@0@Z$2
	DD	02H
	DD	FLAT:__unwindfunclet$?erase@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@2@0@Z$3
	DD	01H
	DD	FLAT:__unwindfunclet$?erase@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@2@0@Z$5
	DD	04H
	DD	FLAT:__unwindfunclet$?erase@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@2@0@Z$7
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Make_iter@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Make_iter@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@2@@Z$0
__ehfuncinfo$?_Make_iter@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@2@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?_Make_iter@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?end@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@2@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?begin@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@2@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??0?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??0?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??0?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAE@XZ$0
__ehfuncinfo$??0?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??0?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z$1
__ehfuncinfo$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1_Iterator_base12@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z$0
__ehfuncinfo$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1_Container_base12@std@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
CRT$XCU	SEGMENT
?groundTileList$initializer$@@3P6AXXZA DD FLAT:??__EgroundTileList@@YAXXZ ; groundTileList$initializer$
CRT$XCU	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@UTile@@U1@@?$allocator@UTile@@@std@@QAEXPAUTile@@$$QAU2@@Z
_TEXT	SEGMENT
tv74 = -220						; size = 4
$T1 = -212						; size = 4
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@UTile@@U1@@?$allocator@UTile@@@std@@QAEXPAUTile@@$$QAU2@@Z PROC ; std::allocator<Tile>::construct<Tile,Tile>, COMDAT
; _this$ = ecx

; 736  : 		{	// construct _Objty(_Types...) at _Ptr

	push	ebp
	mov	ebp, esp
	sub	esp, 220				; 000000dcH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-220]
	mov	ecx, 55					; 00000037H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	push	32					; 00000020H
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T1[ebp], eax
	cmp	DWORD PTR $T1[ebp], 0
	je	SHORT $LN3@construct
	mov	ecx, DWORD PTR _<_Args_0>$[ebp]
	push	ecx
	call	??$forward@UTile@@@std@@YA$$QAUTile@@AAU1@@Z ; std::forward<Tile>
	add	esp, 4
	mov	ecx, 8
	mov	esi, eax
	mov	edi, DWORD PTR $T1[ebp]
	rep movsd
	mov	edx, DWORD PTR $T1[ebp]
	mov	DWORD PTR tv74[ebp], edx
	jmp	SHORT $LN1@construct
$LN3@construct:
	mov	DWORD PTR tv74[ebp], 0
$LN1@construct:

; 738  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 220				; 000000dcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
??$construct@UTile@@U1@@?$allocator@UTile@@@std@@QAEXPAUTile@@$$QAU2@@Z ENDP ; std::allocator<Tile>::construct<Tile,Tile>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@UPushTile@@ABU1@@?$allocator@UPushTile@@@std@@QAEXPAUPushTile@@ABU2@@Z
_TEXT	SEGMENT
tv74 = -220						; size = 4
$T1 = -212						; size = 4
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@UPushTile@@ABU1@@?$allocator@UPushTile@@@std@@QAEXPAUPushTile@@ABU2@@Z PROC ; std::allocator<PushTile>::construct<PushTile,PushTile const &>, COMDAT
; _this$ = ecx

; 736  : 		{	// construct _Objty(_Types...) at _Ptr

	push	ebp
	mov	ebp, esp
	sub	esp, 220				; 000000dcH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-220]
	mov	ecx, 55					; 00000037H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	push	48					; 00000030H
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T1[ebp], eax
	cmp	DWORD PTR $T1[ebp], 0
	je	SHORT $LN3@construct
	mov	ecx, DWORD PTR _<_Args_0>$[ebp]
	push	ecx
	call	??$forward@ABUPushTile@@@std@@YAABUPushTile@@ABU1@@Z ; std::forward<PushTile const &>
	add	esp, 4
	mov	ecx, 12					; 0000000cH
	mov	esi, eax
	mov	edi, DWORD PTR $T1[ebp]
	rep movsd
	mov	edx, DWORD PTR $T1[ebp]
	mov	DWORD PTR tv74[ebp], edx
	jmp	SHORT $LN1@construct
$LN3@construct:
	mov	DWORD PTR tv74[ebp], 0
$LN1@construct:

; 738  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 220				; 000000dcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
??$construct@UPushTile@@ABU1@@?$allocator@UPushTile@@@std@@QAEXPAUPushTile@@ABU2@@Z ENDP ; std::allocator<PushTile>::construct<PushTile,PushTile const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@UTile@@U1@@?$allocator_traits@V?$allocator@UTile@@@std@@@std@@SAXAAV?$allocator@UTile@@@1@PAUTile@@$$QAU3@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@UTile@@U1@@?$allocator_traits@V?$allocator@UTile@@@std@@@std@@SAXAAV?$allocator@UTile@@@1@PAUTile@@$$QAU3@@Z PROC ; std::allocator_traits<std::allocator<Tile> >::construct<Tile,Tile>, COMDAT

; 856  : 		{	// construct _Objty(_Types...) at _Ptr

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 857  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	push	eax
	call	??$forward@UTile@@@std@@YA$$QAUTile@@AAU1@@Z ; std::forward<Tile>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$construct@UTile@@U1@@?$allocator@UTile@@@std@@QAEXPAUTile@@$$QAU2@@Z ; std::allocator<Tile>::construct<Tile,Tile>

; 858  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$construct@UTile@@U1@@?$allocator_traits@V?$allocator@UTile@@@std@@@std@@SAXAAV?$allocator@UTile@@@1@PAUTile@@$$QAU3@@Z ENDP ; std::allocator_traits<std::allocator<Tile> >::construct<Tile,Tile>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@UTile@@@std@@YA$$QAUTile@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@UTile@@@std@@YA$$QAUTile@@AAU1@@Z PROC	; std::forward<Tile>, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$forward@UTile@@@std@@YA$$QAUTile@@AAU1@@Z ENDP	; std::forward<Tile>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@UPushTile@@ABU1@@?$allocator_traits@V?$allocator@UPushTile@@@std@@@std@@SAXAAV?$allocator@UPushTile@@@1@PAUPushTile@@ABU3@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@UPushTile@@ABU1@@?$allocator_traits@V?$allocator@UPushTile@@@std@@@std@@SAXAAV?$allocator@UPushTile@@@1@PAUPushTile@@ABU3@@Z PROC ; std::allocator_traits<std::allocator<PushTile> >::construct<PushTile,PushTile const &>, COMDAT

; 856  : 		{	// construct _Objty(_Types...) at _Ptr

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 857  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	push	eax
	call	??$forward@ABUPushTile@@@std@@YAABUPushTile@@ABU1@@Z ; std::forward<PushTile const &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$construct@UPushTile@@ABU1@@?$allocator@UPushTile@@@std@@QAEXPAUPushTile@@ABU2@@Z ; std::allocator<PushTile>::construct<PushTile,PushTile const &>

; 858  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$construct@UPushTile@@ABU1@@?$allocator_traits@V?$allocator@UPushTile@@@std@@@std@@SAXAAV?$allocator@UPushTile@@@1@PAUPushTile@@ABU3@@Z ENDP ; std::allocator_traits<std::allocator<PushTile> >::construct<PushTile,PushTile const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@ABUPushTile@@@std@@YAABUPushTile@@ABU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABUPushTile@@@std@@YAABUPushTile@@ABU1@@Z PROC ; std::forward<PushTile const &>, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$forward@ABUPushTile@@@std@@YAABUPushTile@@ABU1@@Z ENDP ; std::forward<PushTile const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@UTile@@U1@@?$_Wrap_alloc@V?$allocator@UTile@@@std@@@std@@QAEXPAUTile@@$$QAU2@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@UTile@@U1@@?$_Wrap_alloc@V?$allocator@UTile@@@std@@@std@@QAEXPAUTile@@$$QAU2@@Z PROC ; std::_Wrap_alloc<std::allocator<Tile> >::construct<Tile,Tile>, COMDAT
; _this$ = ecx

; 994  : 		{	// construct _Ty(_Types...) at _Ptr

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 995  : 		_Mytraits::construct(*this, _Ptr,

	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	push	eax
	call	??$forward@UTile@@@std@@YA$$QAUTile@@AAU1@@Z ; std::forward<Tile>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??$construct@UTile@@U1@@?$allocator_traits@V?$allocator@UTile@@@std@@@std@@SAXAAV?$allocator@UTile@@@1@PAUTile@@$$QAU3@@Z ; std::allocator_traits<std::allocator<Tile> >::construct<Tile,Tile>
	add	esp, 12					; 0000000cH

; 996  : 			_STD forward<_Types>(_Args)...);
; 997  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
??$construct@UTile@@U1@@?$_Wrap_alloc@V?$allocator@UTile@@@std@@@std@@QAEXPAUTile@@$$QAU2@@Z ENDP ; std::_Wrap_alloc<std::allocator<Tile> >::construct<Tile,Tile>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@UPushTile@@ABU1@@?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@std@@QAEXPAUPushTile@@ABU2@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@UPushTile@@ABU1@@?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@std@@QAEXPAUPushTile@@ABU2@@Z PROC ; std::_Wrap_alloc<std::allocator<PushTile> >::construct<PushTile,PushTile const &>, COMDAT
; _this$ = ecx

; 994  : 		{	// construct _Ty(_Types...) at _Ptr

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 995  : 		_Mytraits::construct(*this, _Ptr,

	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	push	eax
	call	??$forward@ABUPushTile@@@std@@YAABUPushTile@@ABU1@@Z ; std::forward<PushTile const &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??$construct@UPushTile@@ABU1@@?$allocator_traits@V?$allocator@UPushTile@@@std@@@std@@SAXAAV?$allocator@UPushTile@@@1@PAUPushTile@@ABU3@@Z ; std::allocator_traits<std::allocator<PushTile> >::construct<PushTile,PushTile const &>
	add	esp, 12					; 0000000cH

; 996  : 			_STD forward<_Types>(_Args)...);
; 997  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
??$construct@UPushTile@@ABU1@@?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@std@@QAEXPAUPushTile@@ABU2@@Z ENDP ; std::_Wrap_alloc<std::allocator<PushTile> >::construct<PushTile,PushTile const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move_al_unchecked1@PAUTile@@PAU1@V?$allocator@UTile@@@std@@@std@@YAPAUTile@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UTile@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z
_TEXT	SEGMENT
tv80 = -224						; size = 4
__Next$ = -24						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninitialized_move_al_unchecked1@PAUTile@@PAU1@V?$allocator@UTile@@@std@@@std@@YAPAUTile@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UTile@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z PROC ; std::_Uninitialized_move_al_unchecked1<Tile *,Tile *,std::allocator<Tile> >, COMDAT

; 273  : 	{	// move [_First, _Last) to raw _Dest, using _Al, no special optimization

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninitialized_move_al_unchecked1@PAUTile@@PAU1@V?$allocator@UTile@@@std@@@std@@YAPAUTile@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UTile@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-224]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 274  : 	_FwdIt _Next = _Dest;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 275  : 
; 276  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 277  : 	for (; _First != _Last; ++_Dest, (void)++_First)

	jmp	SHORT $LN4@Uninitiali
$LN2@Uninitiali:
	mov	eax, DWORD PTR __Dest$[ebp]
	add	eax, 32					; 00000020H
	mov	DWORD PTR __Dest$[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp]
	add	ecx, 32					; 00000020H
	mov	DWORD PTR __First$[ebp], ecx
$LN4@Uninitiali:
	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN3@Uninitiali

; 278  : 		_Al.construct(_Unfancy(_Dest), _STD move(*_First));

	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	call	??$_Unfancy@UTile@@@std@@YAPAUTile@@PAU1@@Z ; std::_Unfancy<Tile>
	add	esp, 4
	mov	DWORD PTR tv80[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$move@AAUTile@@@std@@YA$$QAUTile@@AAU1@@Z ; std::move<Tile &>
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR tv80[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$construct@UTile@@U1@@?$_Wrap_alloc@V?$allocator@UTile@@@std@@@std@@QAEXPAUTile@@$$QAU2@@Z ; std::_Wrap_alloc<std::allocator<Tile> >::construct<Tile,Tile>
	jmp	SHORT $LN2@Uninitiali
$LN3@Uninitiali:
	jmp	SHORT $LN7@Uninitiali
__catch$??$_Uninitialized_move_al_unchecked1@PAUTile@@PAU1@V?$allocator@UTile@@@std@@@std@@YAPAUTile@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UTile@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z$0:

; 279  : 	_CATCH_ALL
; 280  : 	_Destroy_range(_Next, _Dest, _Al);

	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Next$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@UTile@@@std@@PAUTile@@@std@@YAXPAUTile@@0AAU?$_Wrap_alloc@V?$allocator@UTile@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<Tile>,Tile *>
	add	esp, 12					; 0000000cH

; 281  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 282  : 	_CATCH_END

	mov	eax, $LN10@Uninitiali
	ret	0
$LN7@Uninitiali:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT __tryend$??$_Uninitialized_move_al_unchecked1@PAUTile@@PAU1@V?$allocator@UTile@@@std@@@std@@YAPAUTile@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UTile@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z$1
$LN10@Uninitiali:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninitialized_move_al_unchecked1@PAUTile@@PAU1@V?$allocator@UTile@@@std@@@std@@YAPAUTile@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UTile@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z$1:

; 283  : 
; 284  : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]
$LN6@Uninitiali:

; 285  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 224				; 000000e0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninitialized_move_al_unchecked1@PAUTile@@PAU1@V?$allocator@UTile@@@std@@@std@@YAPAUTile@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UTile@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-228]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninitialized_move_al_unchecked1@PAUTile@@PAU1@V?$allocator@UTile@@@std@@@std@@YAPAUTile@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UTile@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninitialized_move_al_unchecked1@PAUTile@@PAU1@V?$allocator@UTile@@@std@@@std@@YAPAUTile@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UTile@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ENDP ; std::_Uninitialized_move_al_unchecked1<Tile *,Tile *,std::allocator<Tile> >
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0U?$integral_constant@_N$00@std@@@_Any_tag@std@@QAE@$$QAU?$integral_constant@_N$00@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___formal$ = 8						; size = 4
??$?0U?$integral_constant@_N$00@std@@@_Any_tag@std@@QAE@$$QAU?$integral_constant@_N$00@1@@Z PROC ; std::_Any_tag::_Any_tag<std::integral_constant<bool,1> >, COMDAT
; _this$ = ecx

; 554  : 		constexpr _Any_tag(_Ty&&) _NOEXCEPT {}

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0U?$integral_constant@_N$00@std@@@_Any_tag@std@@QAE@$$QAU?$integral_constant@_N$00@1@@Z ENDP ; std::_Any_tag::_Any_tag<std::integral_constant<bool,1> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_copy_al_unchecked1@PBUPushTile@@PAU1@V?$allocator@UPushTile@@@std@@@std@@YAPAUPushTile@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z
_TEXT	SEGMENT
tv78 = -224						; size = 4
__Next$ = -24						; size = 4
__$EHRec$ = -16						; size = 16
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
___formal$ = 24						; size = 1
___formal$ = 28						; size = 1
??$_Uninitialized_copy_al_unchecked1@PBUPushTile@@PAU1@V?$allocator@UPushTile@@@std@@@std@@YAPAUPushTile@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z PROC ; std::_Uninitialized_copy_al_unchecked1<PushTile const *,PushTile *,std::allocator<PushTile> >, COMDAT

; 220  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, no special optimization

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninitialized_copy_al_unchecked1@PBUPushTile@@PAU1@V?$allocator@UPushTile@@@std@@@std@@YAPAUPushTile@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-224]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp

; 221  : 	_FwdIt _Next = _Dest;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 222  : 
; 223  : 	_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 224  : 	for (; _First != _Last; ++_Dest, (void)++_First)

	jmp	SHORT $LN4@Uninitiali
$LN2@Uninitiali:
	mov	eax, DWORD PTR __Dest$[ebp]
	add	eax, 48					; 00000030H
	mov	DWORD PTR __Dest$[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp]
	add	ecx, 48					; 00000030H
	mov	DWORD PTR __First$[ebp], ecx
$LN4@Uninitiali:
	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN3@Uninitiali

; 225  : 		_Al.construct(_Unfancy(_Dest), *_First);

	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	call	??$_Unfancy@UPushTile@@@std@@YAPAUPushTile@@PAU1@@Z ; std::_Unfancy<PushTile>
	add	esp, 4
	mov	DWORD PTR tv78[ebp], eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	mov	edx, DWORD PTR tv78[ebp]
	push	edx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$construct@UPushTile@@ABU1@@?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@std@@QAEXPAUPushTile@@ABU2@@Z ; std::_Wrap_alloc<std::allocator<PushTile> >::construct<PushTile,PushTile const &>
	jmp	SHORT $LN2@Uninitiali
$LN3@Uninitiali:
	jmp	SHORT $LN7@Uninitiali
__catch$??$_Uninitialized_copy_al_unchecked1@PBUPushTile@@PAU1@V?$allocator@UPushTile@@@std@@@std@@YAPAUPushTile@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z$0:

; 226  : 	_CATCH_ALL
; 227  : 	_Destroy_range(_Next, _Dest, _Al);

	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Next$[ebp]
	push	edx
	call	??$_Destroy_range@V?$allocator@UPushTile@@@std@@PAUPushTile@@@std@@YAXPAUPushTile@@0AAU?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<PushTile>,PushTile *>
	add	esp, 12					; 0000000cH

; 228  : 	_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 229  : 	_CATCH_END

	mov	eax, $LN10@Uninitiali
	ret	0
$LN7@Uninitiali:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT __tryend$??$_Uninitialized_copy_al_unchecked1@PBUPushTile@@PAU1@V?$allocator@UPushTile@@@std@@@std@@YAPAUPushTile@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z$1
$LN10@Uninitiali:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$??$_Uninitialized_copy_al_unchecked1@PBUPushTile@@PAU1@V?$allocator@UPushTile@@@std@@@std@@YAPAUPushTile@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z$1:

; 230  : 
; 231  : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]
$LN6@Uninitiali:

; 232  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 224				; 000000e0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??$_Uninitialized_copy_al_unchecked1@PBUPushTile@@PAU1@V?$allocator@UPushTile@@@std@@@std@@YAPAUPushTile@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-228]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninitialized_copy_al_unchecked1@PBUPushTile@@PAU1@V?$allocator@UPushTile@@@std@@@std@@YAPAUPushTile@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninitialized_copy_al_unchecked1@PBUPushTile@@PAU1@V?$allocator@UPushTile@@@std@@@std@@YAPAUPushTile@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ENDP ; std::_Uninitialized_copy_al_unchecked1<PushTile const *,PushTile *,std::allocator<PushTile> >
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$_Unfancy@UPushTile@@@std@@YAPAUPushTile@@PAU1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy@UPushTile@@@std@@YAPAUPushTile@@PAU1@@Z PROC ; std::_Unfancy<PushTile>, COMDAT

; 739  : 	{	// do nothing for plain pointers

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]

; 741  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unfancy@UPushTile@@@std@@YAPAUPushTile@@PAU1@@Z ENDP ; std::_Unfancy<PushTile>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Ptr_copy_cat@$$CBUPushTile@@U1@@std@@YA?AU_Trivially_copyable_ptr_iterator_tag@0@ABQBUPushTile@@ABQAU2@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Ptr_copy_cat@$$CBUPushTile@@U1@@std@@YA?AU_Trivially_copyable_ptr_iterator_tag@0@ABQBUPushTile@@ABQAU2@@Z PROC ; std::_Ptr_copy_cat<PushTile const ,PushTile>, COMDAT

; 792  : 	{	// return pointer copy optimization category for pointers

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 793  : 	return {};

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 794  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_copy_cat@$$CBUPushTile@@U1@@std@@YA?AU_Trivially_copyable_ptr_iterator_tag@0@ABQBUPushTile@@ABQAU2@@Z ENDP ; std::_Ptr_copy_cat<PushTile const ,PushTile>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Debug_pointer@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@@std@@YAXAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@0@PB_WI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Debug_pointer@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@@std@@YAXAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@0@PB_WI@Z PROC ; std::_Debug_pointer<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Tile> > > >, COMDAT

; 918  : 	{	// (don't) test non-pointer for non-singularity, arbitrary type

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 919  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Debug_pointer@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@@std@@YAXAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@0@PB_WI@Z ENDP ; std::_Debug_pointer<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Tile> > > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Debug_pointer@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YAXAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@PB_WI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Debug_pointer@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YAXAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@PB_WI@Z PROC ; std::_Debug_pointer<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > > >, COMDAT

; 918  : 	{	// (don't) test non-pointer for non-singularity, arbitrary type

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 919  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Debug_pointer@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YAXAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@PB_WI@Z ENDP ; std::_Debug_pointer<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$move@AAU?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAU?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@0@AAU10@@Z PROC ; std::move<std::_Wrap_alloc<std::allocator<PushTile> > &>, COMDAT

; 1291 : 	{	// forward _Arg as movable

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1292 : 	return (static_cast<typename remove_reference<_Ty>::type&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1293 : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$move@AAU?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@0@AAU10@@Z ENDP ; std::move<std::_Wrap_alloc<std::allocator<PushTile> > &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Rechecked@PAUTile@@PAU1@@std@@YAAAPAUTile@@AAPAU1@PAU1@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Src$ = 12						; size = 4
??$_Rechecked@PAUTile@@PAU1@@std@@YAAAPAUTile@@AAPAU1@PAU1@@Z PROC ; std::_Rechecked<Tile *,Tile *>, COMDAT

; 457  : 	{	// reset checked from unchecked, generic

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 458  : 	_Dest = _Src;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	ecx, DWORD PTR __Src$[ebp]
	mov	DWORD PTR [eax], ecx

; 459  : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]

; 460  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Rechecked@PAUTile@@PAU1@@std@@YAAAPAUTile@@AAPAU1@PAU1@@Z ENDP ; std::_Rechecked<Tile *,Tile *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move_al_unchecked@PAUTile@@PAU1@V?$allocator@UTile@@@std@@@std@@YAPAUTile@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UTile@@@std@@@0@@Z
_TEXT	SEGMENT
$T1 = -233						; size = 1
$T2 = -221						; size = 1
$T3 = -209						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move_al_unchecked@PAUTile@@PAU1@V?$allocator@UTile@@@std@@@std@@YAPAUTile@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UTile@@@std@@@0@@Z PROC ; std::_Uninitialized_move_al_unchecked<Tile *,Tile *,std::allocator<Tile> >, COMDAT

; 301  : 	{	// move [_First, _Last) to raw _Dest, using _Al, choose optimization

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 302  : 	typedef decltype(_STD move(*_First)) _Src_type; // TRANSITION MODULES VSO#222794
; 303  : 	return (_Uninitialized_move_al_unchecked1(_First, _Last, _Dest, _Al,

	lea	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	call	??$_Ptr_move_cat@UTile@@U1@@std@@YA?AU_Trivially_copyable_ptr_iterator_tag@0@ABQAUTile@@0@Z ; std::_Ptr_move_cat<Tile,Tile>
	add	esp, 8
	mov	ecx, esp
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??$?0U?$integral_constant@_N$00@std@@@_Any_tag@std@@QAE@$$QAU?$integral_constant@_N$00@1@@Z ; std::_Any_tag::_Any_tag<std::integral_constant<bool,1> >
	movzx	ecx, BYTE PTR $T1[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Uninitialized_move_al_unchecked1@PAUTile@@PAU1@V?$allocator@UTile@@@std@@@std@@YAPAUTile@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UTile@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ; std::_Uninitialized_move_al_unchecked1<Tile *,Tile *,std::allocator<Tile> >
	add	esp, 24					; 00000018H

; 304  : 		_Ptr_move_cat(_First, _Dest),
; 305  : 		_Uses_default_construct_t<_Alloc, decltype(_Unfancy(_Dest)), _Src_type>()));
; 306  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninitialized_move_al_unchecked@PAUTile@@PAU1@V?$allocator@UTile@@@std@@@std@@YAPAUTile@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UTile@@@std@@@0@@Z ENDP ; std::_Uninitialized_move_al_unchecked<Tile *,Tile *,std::allocator<Tile> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Unchecked@PAUTile@@@std@@YAPAUTile@@PAU1@@Z
_TEXT	SEGMENT
__Src$ = 8						; size = 4
??$_Unchecked@PAUTile@@@std@@YAPAUTile@@PAU1@@Z PROC	; std::_Unchecked<Tile *>, COMDAT

; 427  : 	{	// construct unchecked from checked, generic

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 428  : 	return (_Src);

	mov	eax, DWORD PTR __Src$[ebp]

; 429  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unchecked@PAUTile@@@std@@YAPAUTile@@PAU1@@Z ENDP	; std::_Unchecked<Tile *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
_TEXT	SEGMENT
tv74 = -220						; size = 4
$T1 = -212						; size = 4
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z PROC ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>, COMDAT
; _this$ = ecx

; 736  : 		{	// construct _Objty(_Types...) at _Ptr

	push	ebp
	mov	ebp, esp
	sub	esp, 220				; 000000dcH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-220]
	mov	ecx, 55					; 00000037H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	push	8
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T1[ebp], eax
	cmp	DWORD PTR $T1[ebp], 0
	je	SHORT $LN3@construct
	mov	ecx, DWORD PTR _<_Args_0>$[ebp]
	push	ecx
	call	??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>
	add	esp, 4
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR $T1[ebp]
	mov	DWORD PTR [ecx], edx
	mov	DWORD PTR [ecx+4], eax
	mov	edx, DWORD PTR $T1[ebp]
	mov	DWORD PTR tv74[ebp], edx
	jmp	SHORT $LN1@construct
$LN3@construct:
	mov	DWORD PTR tv74[ebp], 0
$LN1@construct:

; 738  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 220				; 000000dcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ENDP ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z PROC ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>, COMDAT
; _this$ = ecx

; 743  : 		{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 744  : 		_Ptr->~_Uty();
; 745  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z ENDP ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@UTile@@ABU1@@?$allocator@UTile@@@std@@QAEXPAUTile@@ABU2@@Z
_TEXT	SEGMENT
tv74 = -220						; size = 4
$T1 = -212						; size = 4
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@UTile@@ABU1@@?$allocator@UTile@@@std@@QAEXPAUTile@@ABU2@@Z PROC ; std::allocator<Tile>::construct<Tile,Tile const &>, COMDAT
; _this$ = ecx

; 736  : 		{	// construct _Objty(_Types...) at _Ptr

	push	ebp
	mov	ebp, esp
	sub	esp, 220				; 000000dcH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-220]
	mov	ecx, 55					; 00000037H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	push	32					; 00000020H
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T1[ebp], eax
	cmp	DWORD PTR $T1[ebp], 0
	je	SHORT $LN3@construct
	mov	ecx, DWORD PTR _<_Args_0>$[ebp]
	push	ecx
	call	??$forward@ABUTile@@@std@@YAABUTile@@ABU1@@Z ; std::forward<Tile const &>
	add	esp, 4
	mov	ecx, 8
	mov	esi, eax
	mov	edi, DWORD PTR $T1[ebp]
	rep movsd
	mov	edx, DWORD PTR $T1[ebp]
	mov	DWORD PTR tv74[ebp], edx
	jmp	SHORT $LN1@construct
$LN3@construct:
	mov	DWORD PTR tv74[ebp], 0
$LN1@construct:

; 738  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 220				; 000000dcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
??$construct@UTile@@ABU1@@?$allocator@UTile@@@std@@QAEXPAUTile@@ABU2@@Z ENDP ; std::allocator<Tile>::construct<Tile,Tile const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@UTile@@AAU1@@?$allocator@UTile@@@std@@QAEXPAUTile@@AAU2@@Z
_TEXT	SEGMENT
tv74 = -220						; size = 4
$T1 = -212						; size = 4
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@UTile@@AAU1@@?$allocator@UTile@@@std@@QAEXPAUTile@@AAU2@@Z PROC ; std::allocator<Tile>::construct<Tile,Tile &>, COMDAT
; _this$ = ecx

; 736  : 		{	// construct _Objty(_Types...) at _Ptr

	push	ebp
	mov	ebp, esp
	sub	esp, 220				; 000000dcH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-220]
	mov	ecx, 55					; 00000037H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 737  : 		::new ((void *)_Ptr) _Objty(_STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	push	32					; 00000020H
	call	??2@YAPAXIPAX@Z				; operator new
	add	esp, 8
	mov	DWORD PTR $T1[ebp], eax
	cmp	DWORD PTR $T1[ebp], 0
	je	SHORT $LN3@construct
	mov	ecx, DWORD PTR _<_Args_0>$[ebp]
	push	ecx
	call	??$forward@AAUTile@@@std@@YAAAUTile@@AAU1@@Z ; std::forward<Tile &>
	add	esp, 4
	mov	ecx, 8
	mov	esi, eax
	mov	edi, DWORD PTR $T1[ebp]
	rep movsd
	mov	edx, DWORD PTR $T1[ebp]
	mov	DWORD PTR tv74[ebp], edx
	jmp	SHORT $LN1@construct
$LN3@construct:
	mov	DWORD PTR tv74[ebp], 0
$LN1@construct:

; 738  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 220				; 000000dcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
??$construct@UTile@@AAU1@@?$allocator@UTile@@@std@@QAEXPAUTile@@AAU2@@Z ENDP ; std::allocator<Tile>::construct<Tile,Tile &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Copy_memmove@PAUTile@@PAU1@@std@@YAPAUTile@@PAU1@00@Z
_TEXT	SEGMENT
__Count$ = -44						; size = 4
__Dest_ch$ = -32					; size = 4
__Last_ch$ = -20					; size = 4
__First_ch$ = -8					; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Copy_memmove@PAUTile@@PAU1@@std@@YAPAUTile@@PAU1@00@Z PROC ; std::_Copy_memmove<Tile *,Tile *>, COMDAT

; 2301 : 	{	// implement copy-like function as memmove

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 2302 : 	const char * const _First_ch = reinterpret_cast<const char *>(_First);

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __First_ch$[ebp], eax

; 2303 : 	const char * const _Last_ch = reinterpret_cast<const char *>(_Last);

	mov	eax, DWORD PTR __Last$[ebp]
	mov	DWORD PTR __Last_ch$[ebp], eax

; 2304 : 	char * const _Dest_ch = reinterpret_cast<char *>(_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	DWORD PTR __Dest_ch$[ebp], eax

; 2305 : 	const size_t _Count = _Last_ch - _First_ch;

	mov	eax, DWORD PTR __Last_ch$[ebp]
	sub	eax, DWORD PTR __First_ch$[ebp]
	mov	DWORD PTR __Count$[ebp], eax

; 2306 : 	_CSTD memmove(_Dest_ch, _First_ch, _Count);

	mov	esi, esp
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First_ch$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Dest_ch$[ebp]
	push	edx
	call	DWORD PTR __imp__memmove
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 2307 : 	return (reinterpret_cast<_OutIt>(_Dest_ch + _Count));

	mov	eax, DWORD PTR __Dest_ch$[ebp]
	add	eax, DWORD PTR __Count$[ebp]

; 2308 : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Copy_memmove@PAUTile@@PAU1@@std@@YAPAUTile@@PAU1@00@Z ENDP ; std::_Copy_memmove<Tile *,Tile *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Rechecked@PAUPushTile@@PAU1@@std@@YAAAPAUPushTile@@AAPAU1@PAU1@@Z
_TEXT	SEGMENT
__Dest$ = 8						; size = 4
__Src$ = 12						; size = 4
??$_Rechecked@PAUPushTile@@PAU1@@std@@YAAAPAUPushTile@@AAPAU1@PAU1@@Z PROC ; std::_Rechecked<PushTile *,PushTile *>, COMDAT

; 457  : 	{	// reset checked from unchecked, generic

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 458  : 	_Dest = _Src;

	mov	eax, DWORD PTR __Dest$[ebp]
	mov	ecx, DWORD PTR __Src$[ebp]
	mov	DWORD PTR [eax], ecx

; 459  : 	return (_Dest);

	mov	eax, DWORD PTR __Dest$[ebp]

; 460  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Rechecked@PAUPushTile@@PAU1@@std@@YAAAPAUPushTile@@AAPAU1@PAU1@@Z ENDP ; std::_Rechecked<PushTile *,PushTile *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_copy_al_unchecked@PBUPushTile@@PAU1@V?$allocator@UPushTile@@@std@@@std@@YAPAUPushTile@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@0@@Z
_TEXT	SEGMENT
$T1 = -233						; size = 1
$T2 = -221						; size = 1
$T3 = -209						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_copy_al_unchecked@PBUPushTile@@PAU1@V?$allocator@UPushTile@@@std@@@std@@YAPAUPushTile@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@0@@Z PROC ; std::_Uninitialized_copy_al_unchecked<PushTile const *,PushTile *,std::allocator<PushTile> >, COMDAT

; 248  : 	{	// copy [_First, _Last) to raw _Dest, using _Al, choose optimization

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 249  : 	return (_Uninitialized_copy_al_unchecked1(_First, _Last, _Dest, _Al,

	lea	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T2[ebp]
	push	edx
	call	??$_Ptr_copy_cat@$$CBUPushTile@@U1@@std@@YA?AU_Trivially_copyable_ptr_iterator_tag@0@ABQBUPushTile@@ABQAU2@@Z ; std::_Ptr_copy_cat<PushTile const ,PushTile>
	add	esp, 8
	mov	ecx, esp
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??$?0U?$integral_constant@_N$00@std@@@_Any_tag@std@@QAE@$$QAU?$integral_constant@_N$00@1@@Z ; std::_Any_tag::_Any_tag<std::integral_constant<bool,1> >
	movzx	ecx, BYTE PTR $T1[ebp]
	push	ecx
	mov	edx, DWORD PTR __Al$[ebp]
	push	edx
	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Uninitialized_copy_al_unchecked1@PBUPushTile@@PAU1@V?$allocator@UPushTile@@@std@@@std@@YAPAUPushTile@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@0@U_General_ptr_iterator_tag@0@U_Any_tag@0@@Z ; std::_Uninitialized_copy_al_unchecked1<PushTile const *,PushTile *,std::allocator<PushTile> >
	add	esp, 24					; 00000018H

; 250  : 		_Ptr_copy_cat(_First, _Dest),
; 251  : 		_Uses_default_construct_t<_Alloc, decltype(_Unfancy(_Dest)), decltype(*_First)>()));
; 252  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninitialized_copy_al_unchecked@PBUPushTile@@PAU1@V?$allocator@UPushTile@@@std@@@std@@YAPAUPushTile@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@0@@Z ENDP ; std::_Uninitialized_copy_al_unchecked<PushTile const *,PushTile *,std::allocator<PushTile> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Unchecked@PAUPushTile@@@std@@YAPAUPushTile@@PAU1@@Z
_TEXT	SEGMENT
__Src$ = 8						; size = 4
??$_Unchecked@PAUPushTile@@@std@@YAPAUPushTile@@PAU1@@Z PROC ; std::_Unchecked<PushTile *>, COMDAT

; 427  : 	{	// construct unchecked from checked, generic

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 428  : 	return (_Src);

	mov	eax, DWORD PTR __Src$[ebp]

; 429  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unchecked@PAUPushTile@@@std@@YAPAUPushTile@@PAU1@@Z ENDP ; std::_Unchecked<PushTile *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@YAPBUPushTile@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
$T2 = -212						; size = 4
__$EHRec$ = -12						; size = 12
__Iter$ = 8						; size = 12
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@YAPBUPushTile@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@0@@Z PROC ; std::_Unchecked<std::_Vector_val<std::_Simple_types<PushTile> > >, COMDAT

; 271  : 	{	// convert to unchecked

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@YAPBUPushTile@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 272  : 	return (_Iter._Unchecked());

	lea	ecx, DWORD PTR __Iter$[ebp]
	call	?_Unchecked@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@QBEPBUPushTile@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PushTile> > >::_Unchecked
	mov	DWORD PTR $T2[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Iter$[ebp]
	call	??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR $T2[ebp]

; 273  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@YAPBUPushTile@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@0@@Z$0:
	lea	ecx, DWORD PTR __Iter$[ebp]
	jmp	??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@QAE@XZ
__ehhandler$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@YAPBUPushTile@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@YAPBUPushTile@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@YAPBUPushTile@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@0@@Z ENDP ; std::_Unchecked<std::_Vector_val<std::_Simple_types<PushTile> > >
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Find_unchecked1@PAUTile@@U1@@std@@YAPAUTile@@PAU1@0ABU1@U?$integral_constant@_N$0A@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Find_unchecked1@PAUTile@@U1@@std@@YAPAUTile@@PAU1@0ABU1@U?$integral_constant@_N$0A@@0@@Z PROC ; std::_Find_unchecked1<Tile *,Tile>, COMDAT

; 3256 : 	{	// find first matching _Val

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 3257 : 	for (; _First != _Last; ++_First)

	jmp	SHORT $LN4@Find_unche
$LN2@Find_unche:
	mov	eax, DWORD PTR __First$[ebp]
	add	eax, 32					; 00000020H
	mov	DWORD PTR __First$[ebp], eax
$LN4@Find_unche:
	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN3@Find_unche

; 3258 : 		if (*_First == _Val)

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	call	??8Tile@@QBEHABU0@@Z			; Tile::operator==
	test	eax, eax
	je	SHORT $LN5@Find_unche

; 3259 : 			break;

	jmp	SHORT $LN3@Find_unche
$LN5@Find_unche:

; 3260 : 	return (_First);

	jmp	SHORT $LN2@Find_unche
$LN3@Find_unche:
	mov	eax, DWORD PTR __First$[ebp]

; 3261 : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Find_unchecked1@PAUTile@@U1@@std@@YAPAUTile@@PAU1@0ABU1@U?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Find_unchecked1<Tile *,Tile>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$move@AAUTile@@@std@@YA$$QAUTile@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$move@AAUTile@@@std@@YA$$QAUTile@@AAU1@@Z PROC	; std::move<Tile &>, COMDAT

; 1291 : 	{	// forward _Arg as movable

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1292 : 	return (static_cast<typename remove_reference<_Ty>::type&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1293 : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$move@AAUTile@@@std@@YA$$QAUTile@@AAU1@@Z ENDP	; std::move<Tile &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Debug_range2@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 12
__Last$ = 20						; size = 12
__File$ = 32						; size = 4
__Line$ = 36						; size = 4
___formal$ = 40						; size = 1
??$_Debug_range2@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z PROC ; std::_Debug_range2<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Tile> > > >, COMDAT

; 953  : 	{	// test iterator pair for valid range, random-access iterators

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Debug_range2@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 954  : 	if (_First != _Last)

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Tile> > >::operator!=
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@Debug_rang

; 955  : 		{	// check for non-null pointers, valid range
; 956  : 		_DEBUG_POINTER2(_First, _File, _Line);

	mov	eax, DWORD PTR __Line$[ebp]
	push	eax
	mov	ecx, DWORD PTR __File$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Debug_pointer@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@@std@@YAXAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@0@PB_WI@Z ; std::_Debug_pointer<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Tile> > > >
	add	esp, 12					; 0000000cH

; 957  : 		_DEBUG_POINTER2(_Last, _File, _Line);

	mov	eax, DWORD PTR __Line$[ebp]
	push	eax
	mov	ecx, DWORD PTR __File$[ebp]
	push	ecx
	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	call	??$_Debug_pointer@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@@std@@YAXAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@0@PB_WI@Z ; std::_Debug_pointer<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Tile> > > >
	add	esp, 12					; 0000000cH

; 958  : 		if (_Last < _First)

	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	call	??M?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Tile> > >::operator<
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@Debug_rang

; 959  : 			_DEBUG_ERROR2("invalid iterator range", _File, _Line);

	mov	esi, esp
	mov	eax, DWORD PTR __Line$[ebp]
	push	eax
	mov	ecx, DWORD PTR __File$[ebp]
	push	ecx
	push	OFFSET ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@
	call	DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@Debug_rang:

; 960  : 		}
; 961  : 	}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __First$[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Last$[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Debug_range2@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z$0:
	lea	ecx, DWORD PTR __Last$[ebp]
	jmp	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$_Debug_range2@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z$1:
	lea	ecx, DWORD PTR __First$[ebp]
	jmp	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAE@XZ
__ehhandler$??$_Debug_range2@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Debug_range2@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Debug_range2@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z ENDP ; std::_Debug_range2<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Tile> > > >
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Find_unchecked1@PAHW4<unnamed-enum-SDLK_UNKNOWN>@@@std@@YAPAHPAH0ABW4<unnamed-enum-SDLK_UNKNOWN>@@U?$integral_constant@_N$0A@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Find_unchecked1@PAHW4<unnamed-enum-SDLK_UNKNOWN>@@@std@@YAPAHPAH0ABW4<unnamed-enum-SDLK_UNKNOWN>@@U?$integral_constant@_N$0A@@0@@Z PROC ; std::_Find_unchecked1<int *,enum <unnamed-enum-SDLK_UNKNOWN> >, COMDAT

; 3256 : 	{	// find first matching _Val

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 3257 : 	for (; _First != _Last; ++_First)

	jmp	SHORT $LN4@Find_unche
$LN2@Find_unche:
	mov	eax, DWORD PTR __First$[ebp]
	add	eax, 4
	mov	DWORD PTR __First$[ebp], eax
$LN4@Find_unche:
	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN3@Find_unche

; 3258 : 		if (*_First == _Val)

	mov	eax, DWORD PTR __First$[ebp]
	mov	ecx, DWORD PTR __Val$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $LN5@Find_unche

; 3259 : 			break;

	jmp	SHORT $LN3@Find_unche
$LN5@Find_unche:

; 3260 : 	return (_First);

	jmp	SHORT $LN2@Find_unche
$LN3@Find_unche:
	mov	eax, DWORD PTR __First$[ebp]

; 3261 : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Find_unchecked1@PAHW4<unnamed-enum-SDLK_UNKNOWN>@@@std@@YAPAHPAH0ABW4<unnamed-enum-SDLK_UNKNOWN>@@U?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Find_unchecked1<int *,enum <unnamed-enum-SDLK_UNKNOWN> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Debug_range2@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 12
__Last$ = 20						; size = 12
__File$ = 32						; size = 4
__Line$ = 36						; size = 4
___formal$ = 40						; size = 1
??$_Debug_range2@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z PROC ; std::_Debug_range2<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > > >, COMDAT

; 953  : 	{	// test iterator pair for valid range, random-access iterators

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Debug_range2@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 954  : 	if (_First != _Last)

	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	call	??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int> > >::operator!=
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@Debug_rang

; 955  : 		{	// check for non-null pointers, valid range
; 956  : 		_DEBUG_POINTER2(_First, _File, _Line);

	mov	eax, DWORD PTR __Line$[ebp]
	push	eax
	mov	ecx, DWORD PTR __File$[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Debug_pointer@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YAXAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@PB_WI@Z ; std::_Debug_pointer<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > > >
	add	esp, 12					; 0000000cH

; 957  : 		_DEBUG_POINTER2(_Last, _File, _Line);

	mov	eax, DWORD PTR __Line$[ebp]
	push	eax
	mov	ecx, DWORD PTR __File$[ebp]
	push	ecx
	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	call	??$_Debug_pointer@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YAXAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@PB_WI@Z ; std::_Debug_pointer<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > > >
	add	esp, 12					; 0000000cH

; 958  : 		if (_Last < _First)

	lea	eax, DWORD PTR __First$[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$[ebp]
	call	??M?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int> > >::operator<
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN2@Debug_rang

; 959  : 			_DEBUG_ERROR2("invalid iterator range", _File, _Line);

	mov	esi, esp
	mov	eax, DWORD PTR __Line$[ebp]
	push	eax
	mov	ecx, DWORD PTR __File$[ebp]
	push	ecx
	push	OFFSET ??_C@_1CO@DGLIKNHI@?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$AA@
	call	DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@Debug_rang:

; 960  : 		}
; 961  : 	}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __First$[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Last$[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Debug_range2@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z$0:
	lea	ecx, DWORD PTR __Last$[ebp]
	jmp	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$_Debug_range2@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z$1:
	lea	ecx, DWORD PTR __First$[ebp]
	jmp	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ
__ehhandler$??$_Debug_range2@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-208]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Debug_range2@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Debug_range2@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z ENDP ; std::_Debug_range2<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > > >
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_move@PAUTile@@PAU1@V?$allocator@UTile@@@std@@@std@@YAPAUTile@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UTile@@@std@@@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
__Al$ = 20						; size = 4
??$_Uninitialized_move@PAUTile@@PAU1@V?$allocator@UTile@@@std@@@std@@YAPAUTile@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UTile@@@std@@@0@@Z PROC ; std::_Uninitialized_move<Tile *,Tile *,std::allocator<Tile> >, COMDAT

; 313  : 	{	// move [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 314  : 		// note: only called internally from elsewhere in the STL, debug checks
; 315  : 		// and deprecation warnings omitted
; 316  : 	return (_Rechecked(_Dest,

	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Unchecked@PAUTile@@@std@@YAPAUTile@@PAU1@@Z ; std::_Unchecked<Tile *>
	add	esp, 4
	push	eax
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	call	??$_Unchecked@PAUTile@@@std@@YAPAUTile@@PAU1@@Z ; std::_Unchecked<Tile *>
	add	esp, 4
	push	eax
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Unchecked@PAUTile@@@std@@YAPAUTile@@PAU1@@Z ; std::_Unchecked<Tile *>
	add	esp, 4
	push	eax
	call	??$_Uninitialized_move_al_unchecked@PAUTile@@PAU1@V?$allocator@UTile@@@std@@@std@@YAPAUTile@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UTile@@@std@@@0@@Z ; std::_Uninitialized_move_al_unchecked<Tile *,Tile *,std::allocator<Tile> >
	add	esp, 16					; 00000010H
	push	eax
	lea	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Rechecked@PAUTile@@PAU1@@std@@YAAAPAUTile@@AAPAU1@PAU1@@Z ; std::_Rechecked<Tile *,Tile *>
	add	esp, 8
	mov	eax, DWORD PTR [eax]

; 317  : 		_Uninitialized_move_al_unchecked(_Unchecked(_First), _Unchecked(_Last),
; 318  : 			_Unchecked(_Dest), _Al)));
; 319  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Uninitialized_move@PAUTile@@PAU1@V?$allocator@UTile@@@std@@@std@@YAPAUTile@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UTile@@@std@@@0@@Z ENDP ; std::_Uninitialized_move<Tile *,Tile *,std::allocator<Tile> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@U_Container_proxy@std@@U12@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@$$QAU31@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@U_Container_proxy@std@@U12@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@$$QAU31@@Z PROC ; std::allocator_traits<std::allocator<std::_Container_proxy> >::construct<std::_Container_proxy,std::_Container_proxy>, COMDAT

; 856  : 		{	// construct _Objty(_Types...) at _Ptr

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 857  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	push	eax
	call	??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$construct@U_Container_proxy@std@@U12@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::allocator<std::_Container_proxy>::construct<std::_Container_proxy,std::_Container_proxy>

; 858  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$construct@U_Container_proxy@std@@U12@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@$$QAU31@@Z ENDP ; std::allocator_traits<std::allocator<std::_Container_proxy> >::construct<std::_Container_proxy,std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z PROC ; std::forward<std::_Container_proxy>, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ENDP ; std::forward<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?0UTile@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@UTile@@@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___formal$ = 8						; size = 4
??$?0UTile@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@UTile@@@1@@Z PROC ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><Tile>, COMDAT
; _this$ = ecx

; 709  : 		{	// construct from a related allocator (do nothing)

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 710  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0UTile@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@UTile@@@1@@Z ENDP ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><Tile>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@AAU?$_Wrap_alloc@V?$allocator@UTile@@@std@@@std@@@std@@YAAAU?$_Wrap_alloc@V?$allocator@UTile@@@std@@@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAU?$_Wrap_alloc@V?$allocator@UTile@@@std@@@std@@@std@@YAAAU?$_Wrap_alloc@V?$allocator@UTile@@@std@@@0@AAU10@@Z PROC ; std::forward<std::_Wrap_alloc<std::allocator<Tile> > &>, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$forward@AAU?$_Wrap_alloc@V?$allocator@UTile@@@std@@@std@@@std@@YAAAU?$_Wrap_alloc@V?$allocator@UTile@@@std@@@0@AAU10@@Z ENDP ; std::forward<std::_Wrap_alloc<std::allocator<Tile> > &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range1@V?$allocator@UPushTile@@@std@@PAUPushTile@@@std@@YAXPAUPushTile@@0AAU?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@0@U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range1@V?$allocator@UPushTile@@@std@@PAUPushTile@@@std@@YAXPAUPushTile@@0AAU?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@0@U?$integral_constant@_N$00@0@@Z PROC ; std::_Destroy_range1<std::allocator<PushTile>,PushTile *>, COMDAT

; 1107 : 	{	// destroy [_First, _Last), trivially destructible and default destroy

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1108 : 		// nothing to do
; 1109 : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Destroy_range1@V?$allocator@UPushTile@@@std@@PAUPushTile@@@std@@YAXPAUPushTile@@0AAU?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@0@U?$integral_constant@_N$00@0@@Z ENDP ; std::_Destroy_range1<std::allocator<PushTile>,PushTile *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@U_Container_proxy@std@@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
??$destroy@U_Container_proxy@std@@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@@Z PROC ; std::allocator_traits<std::allocator<std::_Container_proxy> >::destroy<std::_Container_proxy>, COMDAT

; 863  : 		{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 864  : 		_Al.destroy(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$destroy@U_Container_proxy@std@@@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::allocator<std::_Container_proxy>::destroy<std::_Container_proxy>

; 865  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$destroy@U_Container_proxy@std@@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@@Z ENDP ; std::allocator_traits<std::allocator<std::_Container_proxy> >::destroy<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?0UPushTile@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@UPushTile@@@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___formal$ = 8						; size = 4
??$?0UPushTile@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@UPushTile@@@1@@Z PROC ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><PushTile>, COMDAT
; _this$ = ecx

; 709  : 		{	// construct from a related allocator (do nothing)

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 710  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0UPushTile@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@UPushTile@@@1@@Z ENDP ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><PushTile>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@AAU?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@std@@@std@@YAAAU?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAU?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@std@@@std@@YAAAU?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@0@AAU10@@Z PROC ; std::forward<std::_Wrap_alloc<std::allocator<PushTile> > &>, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$forward@AAU?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@std@@@std@@YAAAU?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@0@AAU10@@Z ENDP ; std::forward<std::_Wrap_alloc<std::allocator<PushTile> > &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range1@V?$allocator@UTile@@@std@@PAUTile@@@std@@YAXPAUTile@@0AAU?$_Wrap_alloc@V?$allocator@UTile@@@std@@@0@U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Destroy_range1@V?$allocator@UTile@@@std@@PAUTile@@@std@@YAXPAUTile@@0AAU?$_Wrap_alloc@V?$allocator@UTile@@@std@@@0@U?$integral_constant@_N$00@0@@Z PROC ; std::_Destroy_range1<std::allocator<Tile>,Tile *>, COMDAT

; 1107 : 	{	// destroy [_First, _Last), trivially destructible and default destroy

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1108 : 		// nothing to do
; 1109 : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Destroy_range1@V?$allocator@UTile@@@std@@PAUTile@@@std@@YAXPAUTile@@0AAU?$_Wrap_alloc@V?$allocator@UTile@@@std@@@0@U?$integral_constant@_N$00@0@@Z ENDP ; std::_Destroy_range1<std::allocator<Tile>,Tile *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@V?$allocator@UPushTile@@@std@@@std@@YA$$QAV?$allocator@UPushTile@@@0@AAV10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@V?$allocator@UPushTile@@@std@@@std@@YA$$QAV?$allocator@UPushTile@@@0@AAV10@@Z PROC ; std::forward<std::allocator<PushTile> >, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$forward@V?$allocator@UPushTile@@@std@@@std@@YA$$QAV?$allocator@UPushTile@@@0@AAV10@@Z ENDP ; std::forward<std::allocator<PushTile> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@UTile@@ABU1@@?$allocator_traits@V?$allocator@UTile@@@std@@@std@@SAXAAV?$allocator@UTile@@@1@PAUTile@@ABU3@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@UTile@@ABU1@@?$allocator_traits@V?$allocator@UTile@@@std@@@std@@SAXAAV?$allocator@UTile@@@1@PAUTile@@ABU3@@Z PROC ; std::allocator_traits<std::allocator<Tile> >::construct<Tile,Tile const &>, COMDAT

; 856  : 		{	// construct _Objty(_Types...) at _Ptr

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 857  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	push	eax
	call	??$forward@ABUTile@@@std@@YAABUTile@@ABU1@@Z ; std::forward<Tile const &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$construct@UTile@@ABU1@@?$allocator@UTile@@@std@@QAEXPAUTile@@ABU2@@Z ; std::allocator<Tile>::construct<Tile,Tile const &>

; 858  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$construct@UTile@@ABU1@@?$allocator_traits@V?$allocator@UTile@@@std@@@std@@SAXAAV?$allocator@UTile@@@1@PAUTile@@ABU3@@Z ENDP ; std::allocator_traits<std::allocator<Tile> >::construct<Tile,Tile const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@ABUTile@@@std@@YAABUTile@@ABU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@ABUTile@@@std@@YAABUTile@@ABU1@@Z PROC	; std::forward<Tile const &>, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$forward@ABUTile@@@std@@YAABUTile@@ABU1@@Z ENDP	; std::forward<Tile const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@UTile@@AAU1@@?$allocator_traits@V?$allocator@UTile@@@std@@@std@@SAXAAV?$allocator@UTile@@@1@PAUTile@@AAU3@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
__Ptr$ = 12						; size = 4
_<_Args_0>$ = 16					; size = 4
??$construct@UTile@@AAU1@@?$allocator_traits@V?$allocator@UTile@@@std@@@std@@SAXAAV?$allocator@UTile@@@1@PAUTile@@AAU3@@Z PROC ; std::allocator_traits<std::allocator<Tile> >::construct<Tile,Tile &>, COMDAT

; 856  : 		{	// construct _Objty(_Types...) at _Ptr

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 857  : 		_Al.construct(_Ptr, _STD forward<_Types>(_Args)...);

	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	push	eax
	call	??$forward@AAUTile@@@std@@YAAAUTile@@AAU1@@Z ; std::forward<Tile &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Al$[ebp]
	call	??$construct@UTile@@AAU1@@?$allocator@UTile@@@std@@QAEXPAUTile@@AAU2@@Z ; std::allocator<Tile>::construct<Tile,Tile &>

; 858  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$construct@UTile@@AAU1@@?$allocator_traits@V?$allocator@UTile@@@std@@@std@@SAXAAV?$allocator@UTile@@@1@PAUTile@@AAU3@@Z ENDP ; std::allocator_traits<std::allocator<Tile> >::construct<Tile,Tile &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@AAUTile@@@std@@YAAAUTile@@AAU1@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@AAUTile@@@std@@YAAAUTile@@AAU1@@Z PROC	; std::forward<Tile &>, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$forward@AAUTile@@@std@@YAAAUTile@@AAU1@@Z ENDP	; std::forward<Tile &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Move_unchecked1@PAUTile@@PAU1@@std@@YAPAUTile@@PAU1@00U_Trivially_copyable_ptr_iterator_tag@0@@Z
_TEXT	SEGMENT
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
___formal$ = 20						; size = 1
??$_Move_unchecked1@PAUTile@@PAU1@@std@@YAPAUTile@@PAU1@00U_Trivially_copyable_ptr_iterator_tag@0@@Z PROC ; std::_Move_unchecked1<Tile *,Tile *>, COMDAT

; 2589 : 	{	// move [_First, _Last) to [_Dest, ...), memmove optimization

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 2590 : 	return (_Copy_memmove(_First, _Last, _Dest));

	mov	eax, DWORD PTR __Dest$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Copy_memmove@PAUTile@@PAU1@@std@@YAPAUTile@@PAU1@00@Z ; std::_Copy_memmove<Tile *,Tile *>
	add	esp, 12					; 0000000cH

; 2591 : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Move_unchecked1@PAUTile@@PAU1@@std@@YAPAUTile@@PAU1@00U_Trivially_copyable_ptr_iterator_tag@0@@Z ENDP ; std::_Move_unchecked1<Tile *,Tile *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Ptr_move_cat@UTile@@U1@@std@@YA?AU_Trivially_copyable_ptr_iterator_tag@0@ABQAUTile@@0@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 4
___formal$ = 16						; size = 4
??$_Ptr_move_cat@UTile@@U1@@std@@YA?AU_Trivially_copyable_ptr_iterator_tag@0@ABQAUTile@@0@Z PROC ; std::_Ptr_move_cat<Tile,Tile>, COMDAT

; 809  : 	{	// return pointer move optimization category for pointers

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 810  : 	return {};

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 811  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Ptr_move_cat@UTile@@U1@@std@@YA?AU_Trivially_copyable_ptr_iterator_tag@0@ABQAUTile@@0@Z ENDP ; std::_Ptr_move_cat<Tile,Tile>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory
;	COMDAT ??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@PAUPushTile@@V?$allocator@UPushTile@@@2@@std@@YAPAUPushTile@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@0@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@0@@Z
_TEXT	SEGMENT
tv67 = -260						; size = 4
tv148 = -256						; size = 4
tv147 = -252						; size = 4
tv144 = -248						; size = 4
tv143 = -244						; size = 4
$T2 = -236						; size = 4
$T3 = -224						; size = 4
$T4 = -212						; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 12
__Last$ = 20						; size = 12
__Dest$ = 32						; size = 4
__Al$ = 36						; size = 4
??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@PAUPushTile@@V?$allocator@UPushTile@@@2@@std@@YAPAUPushTile@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@0@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@0@@Z PROC ; std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PushTile> > >,PushTile *,std::allocator<PushTile> >, COMDAT

; 259  : 	{	// copy [_First, _Last) to raw _Dest, using _Al

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@PAUPushTile@@V?$allocator@UPushTile@@@2@@std@@YAPAUPushTile@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@0@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 248				; 000000f8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-260]
	mov	ecx, 62					; 0000003eH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 260  : 		// note: only called internally from elsewhere in the STL, debug checks
; 261  : 		// and deprecation warnings omitted
; 262  : 	return (_Rechecked(_Dest,

	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Dest$[ebp]
	push	ecx
	call	??$_Unchecked@PAUPushTile@@@std@@YAPAUPushTile@@PAU1@@Z ; std::_Unchecked<PushTile *>
	add	esp, 4
	push	eax
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T3[ebp], esp
	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	call	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv143[ebp], eax
	call	??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@YAPBUPushTile@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@0@@Z ; std::_Unchecked<std::_Vector_val<std::_Simple_types<PushTile> > >
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv144[ebp], eax
	mov	eax, DWORD PTR tv144[ebp]
	push	eax
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T2[ebp], esp
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv147[ebp], eax
	call	??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@YAPBUPushTile@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@0@@Z ; std::_Unchecked<std::_Vector_val<std::_Simple_types<PushTile> > >
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv148[ebp], eax
	mov	eax, DWORD PTR tv148[ebp]
	push	eax
	call	??$_Uninitialized_copy_al_unchecked@PBUPushTile@@PAU1@V?$allocator@UPushTile@@@std@@@std@@YAPAUPushTile@@PBU1@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@0@@Z ; std::_Uninitialized_copy_al_unchecked<PushTile const *,PushTile *,std::allocator<PushTile> >
	add	esp, 16					; 00000010H
	mov	DWORD PTR tv67[ebp], eax
	mov	ecx, DWORD PTR tv67[ebp]
	push	ecx
	lea	edx, DWORD PTR __Dest$[ebp]
	push	edx
	call	??$_Rechecked@PAUPushTile@@PAU1@@std@@YAAAPAUPushTile@@AAPAU1@PAU1@@Z ; std::_Rechecked<PushTile *,PushTile *>
	add	esp, 8
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR $T4[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __First$[ebp]
	call	??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Last$[ebp]
	call	??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR $T4[ebp]

; 263  : 		_Uninitialized_copy_al_unchecked(_Unchecked(_First), _Unchecked(_Last),
; 264  : 			_Unchecked(_Dest), _Al)));
; 265  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 260				; 00000104H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@PAUPushTile@@V?$allocator@UPushTile@@@2@@std@@YAPAUPushTile@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@0@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@0@@Z$0:
	lea	ecx, DWORD PTR __Last$[ebp]
	jmp	??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@PAUPushTile@@V?$allocator@UPushTile@@@2@@std@@YAPAUPushTile@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@0@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@0@@Z$1:
	lea	ecx, DWORD PTR __First$[ebp]
	jmp	??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@QAE@XZ
__ehhandler$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@PAUPushTile@@V?$allocator@UPushTile@@@2@@std@@YAPAUPushTile@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@0@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-264]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@PAUPushTile@@V?$allocator@UPushTile@@@2@@std@@YAPAUPushTile@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@0@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@PAUPushTile@@V?$allocator@UPushTile@@@2@@std@@YAPAUPushTile@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@0@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@0@@Z ENDP ; std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PushTile> > >,PushTile *,std::allocator<PushTile> >
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0U?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___formal$ = 8						; size = 1
__Val1$ = 12						; size = 4
??$?0U?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<PushTile> >,std::_Vector_val<std::_Simple_types<PushTile> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<PushTile> >,std::_Vector_val<std::_Simple_types<PushTile> >,1><std::_Wrap_alloc<std::allocator<PushTile> > >, COMDAT
; _this$ = ecx

; 289  : 		{	// construct from forwarded values

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 287  : 		: _Ty1(_STD forward<_Other1>(_Val1)),

	mov	eax, DWORD PTR __Val1$[ebp]
	push	eax
	call	??$forward@U?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@0@AAU10@@Z ; std::forward<std::_Wrap_alloc<std::allocator<PushTile> > >
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@std@@QAE@$$QAU01@@Z ; std::_Wrap_alloc<std::allocator<PushTile> >::_Wrap_alloc<std::allocator<PushTile> >

; 288  : 			_Myval2(_STD forward<_Other2>(_Val2)...)

	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<PushTile> >::_Vector_val<std::_Simple_types<PushTile> >

; 290  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
??$?0U?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<PushTile> >,std::_Vector_val<std::_Simple_types<PushTile> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<PushTile> >,std::_Vector_val<std::_Simple_types<PushTile> >,1><std::_Wrap_alloc<std::allocator<PushTile> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\type_traits
;	COMDAT ??$forward@U?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@0@AAU10@@Z
_TEXT	SEGMENT
__Arg$ = 8						; size = 4
??$forward@U?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@0@AAU10@@Z PROC ; std::forward<std::_Wrap_alloc<std::allocator<PushTile> > >, COMDAT

; 1275 : 	{	// forward an lvalue as either an lvalue or an rvalue

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1276 : 	return (static_cast<_Ty&&>(_Arg));

	mov	eax, DWORD PTR __Arg$[ebp]

; 1277 : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$forward@U?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@0@AAU10@@Z ENDP ; std::forward<std::_Wrap_alloc<std::allocator<PushTile> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Find_unchecked@PAUTile@@U1@@std@@YAPAUTile@@PAU1@0ABU1@@Z
_TEXT	SEGMENT
$T1 = -197						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Find_unchecked@PAUTile@@U1@@std@@YAPAUTile@@PAU1@0ABU1@@Z PROC ; std::_Find_unchecked<Tile *,Tile>, COMDAT

; 3266 : 	{	// find first matching _Val; choose optimization

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 3267 : 	// activate optimization for pointers to (const) bytes and integral values
; 3268 : 	typedef integral_constant<bool,
; 3269 : 		(is_same<_InIt, char *>::value
; 3270 : 		|| is_same<_InIt, signed char *>::value
; 3271 : 		|| is_same<_InIt, unsigned char *>::value
; 3272 : 		|| is_same<_InIt, const char *>::value
; 3273 : 		|| is_same<_InIt, const signed char *>::value
; 3274 : 		|| is_same<_InIt, const unsigned char *>::value)
; 3275 : 		&& is_integral<_Ty>::value
; 3276 : 	> _Memchr_opt;
; 3277 : 	return (_Find_unchecked1(_First, _Last, _Val, _Memchr_opt()));

	movzx	eax, BYTE PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Find_unchecked1@PAUTile@@U1@@std@@YAPAUTile@@PAU1@0ABU1@U?$integral_constant@_N$0A@@0@@Z ; std::_Find_unchecked1<Tile *,Tile>
	add	esp, 16					; 00000010H

; 3278 : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Find_unchecked@PAUTile@@U1@@std@@YAPAUTile@@PAU1@0ABU1@@Z ENDP ; std::_Find_unchecked<Tile *,Tile>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??$_Rechecked@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@YAAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@0@AAV10@PAUTile@@@Z
_TEXT	SEGMENT
__Iter$ = 8						; size = 4
__Right$ = 12						; size = 4
??$_Rechecked@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@YAAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@0@AAV10@PAUTile@@@Z PROC ; std::_Rechecked<std::_Vector_val<std::_Simple_types<Tile> > >, COMDAT

; 411  : 	{	// convert to checked

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 412  : 	return (_Iter._Rechecked(_Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Iter$[ebp]
	call	?_Rechecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAEAAV12@PAUTile@@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Tile> > >::_Rechecked

; 413  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Rechecked@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@YAAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@0@AAV10@PAUTile@@@Z ENDP ; std::_Rechecked<std::_Vector_val<std::_Simple_types<Tile> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
;	COMDAT ??$_Remove_unchecked@PAUTile@@U1@@std@@YAPAUTile@@PAU1@0ABU1@@Z
_TEXT	SEGMENT
__Next$ = -8						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Remove_unchecked@PAUTile@@U1@@std@@YAPAUTile@@PAU1@0ABU1@@Z PROC ; std::_Remove_unchecked<Tile *,Tile>, COMDAT

; 1448 : 	{	// remove each matching _Val

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1449 : 	_First = _Find_unchecked(_First, _Last, _Val);

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Find_unchecked@PAUTile@@U1@@std@@YAPAUTile@@PAU1@0ABU1@@Z ; std::_Find_unchecked<Tile *,Tile>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __First$[ebp], eax

; 1450 : 	_FwdIt _Next = _First;

	mov	eax, DWORD PTR __First$[ebp]
	mov	DWORD PTR __Next$[ebp], eax

; 1451 : 	if (_First != _Last)

	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN5@Remove_unc

; 1452 : 		{
; 1453 : 		for (++_First; _First != _Last; ++_First)

	mov	eax, DWORD PTR __First$[ebp]
	add	eax, 32					; 00000020H
	mov	DWORD PTR __First$[ebp], eax
	jmp	SHORT $LN4@Remove_unc
$LN2@Remove_unc:
	mov	eax, DWORD PTR __First$[ebp]
	add	eax, 32					; 00000020H
	mov	DWORD PTR __First$[ebp], eax
$LN4@Remove_unc:
	mov	eax, DWORD PTR __First$[ebp]
	cmp	eax, DWORD PTR __Last$[ebp]
	je	SHORT $LN5@Remove_unc

; 1454 : 			if (!(*_First == _Val))

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	call	??8Tile@@QBEHABU0@@Z			; Tile::operator==
	test	eax, eax
	jne	SHORT $LN6@Remove_unc

; 1455 : 				*_Next++ = _STD move(*_First);

	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$move@AAUTile@@@std@@YA$$QAUTile@@AAU1@@Z ; std::move<Tile &>
	add	esp, 4
	mov	ecx, 8
	mov	esi, eax
	mov	edi, DWORD PTR __Next$[ebp]
	rep movsd
	mov	ecx, DWORD PTR __Next$[ebp]
	add	ecx, 32					; 00000020H
	mov	DWORD PTR __Next$[ebp], ecx
$LN6@Remove_unc:

; 1456 : 		}

	jmp	SHORT $LN2@Remove_unc
$LN5@Remove_unc:

; 1457 : 
; 1458 : 	return (_Next);

	mov	eax, DWORD PTR __Next$[ebp]

; 1459 : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Remove_unchecked@PAUTile@@U1@@std@@YAPAUTile@@PAU1@0ABU1@@Z ENDP ; std::_Remove_unchecked<Tile *,Tile>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@YAPAUTile@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@0@@Z
_TEXT	SEGMENT
$T2 = -212						; size = 4
__$EHRec$ = -12						; size = 12
__Iter$ = 8						; size = 12
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@YAPAUTile@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@0@@Z PROC ; std::_Unchecked<std::_Vector_val<std::_Simple_types<Tile> > >, COMDAT

; 402  : 	{	// convert to unchecked

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@YAPAUTile@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 403  : 	return (_Iter._Unchecked());

	lea	ecx, DWORD PTR __Iter$[ebp]
	call	?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QBEPAUTile@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Tile> > >::_Unchecked
	mov	DWORD PTR $T2[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Iter$[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR $T2[ebp]

; 404  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@YAPAUTile@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@0@@Z$0:
	lea	ecx, DWORD PTR __Iter$[ebp]
	jmp	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAE@XZ
__ehhandler$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@YAPAUTile@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@YAPAUTile@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@YAPAUTile@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@0@@Z ENDP ; std::_Unchecked<std::_Vector_val<std::_Simple_types<Tile> > >
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Debug_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@0@0PB_WI@Z
_TEXT	SEGMENT
tv140 = -252						; size = 4
tv137 = -248						; size = 4
tv143 = -244						; size = 4
$T2 = -236						; size = 4
$T3 = -224						; size = 4
$T4 = -209						; size = 1
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 12
__Last$ = 20						; size = 12
__File$ = 32						; size = 4
__Line$ = 36						; size = 4
??$_Debug_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@0@0PB_WI@Z PROC ; std::_Debug_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Tile> > > >, COMDAT

; 966  : 	{	// test iterator pair for valid range

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Debug_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@0@0PB_WI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-252]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 967  : 	_Debug_range2(_First, _Last, _File, _Line, _Iter_cat_t<_InIt>());

	xor	eax, eax
	mov	BYTE PTR $T4[ebp], al
	movzx	ecx, BYTE PTR $T4[ebp]
	push	ecx
	mov	edx, DWORD PTR __Line$[ebp]
	push	edx
	mov	eax, DWORD PTR __File$[ebp]
	push	eax
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T3[ebp], esp
	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	call	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv143[ebp], eax
	mov	eax, DWORD PTR tv143[ebp]
	mov	DWORD PTR tv137[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T2[ebp], esp
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv140[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	call	??$_Debug_range2@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z ; std::_Debug_range2<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Tile> > > >
	add	esp, 36					; 00000024H

; 968  : 	}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __First$[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Last$[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 252				; 000000fcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Debug_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@0@0PB_WI@Z$0:
	lea	ecx, DWORD PTR __Last$[ebp]
	jmp	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$_Debug_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@0@0PB_WI@Z$1:
	lea	ecx, DWORD PTR __First$[ebp]
	jmp	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$_Debug_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@0@0PB_WI@Z$2:
	mov	ecx, DWORD PTR $T3[ebp]
	jmp	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAE@XZ
__ehhandler$??$_Debug_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@0@0PB_WI@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-256]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Debug_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@0@0PB_WI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Debug_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@0@0PB_WI@Z ENDP ; std::_Debug_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Tile> > > >
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??$_Rechecked@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@YAAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@AAV10@PAH@Z
_TEXT	SEGMENT
__Iter$ = 8						; size = 4
__Right$ = 12						; size = 4
??$_Rechecked@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@YAAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@AAV10@PAH@Z PROC ; std::_Rechecked<std::_Vector_val<std::_Simple_types<int> > >, COMDAT

; 411  : 	{	// convert to checked

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 412  : 	return (_Iter._Rechecked(_Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Iter$[ebp]
	call	?_Rechecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAEAAV12@PAH@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >::_Rechecked

; 413  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Rechecked@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@YAAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@AAV10@PAH@Z ENDP ; std::_Rechecked<std::_Vector_val<std::_Simple_types<int> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Find_unchecked@PAHW4<unnamed-enum-SDLK_UNKNOWN>@@@std@@YAPAHPAH0ABW4<unnamed-enum-SDLK_UNKNOWN>@@@Z
_TEXT	SEGMENT
$T1 = -197						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Val$ = 16						; size = 4
??$_Find_unchecked@PAHW4<unnamed-enum-SDLK_UNKNOWN>@@@std@@YAPAHPAH0ABW4<unnamed-enum-SDLK_UNKNOWN>@@@Z PROC ; std::_Find_unchecked<int *,enum <unnamed-enum-SDLK_UNKNOWN> >, COMDAT

; 3266 : 	{	// find first matching _Val; choose optimization

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 3267 : 	// activate optimization for pointers to (const) bytes and integral values
; 3268 : 	typedef integral_constant<bool,
; 3269 : 		(is_same<_InIt, char *>::value
; 3270 : 		|| is_same<_InIt, signed char *>::value
; 3271 : 		|| is_same<_InIt, unsigned char *>::value
; 3272 : 		|| is_same<_InIt, const char *>::value
; 3273 : 		|| is_same<_InIt, const signed char *>::value
; 3274 : 		|| is_same<_InIt, const unsigned char *>::value)
; 3275 : 		&& is_integral<_Ty>::value
; 3276 : 	> _Memchr_opt;
; 3277 : 	return (_Find_unchecked1(_First, _Last, _Val, _Memchr_opt()));

	movzx	eax, BYTE PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR __Val$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Find_unchecked1@PAHW4<unnamed-enum-SDLK_UNKNOWN>@@@std@@YAPAHPAH0ABW4<unnamed-enum-SDLK_UNKNOWN>@@U?$integral_constant@_N$0A@@0@@Z ; std::_Find_unchecked1<int *,enum <unnamed-enum-SDLK_UNKNOWN> >
	add	esp, 16					; 00000010H

; 3278 : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Find_unchecked@PAHW4<unnamed-enum-SDLK_UNKNOWN>@@@std@@YAPAHPAH0ABW4<unnamed-enum-SDLK_UNKNOWN>@@@Z ENDP ; std::_Find_unchecked<int *,enum <unnamed-enum-SDLK_UNKNOWN> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??$_Unchecked@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@YAPAHV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@@Z
_TEXT	SEGMENT
$T2 = -212						; size = 4
__$EHRec$ = -12						; size = 12
__Iter$ = 8						; size = 12
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@YAPAHV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@@Z PROC ; std::_Unchecked<std::_Vector_val<std::_Simple_types<int> > >, COMDAT

; 402  : 	{	// convert to unchecked

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@YAPAHV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 403  : 	return (_Iter._Unchecked());

	lea	ecx, DWORD PTR __Iter$[ebp]
	call	?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBEPAHXZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >::_Unchecked
	mov	DWORD PTR $T2[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Iter$[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR $T2[ebp]

; 404  : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@YAPAHV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@@Z$0:
	lea	ecx, DWORD PTR __Iter$[ebp]
	jmp	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ
__ehhandler$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@YAPAHV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Unchecked@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@YAPAHV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Unchecked@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@YAPAHV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@@Z ENDP ; std::_Unchecked<std::_Vector_val<std::_Simple_types<int> > >
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Debug_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0PB_WI@Z
_TEXT	SEGMENT
tv140 = -252						; size = 4
tv137 = -248						; size = 4
tv143 = -244						; size = 4
$T2 = -236						; size = 4
$T3 = -224						; size = 4
$T4 = -209						; size = 1
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 12
__Last$ = 20						; size = 12
__File$ = 32						; size = 4
__Line$ = 36						; size = 4
??$_Debug_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0PB_WI@Z PROC ; std::_Debug_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > > >, COMDAT

; 966  : 	{	// test iterator pair for valid range

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Debug_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0PB_WI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-252]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 967  : 	_Debug_range2(_First, _Last, _File, _Line, _Iter_cat_t<_InIt>());

	xor	eax, eax
	mov	BYTE PTR $T4[ebp], al
	movzx	ecx, BYTE PTR $T4[ebp]
	push	ecx
	mov	edx, DWORD PTR __Line$[ebp]
	push	edx
	mov	eax, DWORD PTR __File$[ebp]
	push	eax
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T3[ebp], esp
	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	call	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv143[ebp], eax
	mov	eax, DWORD PTR tv143[ebp]
	mov	DWORD PTR tv137[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T2[ebp], esp
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv140[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	call	??$_Debug_range2@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0PB_WIUrandom_access_iterator_tag@0@@Z ; std::_Debug_range2<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > > >
	add	esp, 36					; 00000024H

; 968  : 	}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __First$[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Last$[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 252				; 000000fcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Debug_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0PB_WI@Z$0:
	lea	ecx, DWORD PTR __Last$[ebp]
	jmp	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$_Debug_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0PB_WI@Z$1:
	lea	ecx, DWORD PTR __First$[ebp]
	jmp	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$_Debug_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0PB_WI@Z$2:
	mov	ecx, DWORD PTR $T3[ebp]
	jmp	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ
__ehhandler$??$_Debug_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0PB_WI@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-256]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Debug_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0PB_WI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Debug_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0PB_WI@Z ENDP ; std::_Debug_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > > >
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$addressof@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@AAU10@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@AAU10@@Z PROC ; std::addressof<std::_Container_proxy>, COMDAT

; 724  : 	{	// return address of _Val

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 725  : 	return (__builtin_addressof(_Val));

	mov	eax, DWORD PTR __Val$[ebp]

; 726  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$addressof@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@AAU10@@Z ENDP ; std::addressof<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?pointer_to@?$pointer_traits@PAU_Container_proxy@std@@@std@@SAPAU_Container_proxy@2@AAU32@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
?pointer_to@?$pointer_traits@PAU_Container_proxy@std@@@std@@SAPAU_Container_proxy@2@AAU32@@Z PROC ; std::pointer_traits<std::_Container_proxy *>::pointer_to, COMDAT

; 279  : 		{	// convert raw reference to pointer

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 280  : 		return (_STD addressof(_Val));

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	call	??$addressof@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@AAU10@@Z ; std::addressof<std::_Container_proxy>
	add	esp, 4

; 281  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?pointer_to@?$pointer_traits@PAU_Container_proxy@std@@@std@@SAPAU_Container_proxy@2@AAU32@@Z ENDP ; std::pointer_traits<std::_Container_proxy *>::pointer_to
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??$_Umove@PAUTile@@@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@IAEPAUTile@@PAU2@00@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Ptr$ = 16						; size = 4
??$_Umove@PAUTile@@@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@IAEPAUTile@@PAU2@00@Z PROC ; std::vector<Tile,std::allocator<Tile> >::_Umove<Tile *>, COMDAT
; _this$ = ecx

; 1658 : 		{	// move initializing [_First, _Last), using allocator

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1659 : 		return (_Uninitialized_move(_First, _Last,

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@UTile@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Getal
	push	eax
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Last$[ebp]
	push	ecx
	mov	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Uninitialized_move@PAUTile@@PAU1@V?$allocator@UTile@@@std@@@std@@YAPAUTile@@PAU1@00AAU?$_Wrap_alloc@V?$allocator@UTile@@@std@@@0@@Z ; std::_Uninitialized_move<Tile *,Tile *,std::allocator<Tile> >
	add	esp, 16					; 00000010H

; 1660 : 			_Ptr, this->_Getal()));
; 1661 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
??$_Umove@PAUTile@@@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@IAEPAUTile@@PAU2@00@Z ENDP ; std::vector<Tile,std::allocator<Tile> >::_Umove<Tile *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::construct<std::_Container_proxy,std::_Container_proxy>, COMDAT
; _this$ = ecx

; 994  : 		{	// construct _Ty(_Types...) at _Ptr

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 995  : 		_Mytraits::construct(*this, _Ptr,

	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	push	eax
	call	??$forward@U_Container_proxy@std@@@std@@YA$$QAU_Container_proxy@0@AAU10@@Z ; std::forward<std::_Container_proxy>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??$construct@U_Container_proxy@std@@U12@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@$$QAU31@@Z ; std::allocator_traits<std::allocator<std::_Container_proxy> >::construct<std::_Container_proxy,std::_Container_proxy>
	add	esp, 12					; 0000000cH

; 996  : 			_STD forward<_Types>(_Args)...);
; 997  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::construct<std::_Container_proxy,std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$_Unfancy@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@PAU10@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@PAU10@@Z PROC ; std::_Unfancy<std::_Container_proxy>, COMDAT

; 739  : 	{	// do nothing for plain pointers

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]

; 741  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unfancy@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@PAU10@@Z ENDP ; std::_Unfancy<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?0AAU?$_Wrap_alloc@V?$allocator@UTile@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAU?$_Wrap_alloc@V?$allocator@UTile@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
??$?0AAU?$_Wrap_alloc@V?$allocator@UTile@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAU?$_Wrap_alloc@V?$allocator@UTile@@@std@@@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::_Wrap_alloc<std::allocator<std::_Container_proxy> ><std::_Wrap_alloc<std::allocator<Tile> > &>, COMDAT
; _this$ = ecx

; 952  : 		{	// construct from a related allocator

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 951  : 		: _Mybase(_STD forward<_Other>(_Right))

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	call	??$forward@AAU?$_Wrap_alloc@V?$allocator@UTile@@@std@@@std@@@std@@YAAAU?$_Wrap_alloc@V?$allocator@UTile@@@std@@@0@AAU10@@Z ; std::forward<std::_Wrap_alloc<std::allocator<Tile> > &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$?0UTile@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@UTile@@@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><Tile>

; 953  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0AAU?$_Wrap_alloc@V?$allocator@UTile@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAU?$_Wrap_alloc@V?$allocator@UTile@@@std@@@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::_Wrap_alloc<std::allocator<std::_Container_proxy> ><std::_Wrap_alloc<std::allocator<Tile> > &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@V?$allocator@UPushTile@@@std@@PAUPushTile@@@std@@YAXPAUPushTile@@0AAU?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@0@@Z
_TEXT	SEGMENT
$T1 = -197						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@UPushTile@@@std@@PAUPushTile@@@std@@YAXPAUPushTile@@0AAU?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@0@@Z PROC ; std::_Destroy_range<std::allocator<PushTile>,PushTile *>, COMDAT

; 1114 : 	{	// destroy [_First, _Last), choose optimization

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1115 : 		// note that this is an optimization for debug mode codegen;
; 1116 : 		// in release mode the BE removes all of this
; 1117 : 	typedef typename _Alloc::value_type _Val;
; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<

	movzx	eax, BYTE PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Destroy_range1@V?$allocator@UPushTile@@@std@@PAUPushTile@@@std@@YAXPAUPushTile@@0AAU?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@0@U?$integral_constant@_N$00@0@@Z ; std::_Destroy_range1<std::allocator<PushTile>,PushTile *>
	add	esp, 16					; 00000010H

; 1119 : 		is_trivially_destructible<_Val>,
; 1120 : 		_Uses_default_destroy<_Alloc, _Val *>>::type());
; 1121 : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@UPushTile@@@std@@PAUPushTile@@@std@@YAXPAUPushTile@@0AAU?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<PushTile>,PushTile *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::destroy<std::_Container_proxy>, COMDAT
; _this$ = ecx

; 1002 : 		{	// destroy object at _Ptr

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1003 : 		_Mytraits::destroy(*this, _Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	??$destroy@U_Container_proxy@std@@@?$allocator_traits@V?$allocator@U_Container_proxy@std@@@std@@@std@@SAXAAV?$allocator@U_Container_proxy@std@@@1@PAU_Container_proxy@1@@Z ; std::allocator_traits<std::allocator<std::_Container_proxy> >::destroy<std::_Container_proxy>
	add	esp, 8

; 1004 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::destroy<std::_Container_proxy>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?0AAU?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAU?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
??$?0AAU?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAU?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@1@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::_Wrap_alloc<std::allocator<std::_Container_proxy> ><std::_Wrap_alloc<std::allocator<PushTile> > &>, COMDAT
; _this$ = ecx

; 952  : 		{	// construct from a related allocator

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 951  : 		: _Mybase(_STD forward<_Other>(_Right))

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	call	??$forward@AAU?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@std@@@std@@YAAAU?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@0@AAU10@@Z ; std::forward<std::_Wrap_alloc<std::allocator<PushTile> > &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$?0UPushTile@@@?$allocator@U_Container_proxy@std@@@std@@QAE@ABV?$allocator@UPushTile@@@1@@Z ; std::allocator<std::_Container_proxy>::allocator<std::_Container_proxy><PushTile>

; 953  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0AAU?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAU?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::_Wrap_alloc<std::allocator<std::_Container_proxy> ><std::_Wrap_alloc<std::allocator<PushTile> > &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::deallocate, COMDAT
; _this$ = ecx

; 986  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 987  : 		_Mybase::deallocate(_Ptr, _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::deallocate

; 988  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::allocate, COMDAT
; _this$ = ecx

; 975  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 976  : 		return (_Mybase::allocate(_Count));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::allocator<std::_Container_proxy>::allocate

; 977  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?address@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QBEPAU_Container_proxy@2@AAU32@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Val$ = 8						; size = 4
?address@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QBEPAU_Container_proxy@2@AAU32@@Z PROC ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::address, COMDAT
; _this$ = ecx

; 925  : 		{	// return address of mutable _Val

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 926  : 		return (pointer_traits<pointer>::pointer_to(_Val));

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	call	?pointer_to@?$pointer_traits@PAU_Container_proxy@std@@@std@@SAPAU_Container_proxy@2@AAU32@@Z ; std::pointer_traits<std::_Container_proxy *>::pointer_to
	add	esp, 4

; 927  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?address@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QBEPAU_Container_proxy@2@AAU32@@Z ENDP ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::address
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z PROC ; std::allocator<std::_Container_proxy>::allocate, COMDAT
; _this$ = ecx

; 724  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

	push	1
	push	8
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	?_Allocate@std@@YAPAXII_N@Z		; std::_Allocate
	add	esp, 12					; 0000000cH

; 726  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@U_Container_proxy@std@@@std@@QAEPAU_Container_proxy@2@I@Z ENDP ; std::allocator<std::_Container_proxy>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z PROC ; std::allocator<std::_Container_proxy>::deallocate, COMDAT
; _this$ = ecx

; 719  : 		{	// deallocate object at _Ptr

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	8
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH

; 721  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@U_Container_proxy@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ENDP ; std::allocator<std::_Container_proxy>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$_Destroy_range@V?$allocator@UTile@@@std@@PAUTile@@@std@@YAXPAUTile@@0AAU?$_Wrap_alloc@V?$allocator@UTile@@@std@@@0@@Z
_TEXT	SEGMENT
$T1 = -197						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Al$ = 16						; size = 4
??$_Destroy_range@V?$allocator@UTile@@@std@@PAUTile@@@std@@YAXPAUTile@@0AAU?$_Wrap_alloc@V?$allocator@UTile@@@std@@@0@@Z PROC ; std::_Destroy_range<std::allocator<Tile>,Tile *>, COMDAT

; 1114 : 	{	// destroy [_First, _Last), choose optimization

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 1115 : 		// note that this is an optimization for debug mode codegen;
; 1116 : 		// in release mode the BE removes all of this
; 1117 : 	typedef typename _Alloc::value_type _Val;
; 1118 : 	_Destroy_range1(_First, _Last, _Al, typename conjunction<

	movzx	eax, BYTE PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR __Al$[ebp]
	push	ecx
	mov	edx, DWORD PTR __Last$[ebp]
	push	edx
	mov	eax, DWORD PTR __First$[ebp]
	push	eax
	call	??$_Destroy_range1@V?$allocator@UTile@@@std@@PAUTile@@@std@@YAXPAUTile@@0AAU?$_Wrap_alloc@V?$allocator@UTile@@@std@@@0@U?$integral_constant@_N$00@0@@Z ; std::_Destroy_range1<std::allocator<Tile>,Tile *>
	add	esp, 16					; 00000010H

; 1119 : 		is_trivially_destructible<_Val>,
; 1120 : 		_Uses_default_destroy<_Alloc, _Val *>>::type());
; 1121 : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Destroy_range@V?$allocator@UTile@@@std@@PAUTile@@@std@@YAXPAUTile@@0AAU?$_Wrap_alloc@V?$allocator@UTile@@@std@@@0@@Z ENDP ; std::_Destroy_range<std::allocator<Tile>,Tile *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UTile@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___formal$ = 8						; size = 1
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UTile@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Tile> >,std::_Vector_val<std::_Simple_types<Tile> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<Tile> >,std::_Vector_val<std::_Simple_types<Tile> >,1><>, COMDAT
; _this$ = ecx

; 280  : 		{	// construct from forwarded values

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 279  : 		: _Ty1(), _Myval2(_STD forward<_Other2>(_Val2)...)

	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Wrap_alloc@V?$allocator@UTile@@@std@@@std@@QAE@XZ ; std::_Wrap_alloc<std::allocator<Tile> >::_Wrap_alloc<std::allocator<Tile> >
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@QAE@XZ ; std::_Vector_val<std::_Simple_types<Tile> >::_Vector_val<std::_Simple_types<Tile> >

; 281  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UTile@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Tile> >,std::_Vector_val<std::_Simple_types<Tile> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<Tile> >,std::_Vector_val<std::_Simple_types<Tile> >,1><>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$?0V?$allocator@UPushTile@@@std@@@?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@std@@QAE@$$QAV?$allocator@UPushTile@@@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
??$?0V?$allocator@UPushTile@@@std@@@?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@std@@QAE@$$QAV?$allocator@UPushTile@@@1@@Z PROC ; std::_Wrap_alloc<std::allocator<PushTile> >::_Wrap_alloc<std::allocator<PushTile> ><std::allocator<PushTile> >, COMDAT
; _this$ = ecx

; 952  : 		{	// construct from a related allocator

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 951  : 		: _Mybase(_STD forward<_Other>(_Right))

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	call	??$forward@V?$allocator@UPushTile@@@std@@@std@@YA$$QAV?$allocator@UPushTile@@@0@AAV10@@Z ; std::forward<std::allocator<PushTile> >
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$allocator@UPushTile@@@std@@QAE@ABV01@@Z ; std::allocator<PushTile>::allocator<PushTile>

; 953  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??$?0V?$allocator@UPushTile@@@std@@@?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@std@@QAE@$$QAV?$allocator@UPushTile@@@1@@Z ENDP ; std::_Wrap_alloc<std::allocator<PushTile> >::_Wrap_alloc<std::allocator<PushTile> ><std::allocator<PushTile> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@UTile@@ABU1@@?$_Wrap_alloc@V?$allocator@UTile@@@std@@@std@@QAEXPAUTile@@ABU2@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@UTile@@ABU1@@?$_Wrap_alloc@V?$allocator@UTile@@@std@@@std@@QAEXPAUTile@@ABU2@@Z PROC ; std::_Wrap_alloc<std::allocator<Tile> >::construct<Tile,Tile const &>, COMDAT
; _this$ = ecx

; 994  : 		{	// construct _Ty(_Types...) at _Ptr

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 995  : 		_Mytraits::construct(*this, _Ptr,

	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	push	eax
	call	??$forward@ABUTile@@@std@@YAABUTile@@ABU1@@Z ; std::forward<Tile const &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??$construct@UTile@@ABU1@@?$allocator_traits@V?$allocator@UTile@@@std@@@std@@SAXAAV?$allocator@UTile@@@1@PAUTile@@ABU3@@Z ; std::allocator_traits<std::allocator<Tile> >::construct<Tile,Tile const &>
	add	esp, 12					; 0000000cH

; 996  : 			_STD forward<_Types>(_Args)...);
; 997  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
??$construct@UTile@@ABU1@@?$_Wrap_alloc@V?$allocator@UTile@@@std@@@std@@QAEXPAUTile@@ABU2@@Z ENDP ; std::_Wrap_alloc<std::allocator<Tile> >::construct<Tile,Tile const &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??$construct@UTile@@AAU1@@?$_Wrap_alloc@V?$allocator@UTile@@@std@@@std@@QAEXPAUTile@@AAU2@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
_<_Args_0>$ = 12					; size = 4
??$construct@UTile@@AAU1@@?$_Wrap_alloc@V?$allocator@UTile@@@std@@@std@@QAEXPAUTile@@AAU2@@Z PROC ; std::_Wrap_alloc<std::allocator<Tile> >::construct<Tile,Tile &>, COMDAT
; _this$ = ecx

; 994  : 		{	// construct _Ty(_Types...) at _Ptr

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 995  : 		_Mytraits::construct(*this, _Ptr,

	mov	eax, DWORD PTR _<_Args_0>$[ebp]
	push	eax
	call	??$forward@AAUTile@@@std@@YAAAUTile@@AAU1@@Z ; std::forward<Tile &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _this$[ebp]
	push	edx
	call	??$construct@UTile@@AAU1@@?$allocator_traits@V?$allocator@UTile@@@std@@@std@@SAXAAV?$allocator@UTile@@@1@PAUTile@@AAU3@@Z ; std::allocator_traits<std::allocator<Tile> >::construct<Tile,Tile &>
	add	esp, 12					; 0000000cH

; 996  : 			_STD forward<_Types>(_Args)...);
; 997  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
??$construct@UTile@@AAU1@@?$_Wrap_alloc@V?$allocator@UTile@@@std@@@std@@QAEXPAUTile@@AAU2@@Z ENDP ; std::_Wrap_alloc<std::allocator<Tile> >::construct<Tile,Tile &>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$_Unfancy@UTile@@@std@@YAPAUTile@@PAU1@@Z
_TEXT	SEGMENT
__Ptr$ = 8						; size = 4
??$_Unfancy@UTile@@@std@@YAPAUTile@@PAU1@@Z PROC	; std::_Unfancy<Tile>, COMDAT

; 739  : 	{	// do nothing for plain pointers

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 740  : 	return (_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]

; 741  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Unfancy@UTile@@@std@@YAPAUTile@@PAU1@@Z ENDP	; std::_Unfancy<Tile>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xstddef
;	COMDAT ??$addressof@$$CBUTile@@@std@@YAPBUTile@@ABU1@@Z
_TEXT	SEGMENT
__Val$ = 8						; size = 4
??$addressof@$$CBUTile@@@std@@YAPBUTile@@ABU1@@Z PROC	; std::addressof<Tile const >, COMDAT

; 724  : 	{	// return address of _Val

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 725  : 	return (__builtin_addressof(_Val));

	mov	eax, DWORD PTR __Val$[ebp]

; 726  : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??$addressof@$$CBUTile@@@std@@YAPBUTile@@ABU1@@Z ENDP	; std::addressof<Tile const >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$_Move_unchecked@PAUTile@@PAU1@@std@@YAPAUTile@@PAU1@00@Z
_TEXT	SEGMENT
$T1 = -197						; size = 1
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
__Dest$ = 16						; size = 4
??$_Move_unchecked@PAUTile@@PAU1@@std@@YAPAUTile@@PAU1@00@Z PROC ; std::_Move_unchecked<Tile *,Tile *>, COMDAT

; 2597 : 	{	// move [_First, _Last) to [_Dest, ...), choose optimization

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 2598 : 	return (_Move_unchecked1(_First, _Last,

	lea	eax, DWORD PTR __Dest$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$[ebp]
	push	ecx
	lea	edx, DWORD PTR $T1[ebp]
	push	edx
	call	??$_Ptr_move_cat@UTile@@U1@@std@@YA?AU_Trivially_copyable_ptr_iterator_tag@0@ABQAUTile@@0@Z ; std::_Ptr_move_cat<Tile,Tile>
	add	esp, 12					; 0000000cH
	mov	al, BYTE PTR [eax]
	movzx	ecx, al
	push	ecx
	mov	edx, DWORD PTR __Dest$[ebp]
	push	edx
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Move_unchecked1@PAUTile@@PAU1@@std@@YAPAUTile@@PAU1@00U_Trivially_copyable_ptr_iterator_tag@0@@Z ; std::_Move_unchecked1<Tile *,Tile *>
	add	esp, 16					; 00000010H

; 2599 : 		_Dest, _Ptr_move_cat(_First, _Dest)));
; 2600 : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??$_Move_unchecked@PAUTile@@PAU1@@std@@YAPAUTile@@PAU1@00@Z ENDP ; std::_Move_unchecked<Tile *,Tile *>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@@?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@IAEPAUPushTile@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@1@0PAU2@@Z
_TEXT	SEGMENT
tv66 = -268						; size = 4
tv142 = -264						; size = 4
tv139 = -260						; size = 4
tv145 = -256						; size = 4
$T2 = -248						; size = 4
$T3 = -236						; size = 4
$T4 = -224						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 12
__Last$ = 20						; size = 12
__Ptr$ = 32						; size = 4
??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@@?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@IAEPAUPushTile@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@1@0PAU2@@Z PROC ; std::vector<PushTile,std::allocator<PushTile> >::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PushTile> > > >, COMDAT
; _this$ = ecx

; 1651 : 		{	// copy initializing [_First, _Last), using allocator

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@@?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@IAEPAUPushTile@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@1@0PAU2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 256				; 00000100H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-268]
	mov	ecx, 64					; 00000040H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 1652 : 		return (_Uninitialized_copy(_First, _Last,

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<PushTile,std::allocator<PushTile> > >::_Getal
	push	eax
	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T3[ebp], esp
	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	call	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv145[ebp], eax
	mov	eax, DWORD PTR tv145[ebp]
	mov	DWORD PTR tv139[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T2[ebp], esp
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv142[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	call	??$_Uninitialized_copy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@PAUPushTile@@V?$allocator@UPushTile@@@2@@std@@YAPAUPushTile@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@0@0PAU1@AAU?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@0@@Z ; std::_Uninitialized_copy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PushTile> > >,PushTile *,std::allocator<PushTile> >
	add	esp, 32					; 00000020H
	mov	DWORD PTR tv66[ebp], eax
	mov	eax, DWORD PTR tv66[ebp]
	mov	DWORD PTR $T4[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __First$[ebp]
	call	??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Last$[ebp]
	call	??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR $T4[ebp]

; 1653 : 			_Ptr, this->_Getal()));
; 1654 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 268				; 0000010cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@@?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@IAEPAUPushTile@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@1@0PAU2@@Z$0:
	lea	ecx, DWORD PTR __Last$[ebp]
	jmp	??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@@?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@IAEPAUPushTile@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@1@0PAU2@@Z$1:
	lea	ecx, DWORD PTR __First$[ebp]
	jmp	??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@@?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@IAEPAUPushTile@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@1@0PAU2@@Z$2:
	mov	ecx, DWORD PTR $T3[ebp]
	jmp	??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@QAE@XZ
__ehhandler$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@@?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@IAEPAUPushTile@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@1@0PAU2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-272]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@@?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@IAEPAUPushTile@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@1@0PAU2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@@?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@IAEPAUPushTile@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@1@0PAU2@@Z ENDP ; std::vector<PushTile,std::allocator<PushTile> >::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PushTile> > > >
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??$?0U?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@std@@X@?$_Vector_alloc@U?$_Vec_base_types@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@1@@Z
_TEXT	SEGMENT
$T2 = -221						; size = 1
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Al$ = 8						; size = 4
??$?0U?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@std@@X@?$_Vector_alloc@U?$_Vec_base_types@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@1@@Z PROC ; std::_Vector_alloc<std::_Vec_base_types<PushTile,std::allocator<PushTile> > >::_Vector_alloc<std::_Vec_base_types<PushTile,std::allocator<PushTile> > ><std::_Wrap_alloc<std::allocator<PushTile> >,void>, COMDAT
; _this$ = ecx

; 553  : 		{	// construct allocator from _Al

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$?0U?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@std@@X@?$_Vector_alloc@U?$_Vec_base_types@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 551  : 		: _Mypair(_One_then_variadic_args_t(),

	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	call	??$forward@U?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@0@AAU10@@Z ; std::forward<std::_Wrap_alloc<std::allocator<PushTile> > >
	add	esp, 4
	push	eax
	movzx	ecx, BYTE PTR $T2[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$?0U?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@std@@$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@2@$00@std@@QAE@U_One_then_variadic_args_t@1@$$QAU?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@1@@Z ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<PushTile> >,std::_Vector_val<std::_Simple_types<PushTile> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<PushTile> >,std::_Vector_val<std::_Simple_types<PushTile> >,1><std::_Wrap_alloc<std::allocator<PushTile> > >
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 554  : 		_Alloc_proxy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Alloc_proxy@?$_Vector_alloc@U?$_Vec_base_types@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<std::_Vec_base_types<PushTile,std::allocator<PushTile> > >::_Alloc_proxy

; 555  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$?0U?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@std@@X@?$_Vector_alloc@U?$_Vec_base_types@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@2@$00@std@@QAE@XZ
__ehhandler$??$?0U?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@std@@X@?$_Vector_alloc@U?$_Vec_base_types@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-232]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$?0U?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@std@@X@?$_Vector_alloc@U?$_Vec_base_types@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$?0U?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@std@@X@?$_Vector_alloc@U?$_Vec_base_types@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@1@@Z ENDP ; std::_Vector_alloc<std::_Vec_base_types<PushTile,std::allocator<PushTile> > >::_Vector_alloc<std::_Vec_base_types<PushTile,std::allocator<PushTile> > ><std::_Wrap_alloc<std::allocator<PushTile> >,void>
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@UTile@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@0@V10@0ABUTile@@@Z
_TEXT	SEGMENT
tv130 = -284						; size = 4
tv184 = -280						; size = 4
tv183 = -276						; size = 4
tv176 = -276						; size = 4
tv180 = -272						; size = 4
tv173 = -272						; size = 4
tv179 = -268						; size = 4
tv128 = -268						; size = 4
$T2 = -260						; size = 4
$T3 = -248						; size = 4
$T4 = -236						; size = 4
$T5 = -224						; size = 4
$T6 = -212						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 12
__Last$ = 24						; size = 12
__Val$ = 36						; size = 4
??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@UTile@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@0@V10@0ABUTile@@@Z PROC ; std::find<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Tile> > >,Tile>, COMDAT

; 3283 : 	{	// find first matching _Val

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@UTile@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@0@V10@0ABUTile@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 272				; 00000110H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-284]
	mov	ecx, 68					; 00000044H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR $T2[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 3284 : 	_DEBUG_RANGE(_First, _Last);

	push	3284					; 00000cd4H
	push	OFFSET ??_C@_1JA@MHADJNIL@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T6[ebp], esp
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv128[ebp], eax
	mov	ecx, DWORD PTR tv128[ebp]
	mov	DWORD PTR tv173[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T5[ebp], esp
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv176[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	call	??$_Debug_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@0@0PB_WI@Z ; std::_Debug_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Tile> > > >
	add	esp, 32					; 00000020H

; 3285 : 	return (_Rechecked(_First,

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T4[ebp], esp
	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	call	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv179[ebp], eax
	call	??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@YAPAUTile@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@0@@Z ; std::_Unchecked<std::_Vector_val<std::_Simple_types<Tile> > >
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv180[ebp], eax
	mov	eax, DWORD PTR tv180[ebp]
	push	eax
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T3[ebp], esp
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv183[ebp], eax
	call	??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@YAPAUTile@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@0@@Z ; std::_Unchecked<std::_Vector_val<std::_Simple_types<Tile> > >
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv184[ebp], eax
	mov	eax, DWORD PTR tv184[ebp]
	push	eax
	call	??$_Find_unchecked@PAUTile@@U1@@std@@YAPAUTile@@PAU1@0ABU1@@Z ; std::_Find_unchecked<Tile *,Tile>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv130[ebp], eax
	mov	ecx, DWORD PTR tv130[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Rechecked@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@YAAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@0@AAV10@PAUTile@@@Z ; std::_Rechecked<std::_Vector_val<std::_Simple_types<Tile> > >
	add	esp, 8
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR $T2[ebp]
	or	eax, 1
	mov	DWORD PTR $T2[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __First$[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Last$[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 3286 : 		_Find_unchecked(_Unchecked(_First), _Unchecked(_Last), _Val)));
; 3287 : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 284				; 0000011cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@UTile@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@0@V10@0ABUTile@@@Z$0:
	lea	ecx, DWORD PTR __Last$[ebp]
	jmp	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@UTile@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@0@V10@0ABUTile@@@Z$1:
	lea	ecx, DWORD PTR __First$[ebp]
	jmp	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@UTile@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@0@V10@0ABUTile@@@Z$2:
	mov	ecx, DWORD PTR $T6[ebp]
	jmp	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAE@XZ
__ehhandler$??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@UTile@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@0@V10@0ABUTile@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-288]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@UTile@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@0@V10@0ABUTile@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@UTile@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@0@V10@0ABUTile@@@Z ENDP ; std::find<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Tile> > >,Tile>
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\algorithm
;	COMDAT ??$remove@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@UTile@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@0@V10@0ABUTile@@@Z
_TEXT	SEGMENT
tv130 = -284						; size = 4
tv184 = -280						; size = 4
tv183 = -276						; size = 4
tv176 = -276						; size = 4
tv180 = -272						; size = 4
tv173 = -272						; size = 4
tv179 = -268						; size = 4
tv128 = -268						; size = 4
$T2 = -260						; size = 4
$T3 = -248						; size = 4
$T4 = -236						; size = 4
$T5 = -224						; size = 4
$T6 = -212						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 12
__Last$ = 24						; size = 12
__Val$ = 36						; size = 4
??$remove@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@UTile@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@0@V10@0ABUTile@@@Z PROC ; std::remove<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Tile> > >,Tile>, COMDAT

; 1464 : 	{	// remove each matching _Val

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$remove@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@UTile@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@0@V10@0ABUTile@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 272				; 00000110H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-284]
	mov	ecx, 68					; 00000044H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR $T2[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 1465 : 	_DEBUG_RANGE(_First, _Last);

	push	1465					; 000005b9H
	push	OFFSET ??_C@_1JC@ELNBGKIG@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T6[ebp], esp
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv128[ebp], eax
	mov	ecx, DWORD PTR tv128[ebp]
	mov	DWORD PTR tv173[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T5[ebp], esp
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv176[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	call	??$_Debug_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@0@0PB_WI@Z ; std::_Debug_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Tile> > > >
	add	esp, 32					; 00000020H

; 1466 : 	return (_Rechecked(_First,

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T4[ebp], esp
	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	call	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv179[ebp], eax
	call	??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@YAPAUTile@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@0@@Z ; std::_Unchecked<std::_Vector_val<std::_Simple_types<Tile> > >
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv180[ebp], eax
	mov	eax, DWORD PTR tv180[ebp]
	push	eax
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T3[ebp], esp
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv183[ebp], eax
	call	??$_Unchecked@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@YAPAUTile@@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@0@@Z ; std::_Unchecked<std::_Vector_val<std::_Simple_types<Tile> > >
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv184[ebp], eax
	mov	eax, DWORD PTR tv184[ebp]
	push	eax
	call	??$_Remove_unchecked@PAUTile@@U1@@std@@YAPAUTile@@PAU1@0ABU1@@Z ; std::_Remove_unchecked<Tile *,Tile>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv130[ebp], eax
	mov	ecx, DWORD PTR tv130[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Rechecked@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@YAAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@0@AAV10@PAUTile@@@Z ; std::_Rechecked<std::_Vector_val<std::_Simple_types<Tile> > >
	add	esp, 8
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR $T2[ebp]
	or	eax, 1
	mov	DWORD PTR $T2[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __First$[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Last$[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1467 : 		_Remove_unchecked(_Unchecked(_First), _Unchecked(_Last), _Val)));
; 1468 : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 284				; 0000011cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$remove@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@UTile@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@0@V10@0ABUTile@@@Z$0:
	lea	ecx, DWORD PTR __Last$[ebp]
	jmp	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$remove@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@UTile@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@0@V10@0ABUTile@@@Z$1:
	lea	ecx, DWORD PTR __First$[ebp]
	jmp	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$remove@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@UTile@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@0@V10@0ABUTile@@@Z$2:
	mov	ecx, DWORD PTR $T6[ebp]
	jmp	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAE@XZ
__ehhandler$??$remove@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@UTile@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@0@V10@0ABUTile@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-288]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$remove@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@UTile@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@0@V10@0ABUTile@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$remove@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@UTile@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@0@V10@0ABUTile@@@Z ENDP ; std::remove<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Tile> > >,Tile>
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?__autoclassinit2@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UMovingTile@@@std@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_classSize$ = 8						; size = 4
?__autoclassinit2@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UMovingTile@@@std@@@std@@@std@@QAEXI@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<MovingTile> > >::__autoclassinit2, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _classSize$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?__autoclassinit2@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UMovingTile@@@std@@@std@@@std@@QAEXI@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<MovingTile> > >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UMovingTile@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UMovingTile@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<MovingTile> > >::~_Vector_iterator<std::_Vector_val<std::_Simple_types<MovingTile> > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UMovingTile@@@std@@@std@@@std@@QAE@XZ
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UMovingTile@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<MovingTile> > >::~_Vector_iterator<std::_Vector_val<std::_Simple_types<MovingTile> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UMovingTile@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UMovingTile@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<MovingTile> > >::operator++, COMDAT
; _this$ = ecx

; 340  : 		{	// preincrement

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 341  : 		++*(_Mybase *)this;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UMovingTile@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<MovingTile> > >::operator++

; 342  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 343  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UMovingTile@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<MovingTile> > >::operator++
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UMovingTile@@@std@@@std@@@std@@QBEAAUMovingTile@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UMovingTile@@@std@@@std@@@std@@QBEAAUMovingTile@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<MovingTile> > >::operator*, COMDAT
; _this$ = ecx

; 330  : 		{	// return designated object

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 331  : 		return ((reference)**(_Mybase *)this);

	mov	ecx, DWORD PTR _this$[ebp]
	call	??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UMovingTile@@@std@@@std@@@std@@QBEABUMovingTile@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<MovingTile> > >::operator*

; 332  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UMovingTile@@@std@@@std@@@std@@QBEAAUMovingTile@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<MovingTile> > >::operator*
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UMovingTile@@@std@@@std@@@std@@QAE@PAUMovingTile@@PBU_Container_base12@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UMovingTile@@@std@@@std@@@std@@QAE@PAUMovingTile@@PBU_Container_base12@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<MovingTile> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<MovingTile> > >, COMDAT
; _this$ = ecx

; 313  : 		{	// construct with pointer _Parg

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 312  : 		: _Mybase(_Parg, _Pvector)

	mov	eax, DWORD PTR __Pvector$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Parg$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UMovingTile@@@std@@@std@@@std@@QAE@PAUMovingTile@@PBU_Container_base12@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<MovingTile> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<MovingTile> > >

; 314  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UMovingTile@@@std@@@std@@@std@@QAE@PAUMovingTile@@PBU_Container_base12@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<MovingTile> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<MovingTile> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UMovingTile@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UMovingTile@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<MovingTile> > >::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<MovingTile> > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Iterator012@Urandom_access_iterator_tag@std@@UMovingTile@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UMovingTile@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<MovingTile> > >::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<MovingTile> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UMovingTile@@@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UMovingTile@@@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<MovingTile> > >::_Compat, COMDAT
; _this$ = ecx

; 245  : 		{	// test for compatible iterator pair

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 246  : 		if (this->_Getcont() != _Right._Getcont())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
	mov	esi, eax
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
	cmp	esi, eax
	je	$LN1@Compat

; 247  : 			{
; 248  : 			_DEBUG_ERROR("vector iterators incompatible");

	mov	esi, esp
	push	248					; 000000f8H
	push	OFFSET ??_C@_1IM@NCODKBJH@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	OFFSET ??_C@_1DM@HINDPMBP@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AAs?$AA?5?$AAi?$AAn?$AAc?$AAo?$AAm?$AAp?$AAa?$AAt?$AAi?$AAb?$AAl?$AAe?$AA?$AA@
	call	DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 249  : 			_SCL_SECURE_INVALID_ARGUMENT;

	mov	eax, OFFSET ??_C@_0CI@FNPHFCCM@Standard?5C?$CL?$CL?5Libraries?5Invalid?5A@
	test	eax, eax
	je	SHORT $LN4@Compat
	xor	ecx, ecx
	jne	SHORT $LN5@Compat
$LN4@Compat:
	mov	esi, esp
	push	OFFSET ??_C@_1FO@GJIHNDLM@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5@
	push	OFFSET ??_C@_17CNPHIMPH@?$AA?$CF?$AAl?$AAs?$AA?$AA@
	push	0
	push	249					; 000000f9H
	push	OFFSET ??_C@_1IM@NCODKBJH@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	2
	call	DWORD PTR __imp___CrtDbgReportW
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN5@Compat
	int	3
$LN5@Compat:
	mov	esi, esp
	push	0
	push	249					; 000000f9H
	push	OFFSET ??_C@_1IM@NCODKBJH@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	OFFSET ??_C@_1NK@NBKKOKHK@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
	push	OFFSET ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN1@Compat:

; 250  : 			}
; 251  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UMovingTile@@@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<MovingTile> > >::_Compat
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UMovingTile@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv69 = -208						; size = 4
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UMovingTile@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<MovingTile> > >::operator!=, COMDAT
; _this$ = ecx

; 218  : 		{	// test for iterator inequality

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 219  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UMovingTile@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<MovingTile> > >::operator==
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv69[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv69[ebp]

; 220  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UMovingTile@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<MovingTile> > >::operator!=
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UMovingTile@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv69 = -208						; size = 4
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UMovingTile@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<MovingTile> > >::operator==, COMDAT
; _this$ = ecx

; 212  : 		{	// test for iterator equality

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 213  : 		_Compat(_Right);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UMovingTile@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<MovingTile> > >::_Compat

; 214  : 		return (_Ptr == _Right._Ptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+8]
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv69[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv69[ebp]

; 215  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UMovingTile@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<MovingTile> > >::operator==
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UMovingTile@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
__Mycont$ = -20						; size = 4
_this$ = -8						; size = 4
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UMovingTile@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<MovingTile> > >::operator++, COMDAT
; _this$ = ecx

; 95   : 		{	// preincrement

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 96   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 97   : 		const auto _Mycont = static_cast<const _Myvec *>(this->_Getcont());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
	mov	DWORD PTR __Mycont$[ebp], eax

; 98   : 		if (_Mycont == 0
; 99   : 			|| _Ptr == nullptr_t{}
; 100  : 			|| _Mycont->_Mylast <= _Ptr)

	cmp	DWORD PTR __Mycont$[ebp], 0
	je	SHORT $LN3@operator
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN3@operator
	mov	eax, DWORD PTR __Mycont$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+8]
	ja	SHORT $LN2@operator
$LN3@operator:

; 101  : 			{	// report error
; 102  : 			_DEBUG_ERROR("vector iterator not incrementable");

	mov	esi, esp
	push	102					; 00000066H
	push	OFFSET ??_C@_1IM@NCODKBJH@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	OFFSET ??_C@_1EE@EJDKCLKB@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAi?$AAn?$AAc?$AAr?$AAe?$AAm?$AAe?$AAn?$AAt?$AAa?$AAb?$AAl@
	call	DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 103  : 			_SCL_SECURE_OUT_OF_RANGE;

	mov	eax, OFFSET ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@
	test	eax, eax
	je	SHORT $LN5@operator
	xor	ecx, ecx
	jne	SHORT $LN6@operator
$LN5@operator:
	mov	esi, esp
	push	OFFSET ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@
	push	OFFSET ??_C@_17CNPHIMPH@?$AA?$CF?$AAl?$AAs?$AA?$AA@
	push	0
	push	103					; 00000067H
	push	OFFSET ??_C@_1IM@NCODKBJH@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	2
	call	DWORD PTR __imp___CrtDbgReportW
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN6@operator
	int	3
$LN6@operator:
	mov	esi, esp
	push	0
	push	103					; 00000067H
	push	OFFSET ??_C@_1IM@NCODKBJH@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	OFFSET ??_C@_1OC@EGHAOCGO@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
	push	OFFSET ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@operator:

; 104  : 			}
; 105  : 
; 106  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 107  : 		_SCL_SECURE_VALIDATE(_Ptr != _Tptr());
; 108  : 		const auto _Mycont = static_cast<const _Myvec *>(this->_Getcont());
; 109  : 		_SCL_SECURE_VALIDATE(_Mycont != 0);
; 110  : 		_SCL_SECURE_VALIDATE_RANGE(_Ptr < _Mycont->_Mylast);
; 111  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 112  : 
; 113  : 		++_Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, 48					; 00000030H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 114  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 115  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UMovingTile@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<MovingTile> > >::operator++
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UMovingTile@@@std@@@std@@@std@@QBEABUMovingTile@@XZ
_TEXT	SEGMENT
__Mycont$ = -20						; size = 4
_this$ = -8						; size = 4
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UMovingTile@@@std@@@std@@@std@@QBEABUMovingTile@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<MovingTile> > >::operator*, COMDAT
; _this$ = ecx

; 65   : 		{	// return designated object

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 66   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 67   : 		const auto _Mycont = static_cast<const _Myvec *>(this->_Getcont());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
	mov	DWORD PTR __Mycont$[ebp], eax

; 68   : 		if (_Mycont == 0
; 69   : 			|| _Ptr == _Tptr()
; 70   : 			|| _Ptr < _Mycont->_Myfirst
; 71   : 			|| _Mycont->_Mylast <= _Ptr)

	cmp	DWORD PTR __Mycont$[ebp], 0
	je	SHORT $LN3@operator
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN3@operator
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Mycont$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+4]
	jb	SHORT $LN3@operator
	mov	eax, DWORD PTR __Mycont$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+8]
	ja	SHORT $LN2@operator
$LN3@operator:

; 72   : 			{	// report error
; 73   : 			_DEBUG_ERROR("vector iterator not dereferencable");

	mov	esi, esp
	push	73					; 00000049H
	push	OFFSET ??_C@_1IM@NCODKBJH@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	OFFSET ??_C@_1EG@FOHJJHAC@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe?$AAn?$AAc?$AAa?$AAb@
	call	DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 74   : 			_SCL_SECURE_OUT_OF_RANGE;

	mov	eax, OFFSET ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@
	test	eax, eax
	je	SHORT $LN5@operator
	xor	ecx, ecx
	jne	SHORT $LN6@operator
$LN5@operator:
	mov	esi, esp
	push	OFFSET ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@
	push	OFFSET ??_C@_17CNPHIMPH@?$AA?$CF?$AAl?$AAs?$AA?$AA@
	push	0
	push	74					; 0000004aH
	push	OFFSET ??_C@_1IM@NCODKBJH@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	2
	call	DWORD PTR __imp___CrtDbgReportW
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN6@operator
	int	3
$LN6@operator:
	mov	esi, esp
	push	0
	push	74					; 0000004aH
	push	OFFSET ??_C@_1IM@NCODKBJH@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	OFFSET ??_C@_1OA@POONEEJK@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
	push	OFFSET ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@operator:

; 75   : 			}
; 76   : 
; 77   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 78   : 		_SCL_SECURE_VALIDATE(_Ptr != _Tptr());
; 79   : 		const auto _Mycont = static_cast<const _Myvec *>(this->_Getcont());
; 80   : 		_SCL_SECURE_VALIDATE(_Mycont != 0);
; 81   : 		_SCL_SECURE_VALIDATE_RANGE(_Mycont->_Myfirst <= _Ptr && _Ptr < _Mycont->_Mylast);
; 82   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 83   : 
; 84   : 		_Analysis_assume_(_Ptr != _Tptr());
; 85   : 
; 86   : 		return (*_Ptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]

; 87   : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UMovingTile@@@std@@@std@@@std@@QBEABUMovingTile@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<MovingTile> > >::operator*
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UMovingTile@@@std@@@std@@@std@@QAE@PAUMovingTile@@PBU_Container_base12@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UMovingTile@@@std@@@std@@@std@@QAE@PAUMovingTile@@PBU_Container_base12@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<MovingTile> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<MovingTile> > >, COMDAT
; _this$ = ecx

; 47   : 		{	// construct with pointer _Parg

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UMovingTile@@@std@@@std@@@std@@QAE@PAUMovingTile@@PBU_Container_base12@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Iterator012@Urandom_access_iterator_tag@std@@UMovingTile@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 46   : 		: _Ptr(_Parg)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Parg$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 48   : 		this->_Adopt(_Pvector);

	mov	eax, DWORD PTR __Pvector$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt

; 49   : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UMovingTile@@@std@@@std@@@std@@QAE@PAUMovingTile@@PBU_Container_base12@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Iterator012@Urandom_access_iterator_tag@std@@UMovingTile@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ
__ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UMovingTile@@@std@@@std@@@std@@QAE@PAUMovingTile@@PBU_Container_base12@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UMovingTile@@@std@@@std@@@std@@QAE@PAUMovingTile@@PBU_Container_base12@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UMovingTile@@@std@@@std@@@std@@QAE@PAUMovingTile@@PBU_Container_base12@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<MovingTile> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<MovingTile> > >
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1?$_Iterator012@Urandom_access_iterator_tag@std@@UMovingTile@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$_Iterator012@Urandom_access_iterator_tag@std@@UMovingTile@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ PROC ; std::_Iterator012<std::random_access_iterator_tag,MovingTile,int,MovingTile const *,MovingTile const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,MovingTile,int,MovingTile const *,MovingTile const &,std::_Iterator_base12>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Iterator_base12@std@@QAE@XZ		; std::_Iterator_base12::~_Iterator_base12
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Iterator012@Urandom_access_iterator_tag@std@@UMovingTile@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ ENDP ; std::_Iterator012<std::random_access_iterator_tag,MovingTile,int,MovingTile const *,MovingTile const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,MovingTile,int,MovingTile const *,MovingTile const &,std::_Iterator_base12>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??0?$_Iterator012@Urandom_access_iterator_tag@std@@UMovingTile@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$_Iterator012@Urandom_access_iterator_tag@std@@UMovingTile@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ PROC ; std::_Iterator012<std::random_access_iterator_tag,MovingTile,int,MovingTile const *,MovingTile const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,MovingTile,int,MovingTile const *,MovingTile const &,std::_Iterator_base12>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Iterator_base12@std@@QAE@XZ		; std::_Iterator_base12::_Iterator_base12
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Iterator012@Urandom_access_iterator_tag@std@@UMovingTile@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ ENDP ; std::_Iterator012<std::random_access_iterator_tag,MovingTile,int,MovingTile const *,MovingTile const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,MovingTile,int,MovingTile const *,MovingTile const &,std::_Iterator_base12>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?end@?$vector@UMovingTile@@V?$allocator@UMovingTile@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UMovingTile@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@UMovingTile@@V?$allocator@UMovingTile@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UMovingTile@@@std@@@std@@@2@XZ PROC ; std::vector<MovingTile,std::allocator<MovingTile> >::end, COMDAT
; _this$ = ecx

; 1067 : 		{	// return iterator for end of mutable sequence

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?end@?$vector@UMovingTile@@V?$allocator@UMovingTile@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UMovingTile@@@std@@@std@@@2@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1068 : 		return (iterator(this->_Mylast(), &this->_Get_data()));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UMovingTile@@V?$allocator@UMovingTile@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UMovingTile@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<MovingTile,std::allocator<MovingTile> > >::_Get_data
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UMovingTile@@V?$allocator@UMovingTile@@@std@@@std@@@std@@QAEAAPAUMovingTile@@XZ ; std::_Vector_alloc<std::_Vec_base_types<MovingTile,std::allocator<MovingTile> > >::_Mylast
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UMovingTile@@@std@@@std@@@std@@QAE@PAUMovingTile@@PBU_Container_base12@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<MovingTile> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<MovingTile> > >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1069 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?end@?$vector@UMovingTile@@V?$allocator@UMovingTile@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UMovingTile@@@std@@@std@@@2@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?end@?$vector@UMovingTile@@V?$allocator@UMovingTile@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UMovingTile@@@std@@@std@@@2@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?end@?$vector@UMovingTile@@V?$allocator@UMovingTile@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UMovingTile@@@std@@@std@@@2@XZ ENDP ; std::vector<MovingTile,std::allocator<MovingTile> >::end
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?begin@?$vector@UMovingTile@@V?$allocator@UMovingTile@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UMovingTile@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@UMovingTile@@V?$allocator@UMovingTile@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UMovingTile@@@std@@@std@@@2@XZ PROC ; std::vector<MovingTile,std::allocator<MovingTile> >::begin, COMDAT
; _this$ = ecx

; 1057 : 		{	// return iterator for beginning of mutable sequence

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?begin@?$vector@UMovingTile@@V?$allocator@UMovingTile@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UMovingTile@@@std@@@std@@@2@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1058 : 		return (iterator(this->_Myfirst(), &this->_Get_data()));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UMovingTile@@V?$allocator@UMovingTile@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UMovingTile@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<MovingTile,std::allocator<MovingTile> > >::_Get_data
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UMovingTile@@V?$allocator@UMovingTile@@@std@@@std@@@std@@QAEAAPAUMovingTile@@XZ ; std::_Vector_alloc<std::_Vec_base_types<MovingTile,std::allocator<MovingTile> > >::_Myfirst
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UMovingTile@@@std@@@std@@@std@@QAE@PAUMovingTile@@PBU_Container_base12@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<MovingTile> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<MovingTile> > >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1059 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?begin@?$vector@UMovingTile@@V?$allocator@UMovingTile@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UMovingTile@@@std@@@std@@@2@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?begin@?$vector@UMovingTile@@V?$allocator@UMovingTile@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UMovingTile@@@std@@@std@@@2@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?begin@?$vector@UMovingTile@@V?$allocator@UMovingTile@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UMovingTile@@@std@@@std@@@2@XZ ENDP ; std::vector<MovingTile,std::allocator<MovingTile> >::begin
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UMovingTile@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UMovingTile@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UMovingTile@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UMovingTile@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UMovingTile@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UMovingTile@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<MovingTile> >,std::_Vector_val<std::_Simple_types<MovingTile> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 314  : 		{	// return reference to second

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 315  : 		return (_Myval2);

	mov	eax, DWORD PTR _this$[ebp]

; 316  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UMovingTile@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UMovingTile@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UMovingTile@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<MovingTile> >,std::_Vector_val<std::_Simple_types<MovingTile> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UMovingTile@@V?$allocator@UMovingTile@@@std@@@std@@@std@@QAEAAPAUMovingTile@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UMovingTile@@V?$allocator@UMovingTile@@@std@@@std@@@std@@QAEAAPAUMovingTile@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<MovingTile,std::allocator<MovingTile> > >::_Mylast, COMDAT
; _this$ = ecx

; 652  : 		{	// return reference to _Mylast

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 653  : 		return (_Get_data()._Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UMovingTile@@V?$allocator@UMovingTile@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UMovingTile@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<MovingTile,std::allocator<MovingTile> > >::_Get_data
	add	eax, 8

; 654  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UMovingTile@@V?$allocator@UMovingTile@@@std@@@std@@@std@@QAEAAPAUMovingTile@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<MovingTile,std::allocator<MovingTile> > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UMovingTile@@V?$allocator@UMovingTile@@@std@@@std@@@std@@QAEAAPAUMovingTile@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UMovingTile@@V?$allocator@UMovingTile@@@std@@@std@@@std@@QAEAAPAUMovingTile@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<MovingTile,std::allocator<MovingTile> > >::_Myfirst, COMDAT
; _this$ = ecx

; 642  : 		{	// return reference to _Myfirst

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 643  : 		return (_Get_data()._Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UMovingTile@@V?$allocator@UMovingTile@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UMovingTile@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<MovingTile,std::allocator<MovingTile> > >::_Get_data
	add	eax, 4

; 644  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UMovingTile@@V?$allocator@UMovingTile@@@std@@@std@@@std@@QAEAAPAUMovingTile@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<MovingTile,std::allocator<MovingTile> > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UMovingTile@@V?$allocator@UMovingTile@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UMovingTile@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UMovingTile@@V?$allocator@UMovingTile@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UMovingTile@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<MovingTile,std::allocator<MovingTile> > >::_Get_data, COMDAT
; _this$ = ecx

; 632  : 		{	// return reference to _Vector_val

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 633  : 		return (_Mypair._Get_second());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UMovingTile@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UMovingTile@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UMovingTile@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<MovingTile> >,std::_Vector_val<std::_Simple_types<MovingTile> >,1>::_Get_second

; 634  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UMovingTile@@V?$allocator@UMovingTile@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UMovingTile@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<MovingTile,std::allocator<MovingTile> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?__autoclassinit2@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UAirTile@@@std@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_classSize$ = 8						; size = 4
?__autoclassinit2@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UAirTile@@@std@@@std@@@std@@QAEXI@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<AirTile> > >::__autoclassinit2, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _classSize$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?__autoclassinit2@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UAirTile@@@std@@@std@@@std@@QAEXI@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<AirTile> > >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UAirTile@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UAirTile@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<AirTile> > >::~_Vector_iterator<std::_Vector_val<std::_Simple_types<AirTile> > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UAirTile@@@std@@@std@@@std@@QAE@XZ
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UAirTile@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<AirTile> > >::~_Vector_iterator<std::_Vector_val<std::_Simple_types<AirTile> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UAirTile@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UAirTile@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<AirTile> > >::operator++, COMDAT
; _this$ = ecx

; 340  : 		{	// preincrement

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 341  : 		++*(_Mybase *)this;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UAirTile@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<AirTile> > >::operator++

; 342  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 343  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UAirTile@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<AirTile> > >::operator++
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UAirTile@@@std@@@std@@@std@@QBEAAUAirTile@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UAirTile@@@std@@@std@@@std@@QBEAAUAirTile@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<AirTile> > >::operator*, COMDAT
; _this$ = ecx

; 330  : 		{	// return designated object

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 331  : 		return ((reference)**(_Mybase *)this);

	mov	ecx, DWORD PTR _this$[ebp]
	call	??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UAirTile@@@std@@@std@@@std@@QBEABUAirTile@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<AirTile> > >::operator*

; 332  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UAirTile@@@std@@@std@@@std@@QBEAAUAirTile@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<AirTile> > >::operator*
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UAirTile@@@std@@@std@@@std@@QAE@PAUAirTile@@PBU_Container_base12@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UAirTile@@@std@@@std@@@std@@QAE@PAUAirTile@@PBU_Container_base12@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<AirTile> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<AirTile> > >, COMDAT
; _this$ = ecx

; 313  : 		{	// construct with pointer _Parg

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 312  : 		: _Mybase(_Parg, _Pvector)

	mov	eax, DWORD PTR __Pvector$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Parg$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UAirTile@@@std@@@std@@@std@@QAE@PAUAirTile@@PBU_Container_base12@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<AirTile> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<AirTile> > >

; 314  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UAirTile@@@std@@@std@@@std@@QAE@PAUAirTile@@PBU_Container_base12@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<AirTile> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<AirTile> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UAirTile@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UAirTile@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<AirTile> > >::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<AirTile> > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Iterator012@Urandom_access_iterator_tag@std@@UAirTile@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UAirTile@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<AirTile> > >::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<AirTile> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UAirTile@@@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UAirTile@@@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<AirTile> > >::_Compat, COMDAT
; _this$ = ecx

; 245  : 		{	// test for compatible iterator pair

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 246  : 		if (this->_Getcont() != _Right._Getcont())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
	mov	esi, eax
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
	cmp	esi, eax
	je	$LN1@Compat

; 247  : 			{
; 248  : 			_DEBUG_ERROR("vector iterators incompatible");

	mov	esi, esp
	push	248					; 000000f8H
	push	OFFSET ??_C@_1IM@NCODKBJH@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	OFFSET ??_C@_1DM@HINDPMBP@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AAs?$AA?5?$AAi?$AAn?$AAc?$AAo?$AAm?$AAp?$AAa?$AAt?$AAi?$AAb?$AAl?$AAe?$AA?$AA@
	call	DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 249  : 			_SCL_SECURE_INVALID_ARGUMENT;

	mov	eax, OFFSET ??_C@_0CI@FNPHFCCM@Standard?5C?$CL?$CL?5Libraries?5Invalid?5A@
	test	eax, eax
	je	SHORT $LN4@Compat
	xor	ecx, ecx
	jne	SHORT $LN5@Compat
$LN4@Compat:
	mov	esi, esp
	push	OFFSET ??_C@_1FO@GJIHNDLM@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5@
	push	OFFSET ??_C@_17CNPHIMPH@?$AA?$CF?$AAl?$AAs?$AA?$AA@
	push	0
	push	249					; 000000f9H
	push	OFFSET ??_C@_1IM@NCODKBJH@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	2
	call	DWORD PTR __imp___CrtDbgReportW
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN5@Compat
	int	3
$LN5@Compat:
	mov	esi, esp
	push	0
	push	249					; 000000f9H
	push	OFFSET ??_C@_1IM@NCODKBJH@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	OFFSET ??_C@_1NE@PKGEKJGN@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
	push	OFFSET ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN1@Compat:

; 250  : 			}
; 251  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UAirTile@@@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<AirTile> > >::_Compat
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UAirTile@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv69 = -208						; size = 4
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UAirTile@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<AirTile> > >::operator!=, COMDAT
; _this$ = ecx

; 218  : 		{	// test for iterator inequality

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 219  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UAirTile@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<AirTile> > >::operator==
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv69[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv69[ebp]

; 220  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UAirTile@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<AirTile> > >::operator!=
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UAirTile@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv69 = -208						; size = 4
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UAirTile@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<AirTile> > >::operator==, COMDAT
; _this$ = ecx

; 212  : 		{	// test for iterator equality

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 213  : 		_Compat(_Right);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UAirTile@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<AirTile> > >::_Compat

; 214  : 		return (_Ptr == _Right._Ptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+8]
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv69[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv69[ebp]

; 215  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UAirTile@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<AirTile> > >::operator==
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UAirTile@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
__Mycont$ = -20						; size = 4
_this$ = -8						; size = 4
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UAirTile@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<AirTile> > >::operator++, COMDAT
; _this$ = ecx

; 95   : 		{	// preincrement

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 96   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 97   : 		const auto _Mycont = static_cast<const _Myvec *>(this->_Getcont());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
	mov	DWORD PTR __Mycont$[ebp], eax

; 98   : 		if (_Mycont == 0
; 99   : 			|| _Ptr == nullptr_t{}
; 100  : 			|| _Mycont->_Mylast <= _Ptr)

	cmp	DWORD PTR __Mycont$[ebp], 0
	je	SHORT $LN3@operator
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN3@operator
	mov	eax, DWORD PTR __Mycont$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+8]
	ja	SHORT $LN2@operator
$LN3@operator:

; 101  : 			{	// report error
; 102  : 			_DEBUG_ERROR("vector iterator not incrementable");

	mov	esi, esp
	push	102					; 00000066H
	push	OFFSET ??_C@_1IM@NCODKBJH@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	OFFSET ??_C@_1EE@EJDKCLKB@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAi?$AAn?$AAc?$AAr?$AAe?$AAm?$AAe?$AAn?$AAt?$AAa?$AAb?$AAl@
	call	DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 103  : 			_SCL_SECURE_OUT_OF_RANGE;

	mov	eax, OFFSET ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@
	test	eax, eax
	je	SHORT $LN5@operator
	xor	ecx, ecx
	jne	SHORT $LN6@operator
$LN5@operator:
	mov	esi, esp
	push	OFFSET ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@
	push	OFFSET ??_C@_17CNPHIMPH@?$AA?$CF?$AAl?$AAs?$AA?$AA@
	push	0
	push	103					; 00000067H
	push	OFFSET ??_C@_1IM@NCODKBJH@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	2
	call	DWORD PTR __imp___CrtDbgReportW
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN6@operator
	int	3
$LN6@operator:
	mov	esi, esp
	push	0
	push	103					; 00000067H
	push	OFFSET ??_C@_1IM@NCODKBJH@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	OFFSET ??_C@_1NM@NIBONEGJ@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
	push	OFFSET ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@operator:

; 104  : 			}
; 105  : 
; 106  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 107  : 		_SCL_SECURE_VALIDATE(_Ptr != _Tptr());
; 108  : 		const auto _Mycont = static_cast<const _Myvec *>(this->_Getcont());
; 109  : 		_SCL_SECURE_VALIDATE(_Mycont != 0);
; 110  : 		_SCL_SECURE_VALIDATE_RANGE(_Ptr < _Mycont->_Mylast);
; 111  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 112  : 
; 113  : 		++_Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, 48					; 00000030H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 114  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 115  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UAirTile@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<AirTile> > >::operator++
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UAirTile@@@std@@@std@@@std@@QBEABUAirTile@@XZ
_TEXT	SEGMENT
__Mycont$ = -20						; size = 4
_this$ = -8						; size = 4
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UAirTile@@@std@@@std@@@std@@QBEABUAirTile@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<AirTile> > >::operator*, COMDAT
; _this$ = ecx

; 65   : 		{	// return designated object

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 66   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 67   : 		const auto _Mycont = static_cast<const _Myvec *>(this->_Getcont());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
	mov	DWORD PTR __Mycont$[ebp], eax

; 68   : 		if (_Mycont == 0
; 69   : 			|| _Ptr == _Tptr()
; 70   : 			|| _Ptr < _Mycont->_Myfirst
; 71   : 			|| _Mycont->_Mylast <= _Ptr)

	cmp	DWORD PTR __Mycont$[ebp], 0
	je	SHORT $LN3@operator
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN3@operator
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Mycont$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+4]
	jb	SHORT $LN3@operator
	mov	eax, DWORD PTR __Mycont$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+8]
	ja	SHORT $LN2@operator
$LN3@operator:

; 72   : 			{	// report error
; 73   : 			_DEBUG_ERROR("vector iterator not dereferencable");

	mov	esi, esp
	push	73					; 00000049H
	push	OFFSET ??_C@_1IM@NCODKBJH@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	OFFSET ??_C@_1EG@FOHJJHAC@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe?$AAn?$AAc?$AAa?$AAb@
	call	DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 74   : 			_SCL_SECURE_OUT_OF_RANGE;

	mov	eax, OFFSET ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@
	test	eax, eax
	je	SHORT $LN5@operator
	xor	ecx, ecx
	jne	SHORT $LN6@operator
$LN5@operator:
	mov	esi, esp
	push	OFFSET ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@
	push	OFFSET ??_C@_17CNPHIMPH@?$AA?$CF?$AAl?$AAs?$AA?$AA@
	push	0
	push	74					; 0000004aH
	push	OFFSET ??_C@_1IM@NCODKBJH@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	2
	call	DWORD PTR __imp___CrtDbgReportW
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN6@operator
	int	3
$LN6@operator:
	mov	esi, esp
	push	0
	push	74					; 0000004aH
	push	OFFSET ??_C@_1IM@NCODKBJH@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	OFFSET ??_C@_1NK@FNOHGEBE@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
	push	OFFSET ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@operator:

; 75   : 			}
; 76   : 
; 77   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 78   : 		_SCL_SECURE_VALIDATE(_Ptr != _Tptr());
; 79   : 		const auto _Mycont = static_cast<const _Myvec *>(this->_Getcont());
; 80   : 		_SCL_SECURE_VALIDATE(_Mycont != 0);
; 81   : 		_SCL_SECURE_VALIDATE_RANGE(_Mycont->_Myfirst <= _Ptr && _Ptr < _Mycont->_Mylast);
; 82   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 83   : 
; 84   : 		_Analysis_assume_(_Ptr != _Tptr());
; 85   : 
; 86   : 		return (*_Ptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]

; 87   : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UAirTile@@@std@@@std@@@std@@QBEABUAirTile@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<AirTile> > >::operator*
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UAirTile@@@std@@@std@@@std@@QAE@PAUAirTile@@PBU_Container_base12@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UAirTile@@@std@@@std@@@std@@QAE@PAUAirTile@@PBU_Container_base12@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<AirTile> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<AirTile> > >, COMDAT
; _this$ = ecx

; 47   : 		{	// construct with pointer _Parg

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UAirTile@@@std@@@std@@@std@@QAE@PAUAirTile@@PBU_Container_base12@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Iterator012@Urandom_access_iterator_tag@std@@UAirTile@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 46   : 		: _Ptr(_Parg)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Parg$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 48   : 		this->_Adopt(_Pvector);

	mov	eax, DWORD PTR __Pvector$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt

; 49   : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UAirTile@@@std@@@std@@@std@@QAE@PAUAirTile@@PBU_Container_base12@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Iterator012@Urandom_access_iterator_tag@std@@UAirTile@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ
__ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UAirTile@@@std@@@std@@@std@@QAE@PAUAirTile@@PBU_Container_base12@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UAirTile@@@std@@@std@@@std@@QAE@PAUAirTile@@PBU_Container_base12@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UAirTile@@@std@@@std@@@std@@QAE@PAUAirTile@@PBU_Container_base12@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<AirTile> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<AirTile> > >
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1?$_Iterator012@Urandom_access_iterator_tag@std@@UAirTile@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$_Iterator012@Urandom_access_iterator_tag@std@@UAirTile@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ PROC ; std::_Iterator012<std::random_access_iterator_tag,AirTile,int,AirTile const *,AirTile const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,AirTile,int,AirTile const *,AirTile const &,std::_Iterator_base12>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Iterator_base12@std@@QAE@XZ		; std::_Iterator_base12::~_Iterator_base12
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Iterator012@Urandom_access_iterator_tag@std@@UAirTile@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ ENDP ; std::_Iterator012<std::random_access_iterator_tag,AirTile,int,AirTile const *,AirTile const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,AirTile,int,AirTile const *,AirTile const &,std::_Iterator_base12>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??0?$_Iterator012@Urandom_access_iterator_tag@std@@UAirTile@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$_Iterator012@Urandom_access_iterator_tag@std@@UAirTile@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ PROC ; std::_Iterator012<std::random_access_iterator_tag,AirTile,int,AirTile const *,AirTile const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,AirTile,int,AirTile const *,AirTile const &,std::_Iterator_base12>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Iterator_base12@std@@QAE@XZ		; std::_Iterator_base12::_Iterator_base12
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Iterator012@Urandom_access_iterator_tag@std@@UAirTile@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ ENDP ; std::_Iterator012<std::random_access_iterator_tag,AirTile,int,AirTile const *,AirTile const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,AirTile,int,AirTile const *,AirTile const &,std::_Iterator_base12>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?end@?$vector@UAirTile@@V?$allocator@UAirTile@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UAirTile@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@UAirTile@@V?$allocator@UAirTile@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UAirTile@@@std@@@std@@@2@XZ PROC ; std::vector<AirTile,std::allocator<AirTile> >::end, COMDAT
; _this$ = ecx

; 1067 : 		{	// return iterator for end of mutable sequence

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?end@?$vector@UAirTile@@V?$allocator@UAirTile@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UAirTile@@@std@@@std@@@2@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1068 : 		return (iterator(this->_Mylast(), &this->_Get_data()));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UAirTile@@V?$allocator@UAirTile@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UAirTile@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<AirTile,std::allocator<AirTile> > >::_Get_data
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UAirTile@@V?$allocator@UAirTile@@@std@@@std@@@std@@QAEAAPAUAirTile@@XZ ; std::_Vector_alloc<std::_Vec_base_types<AirTile,std::allocator<AirTile> > >::_Mylast
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UAirTile@@@std@@@std@@@std@@QAE@PAUAirTile@@PBU_Container_base12@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<AirTile> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<AirTile> > >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1069 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?end@?$vector@UAirTile@@V?$allocator@UAirTile@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UAirTile@@@std@@@std@@@2@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?end@?$vector@UAirTile@@V?$allocator@UAirTile@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UAirTile@@@std@@@std@@@2@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?end@?$vector@UAirTile@@V?$allocator@UAirTile@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UAirTile@@@std@@@std@@@2@XZ ENDP ; std::vector<AirTile,std::allocator<AirTile> >::end
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?begin@?$vector@UAirTile@@V?$allocator@UAirTile@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UAirTile@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@UAirTile@@V?$allocator@UAirTile@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UAirTile@@@std@@@std@@@2@XZ PROC ; std::vector<AirTile,std::allocator<AirTile> >::begin, COMDAT
; _this$ = ecx

; 1057 : 		{	// return iterator for beginning of mutable sequence

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?begin@?$vector@UAirTile@@V?$allocator@UAirTile@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UAirTile@@@std@@@std@@@2@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1058 : 		return (iterator(this->_Myfirst(), &this->_Get_data()));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UAirTile@@V?$allocator@UAirTile@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UAirTile@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<AirTile,std::allocator<AirTile> > >::_Get_data
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UAirTile@@V?$allocator@UAirTile@@@std@@@std@@@std@@QAEAAPAUAirTile@@XZ ; std::_Vector_alloc<std::_Vec_base_types<AirTile,std::allocator<AirTile> > >::_Myfirst
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UAirTile@@@std@@@std@@@std@@QAE@PAUAirTile@@PBU_Container_base12@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<AirTile> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<AirTile> > >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1059 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?begin@?$vector@UAirTile@@V?$allocator@UAirTile@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UAirTile@@@std@@@std@@@2@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?begin@?$vector@UAirTile@@V?$allocator@UAirTile@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UAirTile@@@std@@@std@@@2@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?begin@?$vector@UAirTile@@V?$allocator@UAirTile@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UAirTile@@@std@@@std@@@2@XZ ENDP ; std::vector<AirTile,std::allocator<AirTile> >::begin
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UAirTile@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UAirTile@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UAirTile@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UAirTile@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UAirTile@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UAirTile@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<AirTile> >,std::_Vector_val<std::_Simple_types<AirTile> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 314  : 		{	// return reference to second

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 315  : 		return (_Myval2);

	mov	eax, DWORD PTR _this$[ebp]

; 316  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UAirTile@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UAirTile@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UAirTile@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<AirTile> >,std::_Vector_val<std::_Simple_types<AirTile> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UAirTile@@V?$allocator@UAirTile@@@std@@@std@@@std@@QAEAAPAUAirTile@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UAirTile@@V?$allocator@UAirTile@@@std@@@std@@@std@@QAEAAPAUAirTile@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<AirTile,std::allocator<AirTile> > >::_Mylast, COMDAT
; _this$ = ecx

; 652  : 		{	// return reference to _Mylast

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 653  : 		return (_Get_data()._Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UAirTile@@V?$allocator@UAirTile@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UAirTile@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<AirTile,std::allocator<AirTile> > >::_Get_data
	add	eax, 8

; 654  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UAirTile@@V?$allocator@UAirTile@@@std@@@std@@@std@@QAEAAPAUAirTile@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<AirTile,std::allocator<AirTile> > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UAirTile@@V?$allocator@UAirTile@@@std@@@std@@@std@@QAEAAPAUAirTile@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UAirTile@@V?$allocator@UAirTile@@@std@@@std@@@std@@QAEAAPAUAirTile@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<AirTile,std::allocator<AirTile> > >::_Myfirst, COMDAT
; _this$ = ecx

; 642  : 		{	// return reference to _Myfirst

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 643  : 		return (_Get_data()._Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UAirTile@@V?$allocator@UAirTile@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UAirTile@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<AirTile,std::allocator<AirTile> > >::_Get_data
	add	eax, 4

; 644  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UAirTile@@V?$allocator@UAirTile@@@std@@@std@@@std@@QAEAAPAUAirTile@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<AirTile,std::allocator<AirTile> > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UAirTile@@V?$allocator@UAirTile@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UAirTile@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UAirTile@@V?$allocator@UAirTile@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UAirTile@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<AirTile,std::allocator<AirTile> > >::_Get_data, COMDAT
; _this$ = ecx

; 632  : 		{	// return reference to _Vector_val

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 633  : 		return (_Mypair._Get_second());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UAirTile@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UAirTile@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UAirTile@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<AirTile> >,std::_Vector_val<std::_Simple_types<AirTile> >,1>::_Get_second

; 634  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UAirTile@@V?$allocator@UAirTile@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UAirTile@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<AirTile,std::allocator<AirTile> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@W4<unnamed-enum-SDLK_UNKNOWN>@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@V10@0ABW4<unnamed-enum-SDLK_UNKNOWN>@@@Z
_TEXT	SEGMENT
tv130 = -284						; size = 4
tv184 = -280						; size = 4
tv183 = -276						; size = 4
tv176 = -276						; size = 4
tv180 = -272						; size = 4
tv173 = -272						; size = 4
tv179 = -268						; size = 4
tv128 = -268						; size = 4
$T2 = -260						; size = 4
$T3 = -248						; size = 4
$T4 = -236						; size = 4
$T5 = -224						; size = 4
$T6 = -212						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First$ = 12						; size = 12
__Last$ = 24						; size = 12
__Val$ = 36						; size = 4
??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@W4<unnamed-enum-SDLK_UNKNOWN>@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@V10@0ABW4<unnamed-enum-SDLK_UNKNOWN>@@@Z PROC ; std::find<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >,enum <unnamed-enum-SDLK_UNKNOWN> >, COMDAT

; 3283 : 	{	// find first matching _Val

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@W4<unnamed-enum-SDLK_UNKNOWN>@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@V10@0ABW4<unnamed-enum-SDLK_UNKNOWN>@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 272				; 00000110H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-284]
	mov	ecx, 68					; 00000044H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR $T2[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 3284 : 	_DEBUG_RANGE(_First, _Last);

	push	3284					; 00000cd4H
	push	OFFSET ??_C@_1JA@MHADJNIL@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T6[ebp], esp
	lea	eax, DWORD PTR __Last$[ebp]
	push	eax
	call	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv128[ebp], eax
	mov	ecx, DWORD PTR tv128[ebp]
	mov	DWORD PTR tv173[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T5[ebp], esp
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv176[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	call	??$_Debug_range@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@@std@@YAXV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@0PB_WI@Z ; std::_Debug_range<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > > >
	add	esp, 32					; 00000020H

; 3285 : 	return (_Rechecked(_First,

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T4[ebp], esp
	lea	edx, DWORD PTR __Last$[ebp]
	push	edx
	call	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv179[ebp], eax
	call	??$_Unchecked@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@YAPAHV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@@Z ; std::_Unchecked<std::_Vector_val<std::_Simple_types<int> > >
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv180[ebp], eax
	mov	eax, DWORD PTR tv180[ebp]
	push	eax
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T3[ebp], esp
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv183[ebp], eax
	call	??$_Unchecked@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@YAPAHV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@@Z ; std::_Unchecked<std::_Vector_val<std::_Simple_types<int> > >
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv184[ebp], eax
	mov	eax, DWORD PTR tv184[ebp]
	push	eax
	call	??$_Find_unchecked@PAHW4<unnamed-enum-SDLK_UNKNOWN>@@@std@@YAPAHPAH0ABW4<unnamed-enum-SDLK_UNKNOWN>@@@Z ; std::_Find_unchecked<int *,enum <unnamed-enum-SDLK_UNKNOWN> >
	add	esp, 12					; 0000000cH
	mov	DWORD PTR tv130[ebp], eax
	mov	ecx, DWORD PTR tv130[ebp]
	push	ecx
	lea	edx, DWORD PTR __First$[ebp]
	push	edx
	call	??$_Rechecked@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@YAAAV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@AAV10@PAH@Z ; std::_Rechecked<std::_Vector_val<std::_Simple_types<int> > >
	add	esp, 8
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR $T2[ebp]
	or	eax, 1
	mov	DWORD PTR $T2[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __First$[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Last$[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 3286 : 		_Find_unchecked(_Unchecked(_First), _Unchecked(_Last), _Val)));
; 3287 : 	}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 284				; 0000011cH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@W4<unnamed-enum-SDLK_UNKNOWN>@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@V10@0ABW4<unnamed-enum-SDLK_UNKNOWN>@@@Z$0:
	lea	ecx, DWORD PTR __Last$[ebp]
	jmp	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@W4<unnamed-enum-SDLK_UNKNOWN>@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@V10@0ABW4<unnamed-enum-SDLK_UNKNOWN>@@@Z$1:
	lea	ecx, DWORD PTR __First$[ebp]
	jmp	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ
__unwindfunclet$??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@W4<unnamed-enum-SDLK_UNKNOWN>@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@V10@0ABW4<unnamed-enum-SDLK_UNKNOWN>@@@Z$2:
	mov	ecx, DWORD PTR $T6[ebp]
	jmp	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ
__ehhandler$??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@W4<unnamed-enum-SDLK_UNKNOWN>@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@V10@0ABW4<unnamed-enum-SDLK_UNKNOWN>@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-288]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@W4<unnamed-enum-SDLK_UNKNOWN>@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@V10@0ABW4<unnamed-enum-SDLK_UNKNOWN>@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@W4<unnamed-enum-SDLK_UNKNOWN>@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@V10@0ABW4<unnamed-enum-SDLK_UNKNOWN>@@@Z ENDP ; std::find<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >,enum <unnamed-enum-SDLK_UNKNOWN> >
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___that$ = 8						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >::~_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >::~_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBEPAHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBEPAHXZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >::_Unchecked, COMDAT
; _this$ = ecx

; 325  : 		{	// make an unchecked iterator

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 326  : 		return (this->_Ptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]

; 327  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBEPAHXZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >::_Unchecked
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Rechecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAEAAV12@PAH@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
?_Rechecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAEAAV12@PAH@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >::_Rechecked, COMDAT
; _this$ = ecx

; 319  : 		{	// reset from unchecked iterator

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 320  : 		this->_Ptr = _Right;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 321  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 322  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?_Rechecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAEAAV12@PAH@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >::_Rechecked
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >, COMDAT
; _this$ = ecx

; 313  : 		{	// construct with pointer _Parg

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 312  : 		: _Mybase(_Parg, _Pvector)

	mov	eax, DWORD PTR __Pvector$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Parg$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int> > >

; 314  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___that$ = 8						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int> > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@ABU01@@Z
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int> > >::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int> > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int> > >::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int> > >::_Compat, COMDAT
; _this$ = ecx

; 245  : 		{	// test for compatible iterator pair

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 246  : 		if (this->_Getcont() != _Right._Getcont())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
	mov	esi, eax
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
	cmp	esi, eax
	je	$LN1@Compat

; 247  : 			{
; 248  : 			_DEBUG_ERROR("vector iterators incompatible");

	mov	esi, esp
	push	248					; 000000f8H
	push	OFFSET ??_C@_1IM@NCODKBJH@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	OFFSET ??_C@_1DM@HINDPMBP@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AAs?$AA?5?$AAi?$AAn?$AAc?$AAo?$AAm?$AAp?$AAa?$AAt?$AAi?$AAb?$AAl?$AAe?$AA?$AA@
	call	DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 249  : 			_SCL_SECURE_INVALID_ARGUMENT;

	mov	eax, OFFSET ??_C@_0CI@FNPHFCCM@Standard?5C?$CL?$CL?5Libraries?5Invalid?5A@
	test	eax, eax
	je	SHORT $LN4@Compat
	xor	ecx, ecx
	jne	SHORT $LN5@Compat
$LN4@Compat:
	mov	esi, esp
	push	OFFSET ??_C@_1FO@GJIHNDLM@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5@
	push	OFFSET ??_C@_17CNPHIMPH@?$AA?$CF?$AAl?$AAs?$AA?$AA@
	push	0
	push	249					; 000000f9H
	push	OFFSET ??_C@_1IM@NCODKBJH@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	2
	call	DWORD PTR __imp___CrtDbgReportW
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN5@Compat
	int	3
$LN5@Compat:
	mov	esi, esp
	push	0
	push	249					; 000000f9H
	push	OFFSET ??_C@_1IM@NCODKBJH@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	OFFSET ??_C@_1LO@MGELDLOO@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
	push	OFFSET ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN1@Compat:

; 250  : 			}
; 251  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int> > >::_Compat
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??M?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv69 = -208						; size = 4
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
??M?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int> > >::operator<, COMDAT
; _this$ = ecx

; 223  : 		{	// test if this < _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 224  : 		_Compat(_Right);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int> > >::_Compat

; 225  : 		return (_Ptr < _Right._Ptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+8]
	jae	SHORT $LN3@operator
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv69[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv69[ebp]

; 226  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??M?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int> > >::operator<
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv69 = -208						; size = 4
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int> > >::operator!=, COMDAT
; _this$ = ecx

; 218  : 		{	// test for iterator inequality

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 219  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int> > >::operator==
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv69[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv69[ebp]

; 220  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int> > >::operator!=
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv69 = -208						; size = 4
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int> > >::operator==, COMDAT
; _this$ = ecx

; 212  : 		{	// test for iterator equality

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 213  : 		_Compat(_Right);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int> > >::_Compat

; 214  : 		return (_Ptr == _Right._Ptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+8]
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv69[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv69[ebp]

; 215  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int> > >::operator==
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int> > >, COMDAT
; _this$ = ecx

; 47   : 		{	// construct with pointer _Parg

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 46   : 		: _Ptr(_Parg)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Parg$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 48   : 		this->_Adopt(_Pvector);

	mov	eax, DWORD PTR __Pvector$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt

; 49   : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ
__ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int> > >
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??0?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@ABU01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___that$ = 8						; size = 4
??0?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@ABU01@@Z PROC ; std::_Iterator012<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base12>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Iterator_base12@std@@QAE@ABU01@@Z	; std::_Iterator_base12::_Iterator_base12
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@ABU01@@Z ENDP ; std::_Iterator012<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base12>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ PROC ; std::_Iterator012<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base12>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Iterator_base12@std@@QAE@XZ		; std::_Iterator_base12::~_Iterator_base12
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ ENDP ; std::_Iterator012<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base12>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??0?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ PROC ; std::_Iterator012<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base12>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Iterator_base12@std@@QAE@XZ		; std::_Iterator_base12::_Iterator_base12
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Iterator012@Urandom_access_iterator_tag@std@@HHPBHABHU_Iterator_base12@2@@std@@QAE@XZ ENDP ; std::_Iterator012<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,int,int,int const *,int const &,std::_Iterator_base12>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ PROC ; std::vector<int,std::allocator<int> >::end, COMDAT
; _this$ = ecx

; 1067 : 		{	// return iterator for end of mutable sequence

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1068 : 		return (iterator(this->_Mylast(), &this->_Get_data()));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@H@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Get_data
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEAAPAHXZ ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Mylast
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1069 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ ENDP ; std::vector<int,std::allocator<int> >::end
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ PROC ; std::vector<int,std::allocator<int> >::begin, COMDAT
; _this$ = ecx

; 1057 : 		{	// return iterator for beginning of mutable sequence

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1058 : 		return (iterator(this->_Myfirst(), &this->_Get_data()));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@H@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Get_data
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEAAPAHXZ ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Myfirst
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@PAHPBU_Container_base12@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1059 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ ENDP ; std::vector<int,std::allocator<int> >::begin
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@H@std@@@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@H@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@H@std@@@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@H@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<int> >,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 314  : 		{	// return reference to second

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 315  : 		return (_Myval2);

	mov	eax, DWORD PTR _this$[ebp]

; 316  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@H@std@@@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@H@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<int> >,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEAAPAHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEAAPAHXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Mylast, COMDAT
; _this$ = ecx

; 652  : 		{	// return reference to _Mylast

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 653  : 		return (_Get_data()._Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@H@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Get_data
	add	eax, 8

; 654  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEAAPAHXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEAAPAHXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEAAPAHXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Myfirst, COMDAT
; _this$ = ecx

; 642  : 		{	// return reference to _Myfirst

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 643  : 		return (_Get_data()._Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@H@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Get_data
	add	eax, 4

; 644  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEAAPAHXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@H@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@H@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Get_data, COMDAT
; _this$ = ecx

; 632  : 		{	// return reference to _Vector_val

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 633  : 		return (_Mypair._Get_second());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@H@std@@@std@@V?$_Vector_val@U?$_Simple_types@H@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@H@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<int> >,std::_Vector_val<std::_Simple_types<int> >,1>::_Get_second

; 634  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@HV?$allocator@H@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@H@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<int,std::allocator<int> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??__FgroundTileList@@YAXXZ
text$yd	SEGMENT
??__FgroundTileList@@YAXXZ PROC				; `dynamic atexit destructor for 'groundTileList'', COMDAT
	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET ?groundTileList@@3V?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@A ; groundTileList
	call	??1?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QAE@XZ ; std::vector<Tile,std::allocator<Tile> >::~vector<Tile,std::allocator<Tile> >
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??__FgroundTileList@@YAXXZ ENDP				; `dynamic atexit destructor for 'groundTileList''
text$yd	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File g:\projects\lotion\lotion\player.cpp
;	COMDAT ??__EgroundTileList@@YAXXZ
text$di	SEGMENT
??__EgroundTileList@@YAXXZ PROC				; `dynamic initializer for 'groundTileList'', COMDAT

; 17   : std::vector<Tile> groundTileList;

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	push	16					; 00000010H
	mov	ecx, OFFSET ?groundTileList@@3V?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@A ; groundTileList
	call	?__autoclassinit2@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QAEXI@Z
	mov	ecx, OFFSET ?groundTileList@@3V?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@A ; groundTileList
	call	??0?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QAE@XZ ; std::vector<Tile,std::allocator<Tile> >::vector<Tile,std::allocator<Tile> >
	push	OFFSET ??__FgroundTileList@@YAXXZ	; `dynamic atexit destructor for 'groundTileList''
	call	_atexit
	add	esp, 4
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??__EgroundTileList@@YAXXZ ENDP				; `dynamic initializer for 'groundTileList''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File g:\projects\lotion\lotion\player.cpp
;	COMDAT ?FloatingMovement@@YAXM@Z
_TEXT	SEGMENT
tv548 = -1124						; size = 4
tv441 = -1124						; size = 4
tv303 = -1124						; size = 4
tv196 = -1124						; size = 4
tv533 = -1117						; size = 1
tv426 = -1117						; size = 1
tv288 = -1117						; size = 1
tv181 = -1117						; size = 1
tv713 = -1116						; size = 4
tv671 = -1116						; size = 4
tv629 = -1116						; size = 4
tv587 = -1116						; size = 4
tv499 = -1112						; size = 4
tv360 = -1112						; size = 4
tv254 = -1112						; size = 4
tv147 = -1112						; size = 4
tv708 = -1108						; size = 4
tv666 = -1108						; size = 4
tv624 = -1108						; size = 4
tv582 = -1108						; size = 4
tv705 = -1104						; size = 4
tv663 = -1104						; size = 4
tv621 = -1104						; size = 4
tv579 = -1104						; size = 4
tv701 = -1100						; size = 4
tv659 = -1100						; size = 4
tv617 = -1100						; size = 4
tv575 = -1100						; size = 4
tv771 = -1096						; size = 4
tv757 = -1096						; size = 4
tv743 = -1096						; size = 4
tv729 = -1096						; size = 4
tv485 = -1089						; size = 1
tv346 = -1089						; size = 1
tv240 = -1089						; size = 1
tv133 = -1089						; size = 1
tv696 = -1088						; size = 4
tv654 = -1088						; size = 4
tv612 = -1088						; size = 4
tv570 = -1088						; size = 4
tv451 = -1084						; size = 4
tv312 = -1084						; size = 4
tv206 = -1084						; size = 4
tv67 = -1084						; size = 4
tv691 = -1080						; size = 4
tv649 = -1080						; size = 4
tv607 = -1080						; size = 4
tv565 = -1080						; size = 4
tv688 = -1076						; size = 4
tv646 = -1076						; size = 4
tv604 = -1076						; size = 4
tv562 = -1076						; size = 4
tv684 = -1072						; size = 4
tv642 = -1072						; size = 4
tv600 = -1072						; size = 4
tv558 = -1072						; size = 4
tv764 = -1068						; size = 4
tv750 = -1068						; size = 4
tv736 = -1068						; size = 4
tv722 = -1068						; size = 4
$T2 = -1060						; size = 4
$T3 = -1048						; size = 12
$T4 = -1028						; size = 12
$T5 = -1008						; size = 4
$T6 = -996						; size = 4
$T7 = -984						; size = 4
$T8 = -972						; size = 12
$T9 = -952						; size = 12
$T10 = -932						; size = 4
$T11 = -920						; size = 4
$T12 = -908						; size = 4
$T13 = -893						; size = 1
$T14 = -884						; size = 12
$T15 = -864						; size = 12
$T16 = -844						; size = 4
$T17 = -832						; size = 4
$T18 = -820						; size = 4
$T19 = -808						; size = 12
$T20 = -788						; size = 12
$T21 = -768						; size = 4
$T22 = -756						; size = 4
$T23 = -744						; size = 4
$T24 = -729						; size = 1
$T25 = -720						; size = 12
$T26 = -700						; size = 12
$T27 = -680						; size = 4
$T28 = -668						; size = 4
$T29 = -656						; size = 4
$T30 = -644						; size = 12
$T31 = -624						; size = 12
$T32 = -604						; size = 4
$T33 = -592						; size = 4
$T34 = -580						; size = 4
$T35 = -565						; size = 1
$T36 = -556						; size = 12
$T37 = -536						; size = 12
$T38 = -516						; size = 4
$T39 = -504						; size = 4
$T40 = -492						; size = 4
$T41 = -480						; size = 12
$T42 = -460						; size = 12
$T43 = -440						; size = 4
$T44 = -428						; size = 4
$T45 = -416						; size = 4
$T46 = -401						; size = 1
__$EHRec$ = -12						; size = 12
_deltaTimeS$ = 8					; size = 4
?FloatingMovement@@YAXM@Z PROC				; FloatingMovement, COMDAT

; 135  : void FloatingMovement(float deltaTimeS) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?FloatingMovement@@YAXM@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 1112				; 00000458H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-1124]
	mov	ecx, 278				; 00000116H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR $T2[ebp], 0

; 136  : 	player.velocityX = 0;

	xorps	xmm0, xmm0
	movsd	QWORD PTR ?player@@3UPlayer@@A+32, xmm0

; 137  : 	player.velocityY = 0;

	xorps	xmm0, xmm0
	movsd	QWORD PTR ?player@@3UPlayer@@A+40, xmm0

; 138  : 	if (std::find(keyList.begin(), keyList.end(), SDLK_LEFT) != keyList.end() && std::find(keyList.begin(), keyList.end(), SDLK_RIGHT) == keyList.end()) player.velocityX = -player.speed * deltaTimeS;

	mov	DWORD PTR $T45[ebp], 1073741904		; 40000050H
	lea	eax, DWORD PTR $T41[ebp]
	push	eax
	mov	ecx, OFFSET ?keyList@@3V?$vector@HV?$allocator@H@std@@@std@@A ; keyList
	call	?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ ; std::vector<int,std::allocator<int> >::end
	mov	DWORD PTR tv722[ebp], eax
	mov	ecx, DWORD PTR tv722[ebp]
	mov	DWORD PTR tv558[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR $T2[ebp]
	or	edx, 1
	mov	DWORD PTR $T2[ebp], edx
	mov	eax, DWORD PTR tv558[ebp]
	push	eax
	lea	ecx, DWORD PTR $T45[ebp]
	push	ecx
	sub	esp, 12					; 0000000cH
	mov	edx, esp
	mov	DWORD PTR $T44[ebp], esp
	push	edx
	mov	ecx, OFFSET ?keyList@@3V?$vector@HV?$allocator@H@std@@@std@@A ; keyList
	call	?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ ; std::vector<int,std::allocator<int> >::end
	mov	DWORD PTR tv562[ebp], eax
	sub	esp, 12					; 0000000cH
	mov	eax, esp
	mov	DWORD PTR $T43[ebp], esp
	push	eax
	mov	ecx, OFFSET ?keyList@@3V?$vector@HV?$allocator@H@std@@@std@@A ; keyList
	call	?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ ; std::vector<int,std::allocator<int> >::begin
	mov	DWORD PTR tv565[ebp], eax
	lea	ecx, DWORD PTR $T42[ebp]
	push	ecx
	call	??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@W4<unnamed-enum-SDLK_UNKNOWN>@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@V10@0ABW4<unnamed-enum-SDLK_UNKNOWN>@@@Z ; std::find<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >,enum <unnamed-enum-SDLK_UNKNOWN> >
	add	esp, 32					; 00000020H
	mov	DWORD PTR tv67[ebp], eax
	mov	edx, DWORD PTR tv67[ebp]
	mov	DWORD PTR tv570[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	mov	eax, DWORD PTR $T2[ebp]
	or	eax, 2
	mov	DWORD PTR $T2[ebp], eax
	mov	ecx, DWORD PTR tv570[ebp]
	call	??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int> > >::operator!=
	mov	BYTE PTR tv133[ebp], al
	movzx	ecx, BYTE PTR tv133[ebp]
	test	ecx, ecx
	je	$LN7@FloatingMo
	mov	DWORD PTR $T40[ebp], 1073741903		; 4000004fH
	lea	edx, DWORD PTR $T36[ebp]
	push	edx
	mov	ecx, OFFSET ?keyList@@3V?$vector@HV?$allocator@H@std@@@std@@A ; keyList
	call	?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ ; std::vector<int,std::allocator<int> >::end
	mov	DWORD PTR tv729[ebp], eax
	mov	eax, DWORD PTR tv729[ebp]
	mov	DWORD PTR tv575[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	mov	ecx, DWORD PTR $T2[ebp]
	or	ecx, 4
	mov	DWORD PTR $T2[ebp], ecx
	mov	edx, DWORD PTR tv575[ebp]
	push	edx
	lea	eax, DWORD PTR $T40[ebp]
	push	eax
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T39[ebp], esp
	push	ecx
	mov	ecx, OFFSET ?keyList@@3V?$vector@HV?$allocator@H@std@@@std@@A ; keyList
	call	?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ ; std::vector<int,std::allocator<int> >::end
	mov	DWORD PTR tv579[ebp], eax
	sub	esp, 12					; 0000000cH
	mov	edx, esp
	mov	DWORD PTR $T38[ebp], esp
	push	edx
	mov	ecx, OFFSET ?keyList@@3V?$vector@HV?$allocator@H@std@@@std@@A ; keyList
	call	?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ ; std::vector<int,std::allocator<int> >::begin
	mov	DWORD PTR tv582[ebp], eax
	lea	eax, DWORD PTR $T37[ebp]
	push	eax
	call	??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@W4<unnamed-enum-SDLK_UNKNOWN>@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@V10@0ABW4<unnamed-enum-SDLK_UNKNOWN>@@@Z ; std::find<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >,enum <unnamed-enum-SDLK_UNKNOWN> >
	add	esp, 32					; 00000020H
	mov	DWORD PTR tv147[ebp], eax
	mov	ecx, DWORD PTR tv147[ebp]
	mov	DWORD PTR tv587[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 3
	mov	edx, DWORD PTR $T2[ebp]
	or	edx, 8
	mov	DWORD PTR $T2[ebp], edx
	mov	ecx, DWORD PTR tv587[ebp]
	call	??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int> > >::operator==
	mov	BYTE PTR tv181[ebp], al
	movzx	eax, BYTE PTR tv181[ebp]
	test	eax, eax
	je	SHORT $LN7@FloatingMo
	mov	DWORD PTR tv196[ebp], 1
	jmp	SHORT $LN8@FloatingMo
$LN7@FloatingMo:
	mov	DWORD PTR tv196[ebp], 0
$LN8@FloatingMo:
	mov	cl, BYTE PTR tv196[ebp]
	mov	BYTE PTR $T46[ebp], cl
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	mov	edx, DWORD PTR $T2[ebp]
	and	edx, 8
	je	SHORT $LN27@FloatingMo
	and	DWORD PTR $T2[ebp], -9			; fffffff7H
	lea	ecx, DWORD PTR $T37[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ
$LN27@FloatingMo:
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	mov	eax, DWORD PTR $T2[ebp]
	and	eax, 4
	je	SHORT $LN28@FloatingMo
	and	DWORD PTR $T2[ebp], -5			; fffffffbH
	lea	ecx, DWORD PTR $T36[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ
$LN28@FloatingMo:
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	ecx, DWORD PTR $T2[ebp]
	and	ecx, 2
	je	SHORT $LN29@FloatingMo
	and	DWORD PTR $T2[ebp], -3			; fffffffdH
	lea	ecx, DWORD PTR $T42[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ
$LN29@FloatingMo:
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR $T2[ebp]
	and	edx, 1
	je	SHORT $LN30@FloatingMo
	and	DWORD PTR $T2[ebp], -2			; fffffffeH
	lea	ecx, DWORD PTR $T41[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ
$LN30@FloatingMo:
	movzx	eax, BYTE PTR $T46[ebp]
	test	eax, eax
	je	SHORT $LN2@FloatingMo
	movsd	xmm0, QWORD PTR ?player@@3UPlayer@@A+48
	xorps	xmm0, QWORD PTR __xmm@80000000000000008000000000000000
	cvtss2sd xmm1, DWORD PTR _deltaTimeS$[ebp]
	mulsd	xmm0, xmm1
	movsd	QWORD PTR ?player@@3UPlayer@@A+32, xmm0
$LN2@FloatingMo:

; 139  : 	if (std::find(keyList.begin(), keyList.end(), SDLK_RIGHT) != keyList.end() && std::find(keyList.begin(), keyList.end(), SDLK_LEFT) == keyList.end()) player.velocityX = player.speed * deltaTimeS;

	mov	DWORD PTR $T34[ebp], 1073741903		; 4000004fH
	lea	eax, DWORD PTR $T30[ebp]
	push	eax
	mov	ecx, OFFSET ?keyList@@3V?$vector@HV?$allocator@H@std@@@std@@A ; keyList
	call	?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ ; std::vector<int,std::allocator<int> >::end
	mov	DWORD PTR tv736[ebp], eax
	mov	ecx, DWORD PTR tv736[ebp]
	mov	DWORD PTR tv600[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 4
	mov	edx, DWORD PTR $T2[ebp]
	or	edx, 16					; 00000010H
	mov	DWORD PTR $T2[ebp], edx
	mov	eax, DWORD PTR tv600[ebp]
	push	eax
	lea	ecx, DWORD PTR $T34[ebp]
	push	ecx
	sub	esp, 12					; 0000000cH
	mov	edx, esp
	mov	DWORD PTR $T33[ebp], esp
	push	edx
	mov	ecx, OFFSET ?keyList@@3V?$vector@HV?$allocator@H@std@@@std@@A ; keyList
	call	?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ ; std::vector<int,std::allocator<int> >::end
	mov	DWORD PTR tv604[ebp], eax
	sub	esp, 12					; 0000000cH
	mov	eax, esp
	mov	DWORD PTR $T32[ebp], esp
	push	eax
	mov	ecx, OFFSET ?keyList@@3V?$vector@HV?$allocator@H@std@@@std@@A ; keyList
	call	?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ ; std::vector<int,std::allocator<int> >::begin
	mov	DWORD PTR tv607[ebp], eax
	lea	ecx, DWORD PTR $T31[ebp]
	push	ecx
	call	??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@W4<unnamed-enum-SDLK_UNKNOWN>@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@V10@0ABW4<unnamed-enum-SDLK_UNKNOWN>@@@Z ; std::find<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >,enum <unnamed-enum-SDLK_UNKNOWN> >
	add	esp, 32					; 00000020H
	mov	DWORD PTR tv206[ebp], eax
	mov	edx, DWORD PTR tv206[ebp]
	mov	DWORD PTR tv612[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], 5
	mov	eax, DWORD PTR $T2[ebp]
	or	eax, 32					; 00000020H
	mov	DWORD PTR $T2[ebp], eax
	mov	ecx, DWORD PTR tv612[ebp]
	call	??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int> > >::operator!=
	mov	BYTE PTR tv240[ebp], al
	movzx	ecx, BYTE PTR tv240[ebp]
	test	ecx, ecx
	je	$LN9@FloatingMo
	mov	DWORD PTR $T29[ebp], 1073741904		; 40000050H
	lea	edx, DWORD PTR $T25[ebp]
	push	edx
	mov	ecx, OFFSET ?keyList@@3V?$vector@HV?$allocator@H@std@@@std@@A ; keyList
	call	?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ ; std::vector<int,std::allocator<int> >::end
	mov	DWORD PTR tv743[ebp], eax
	mov	eax, DWORD PTR tv743[ebp]
	mov	DWORD PTR tv617[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 6
	mov	ecx, DWORD PTR $T2[ebp]
	or	ecx, 64					; 00000040H
	mov	DWORD PTR $T2[ebp], ecx
	mov	edx, DWORD PTR tv617[ebp]
	push	edx
	lea	eax, DWORD PTR $T29[ebp]
	push	eax
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T28[ebp], esp
	push	ecx
	mov	ecx, OFFSET ?keyList@@3V?$vector@HV?$allocator@H@std@@@std@@A ; keyList
	call	?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ ; std::vector<int,std::allocator<int> >::end
	mov	DWORD PTR tv621[ebp], eax
	sub	esp, 12					; 0000000cH
	mov	edx, esp
	mov	DWORD PTR $T27[ebp], esp
	push	edx
	mov	ecx, OFFSET ?keyList@@3V?$vector@HV?$allocator@H@std@@@std@@A ; keyList
	call	?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ ; std::vector<int,std::allocator<int> >::begin
	mov	DWORD PTR tv624[ebp], eax
	lea	eax, DWORD PTR $T26[ebp]
	push	eax
	call	??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@W4<unnamed-enum-SDLK_UNKNOWN>@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@V10@0ABW4<unnamed-enum-SDLK_UNKNOWN>@@@Z ; std::find<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >,enum <unnamed-enum-SDLK_UNKNOWN> >
	add	esp, 32					; 00000020H
	mov	DWORD PTR tv254[ebp], eax
	mov	ecx, DWORD PTR tv254[ebp]
	mov	DWORD PTR tv629[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 7
	mov	edx, DWORD PTR $T2[ebp]
	or	edx, 128				; 00000080H
	mov	DWORD PTR $T2[ebp], edx
	mov	ecx, DWORD PTR tv629[ebp]
	call	??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int> > >::operator==
	mov	BYTE PTR tv288[ebp], al
	movzx	eax, BYTE PTR tv288[ebp]
	test	eax, eax
	je	SHORT $LN9@FloatingMo
	mov	DWORD PTR tv303[ebp], 1
	jmp	SHORT $LN10@FloatingMo
$LN9@FloatingMo:
	mov	DWORD PTR tv303[ebp], 0
$LN10@FloatingMo:
	mov	cl, BYTE PTR tv303[ebp]
	mov	BYTE PTR $T35[ebp], cl
	mov	DWORD PTR __$EHRec$[ebp+8], 6
	mov	edx, DWORD PTR $T2[ebp]
	and	edx, 128				; 00000080H
	je	SHORT $LN43@FloatingMo
	and	DWORD PTR $T2[ebp], -129		; ffffff7fH
	lea	ecx, DWORD PTR $T26[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ
$LN43@FloatingMo:
	mov	DWORD PTR __$EHRec$[ebp+8], 5
	mov	eax, DWORD PTR $T2[ebp]
	and	eax, 64					; 00000040H
	je	SHORT $LN44@FloatingMo
	and	DWORD PTR $T2[ebp], -65			; ffffffbfH
	lea	ecx, DWORD PTR $T25[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ
$LN44@FloatingMo:
	mov	DWORD PTR __$EHRec$[ebp+8], 4
	mov	ecx, DWORD PTR $T2[ebp]
	and	ecx, 32					; 00000020H
	je	SHORT $LN45@FloatingMo
	and	DWORD PTR $T2[ebp], -33			; ffffffdfH
	lea	ecx, DWORD PTR $T31[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ
$LN45@FloatingMo:
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR $T2[ebp]
	and	edx, 16					; 00000010H
	je	SHORT $LN46@FloatingMo
	and	DWORD PTR $T2[ebp], -17			; ffffffefH
	lea	ecx, DWORD PTR $T30[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ
$LN46@FloatingMo:
	movzx	eax, BYTE PTR $T35[ebp]
	test	eax, eax
	je	SHORT $LN3@FloatingMo
	cvtss2sd xmm0, DWORD PTR _deltaTimeS$[ebp]
	mulsd	xmm0, QWORD PTR ?player@@3UPlayer@@A+48
	movsd	QWORD PTR ?player@@3UPlayer@@A+32, xmm0
$LN3@FloatingMo:

; 140  : 	if (std::find(keyList.begin(), keyList.end(), SDLK_UP) != keyList.end() && std::find(keyList.begin(), keyList.end(), SDLK_DOWN) == keyList.end()) player.velocityY = -player.speed * deltaTimeS;

	mov	DWORD PTR $T23[ebp], 1073741906		; 40000052H
	lea	eax, DWORD PTR $T19[ebp]
	push	eax
	mov	ecx, OFFSET ?keyList@@3V?$vector@HV?$allocator@H@std@@@std@@A ; keyList
	call	?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ ; std::vector<int,std::allocator<int> >::end
	mov	DWORD PTR tv750[ebp], eax
	mov	ecx, DWORD PTR tv750[ebp]
	mov	DWORD PTR tv642[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 8
	mov	edx, DWORD PTR $T2[ebp]
	or	edx, 256				; 00000100H
	mov	DWORD PTR $T2[ebp], edx
	mov	eax, DWORD PTR tv642[ebp]
	push	eax
	lea	ecx, DWORD PTR $T23[ebp]
	push	ecx
	sub	esp, 12					; 0000000cH
	mov	edx, esp
	mov	DWORD PTR $T22[ebp], esp
	push	edx
	mov	ecx, OFFSET ?keyList@@3V?$vector@HV?$allocator@H@std@@@std@@A ; keyList
	call	?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ ; std::vector<int,std::allocator<int> >::end
	mov	DWORD PTR tv646[ebp], eax
	sub	esp, 12					; 0000000cH
	mov	eax, esp
	mov	DWORD PTR $T21[ebp], esp
	push	eax
	mov	ecx, OFFSET ?keyList@@3V?$vector@HV?$allocator@H@std@@@std@@A ; keyList
	call	?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ ; std::vector<int,std::allocator<int> >::begin
	mov	DWORD PTR tv649[ebp], eax
	lea	ecx, DWORD PTR $T20[ebp]
	push	ecx
	call	??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@W4<unnamed-enum-SDLK_UNKNOWN>@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@V10@0ABW4<unnamed-enum-SDLK_UNKNOWN>@@@Z ; std::find<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >,enum <unnamed-enum-SDLK_UNKNOWN> >
	add	esp, 32					; 00000020H
	mov	DWORD PTR tv312[ebp], eax
	mov	edx, DWORD PTR tv312[ebp]
	mov	DWORD PTR tv654[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], 9
	mov	eax, DWORD PTR $T2[ebp]
	or	eax, 512				; 00000200H
	mov	DWORD PTR $T2[ebp], eax
	mov	ecx, DWORD PTR tv654[ebp]
	call	??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int> > >::operator!=
	mov	BYTE PTR tv346[ebp], al
	movzx	ecx, BYTE PTR tv346[ebp]
	test	ecx, ecx
	je	$LN11@FloatingMo
	mov	DWORD PTR $T18[ebp], 1073741905		; 40000051H
	lea	edx, DWORD PTR $T14[ebp]
	push	edx
	mov	ecx, OFFSET ?keyList@@3V?$vector@HV?$allocator@H@std@@@std@@A ; keyList
	call	?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ ; std::vector<int,std::allocator<int> >::end
	mov	DWORD PTR tv757[ebp], eax
	mov	eax, DWORD PTR tv757[ebp]
	mov	DWORD PTR tv659[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 10		; 0000000aH
	mov	ecx, DWORD PTR $T2[ebp]
	or	ecx, 1024				; 00000400H
	mov	DWORD PTR $T2[ebp], ecx
	mov	edx, DWORD PTR tv659[ebp]
	push	edx
	lea	eax, DWORD PTR $T18[ebp]
	push	eax
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T17[ebp], esp
	push	ecx
	mov	ecx, OFFSET ?keyList@@3V?$vector@HV?$allocator@H@std@@@std@@A ; keyList
	call	?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ ; std::vector<int,std::allocator<int> >::end
	mov	DWORD PTR tv663[ebp], eax
	sub	esp, 12					; 0000000cH
	mov	edx, esp
	mov	DWORD PTR $T16[ebp], esp
	push	edx
	mov	ecx, OFFSET ?keyList@@3V?$vector@HV?$allocator@H@std@@@std@@A ; keyList
	call	?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ ; std::vector<int,std::allocator<int> >::begin
	mov	DWORD PTR tv666[ebp], eax
	lea	eax, DWORD PTR $T15[ebp]
	push	eax
	call	??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@W4<unnamed-enum-SDLK_UNKNOWN>@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@V10@0ABW4<unnamed-enum-SDLK_UNKNOWN>@@@Z ; std::find<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >,enum <unnamed-enum-SDLK_UNKNOWN> >
	add	esp, 32					; 00000020H
	mov	DWORD PTR tv360[ebp], eax
	mov	ecx, DWORD PTR tv360[ebp]
	mov	DWORD PTR tv671[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 11		; 0000000bH
	mov	edx, DWORD PTR $T2[ebp]
	or	edx, 2048				; 00000800H
	mov	DWORD PTR $T2[ebp], edx
	mov	ecx, DWORD PTR tv671[ebp]
	call	??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int> > >::operator==
	mov	BYTE PTR tv426[ebp], al
	movzx	eax, BYTE PTR tv426[ebp]
	test	eax, eax
	je	SHORT $LN11@FloatingMo
	mov	DWORD PTR tv441[ebp], 1
	jmp	SHORT $LN12@FloatingMo
$LN11@FloatingMo:
	mov	DWORD PTR tv441[ebp], 0
$LN12@FloatingMo:
	mov	cl, BYTE PTR tv441[ebp]
	mov	BYTE PTR $T24[ebp], cl
	mov	DWORD PTR __$EHRec$[ebp+8], 10		; 0000000aH
	mov	edx, DWORD PTR $T2[ebp]
	and	edx, 2048				; 00000800H
	je	SHORT $LN59@FloatingMo
	and	DWORD PTR $T2[ebp], -2049		; fffff7ffH
	lea	ecx, DWORD PTR $T15[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ
$LN59@FloatingMo:
	mov	DWORD PTR __$EHRec$[ebp+8], 9
	mov	eax, DWORD PTR $T2[ebp]
	and	eax, 1024				; 00000400H
	je	SHORT $LN60@FloatingMo
	and	DWORD PTR $T2[ebp], -1025		; fffffbffH
	lea	ecx, DWORD PTR $T14[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ
$LN60@FloatingMo:
	mov	DWORD PTR __$EHRec$[ebp+8], 8
	mov	ecx, DWORD PTR $T2[ebp]
	and	ecx, 512				; 00000200H
	je	SHORT $LN61@FloatingMo
	and	DWORD PTR $T2[ebp], -513		; fffffdffH
	lea	ecx, DWORD PTR $T20[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ
$LN61@FloatingMo:
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR $T2[ebp]
	and	edx, 256				; 00000100H
	je	SHORT $LN62@FloatingMo
	and	DWORD PTR $T2[ebp], -257		; fffffeffH
	lea	ecx, DWORD PTR $T19[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ
$LN62@FloatingMo:
	movzx	eax, BYTE PTR $T24[ebp]
	test	eax, eax
	je	SHORT $LN4@FloatingMo
	movsd	xmm0, QWORD PTR ?player@@3UPlayer@@A+48
	xorps	xmm0, QWORD PTR __xmm@80000000000000008000000000000000
	cvtss2sd xmm1, DWORD PTR _deltaTimeS$[ebp]
	mulsd	xmm0, xmm1
	movsd	QWORD PTR ?player@@3UPlayer@@A+40, xmm0
$LN4@FloatingMo:

; 141  : 	if (std::find(keyList.begin(), keyList.end(), SDLK_DOWN) != keyList.end() && std::find(keyList.begin(), keyList.end(), SDLK_UP) == keyList.end()) player.velocityY = player.speed * deltaTimeS;

	mov	DWORD PTR $T12[ebp], 1073741905		; 40000051H
	lea	eax, DWORD PTR $T8[ebp]
	push	eax
	mov	ecx, OFFSET ?keyList@@3V?$vector@HV?$allocator@H@std@@@std@@A ; keyList
	call	?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ ; std::vector<int,std::allocator<int> >::end
	mov	DWORD PTR tv764[ebp], eax
	mov	ecx, DWORD PTR tv764[ebp]
	mov	DWORD PTR tv684[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 12		; 0000000cH
	mov	edx, DWORD PTR $T2[ebp]
	or	edx, 4096				; 00001000H
	mov	DWORD PTR $T2[ebp], edx
	mov	eax, DWORD PTR tv684[ebp]
	push	eax
	lea	ecx, DWORD PTR $T12[ebp]
	push	ecx
	sub	esp, 12					; 0000000cH
	mov	edx, esp
	mov	DWORD PTR $T11[ebp], esp
	push	edx
	mov	ecx, OFFSET ?keyList@@3V?$vector@HV?$allocator@H@std@@@std@@A ; keyList
	call	?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ ; std::vector<int,std::allocator<int> >::end
	mov	DWORD PTR tv688[ebp], eax
	sub	esp, 12					; 0000000cH
	mov	eax, esp
	mov	DWORD PTR $T10[ebp], esp
	push	eax
	mov	ecx, OFFSET ?keyList@@3V?$vector@HV?$allocator@H@std@@@std@@A ; keyList
	call	?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ ; std::vector<int,std::allocator<int> >::begin
	mov	DWORD PTR tv691[ebp], eax
	lea	ecx, DWORD PTR $T9[ebp]
	push	ecx
	call	??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@W4<unnamed-enum-SDLK_UNKNOWN>@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@V10@0ABW4<unnamed-enum-SDLK_UNKNOWN>@@@Z ; std::find<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >,enum <unnamed-enum-SDLK_UNKNOWN> >
	add	esp, 32					; 00000020H
	mov	DWORD PTR tv451[ebp], eax
	mov	edx, DWORD PTR tv451[ebp]
	mov	DWORD PTR tv696[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], 13		; 0000000dH
	mov	eax, DWORD PTR $T2[ebp]
	or	eax, 8192				; 00002000H
	mov	DWORD PTR $T2[ebp], eax
	mov	ecx, DWORD PTR tv696[ebp]
	call	??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int> > >::operator!=
	mov	BYTE PTR tv485[ebp], al
	movzx	ecx, BYTE PTR tv485[ebp]
	test	ecx, ecx
	je	$LN13@FloatingMo
	mov	DWORD PTR $T7[ebp], 1073741906		; 40000052H
	lea	edx, DWORD PTR $T3[ebp]
	push	edx
	mov	ecx, OFFSET ?keyList@@3V?$vector@HV?$allocator@H@std@@@std@@A ; keyList
	call	?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ ; std::vector<int,std::allocator<int> >::end
	mov	DWORD PTR tv771[ebp], eax
	mov	eax, DWORD PTR tv771[ebp]
	mov	DWORD PTR tv701[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 14		; 0000000eH
	mov	ecx, DWORD PTR $T2[ebp]
	or	ecx, 16384				; 00004000H
	mov	DWORD PTR $T2[ebp], ecx
	mov	edx, DWORD PTR tv701[ebp]
	push	edx
	lea	eax, DWORD PTR $T7[ebp]
	push	eax
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T6[ebp], esp
	push	ecx
	mov	ecx, OFFSET ?keyList@@3V?$vector@HV?$allocator@H@std@@@std@@A ; keyList
	call	?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ ; std::vector<int,std::allocator<int> >::end
	mov	DWORD PTR tv705[ebp], eax
	sub	esp, 12					; 0000000cH
	mov	edx, esp
	mov	DWORD PTR $T5[ebp], esp
	push	edx
	mov	ecx, OFFSET ?keyList@@3V?$vector@HV?$allocator@H@std@@@std@@A ; keyList
	call	?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ ; std::vector<int,std::allocator<int> >::begin
	mov	DWORD PTR tv708[ebp], eax
	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	call	??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@W4<unnamed-enum-SDLK_UNKNOWN>@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@V10@0ABW4<unnamed-enum-SDLK_UNKNOWN>@@@Z ; std::find<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >,enum <unnamed-enum-SDLK_UNKNOWN> >
	add	esp, 32					; 00000020H
	mov	DWORD PTR tv499[ebp], eax
	mov	ecx, DWORD PTR tv499[ebp]
	mov	DWORD PTR tv713[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 15		; 0000000fH
	mov	edx, DWORD PTR $T2[ebp]
	or	edx, 32768				; 00008000H
	mov	DWORD PTR $T2[ebp], edx
	mov	ecx, DWORD PTR tv713[ebp]
	call	??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int> > >::operator==
	mov	BYTE PTR tv533[ebp], al
	movzx	eax, BYTE PTR tv533[ebp]
	test	eax, eax
	je	SHORT $LN13@FloatingMo
	mov	DWORD PTR tv548[ebp], 1
	jmp	SHORT $LN14@FloatingMo
$LN13@FloatingMo:
	mov	DWORD PTR tv548[ebp], 0
$LN14@FloatingMo:
	mov	cl, BYTE PTR tv548[ebp]
	mov	BYTE PTR $T13[ebp], cl
	mov	DWORD PTR __$EHRec$[ebp+8], 14		; 0000000eH
	mov	edx, DWORD PTR $T2[ebp]
	and	edx, 32768				; 00008000H
	je	SHORT $LN75@FloatingMo
	and	DWORD PTR $T2[ebp], -32769		; ffff7fffH
	lea	ecx, DWORD PTR $T4[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ
$LN75@FloatingMo:
	mov	DWORD PTR __$EHRec$[ebp+8], 13		; 0000000dH
	mov	eax, DWORD PTR $T2[ebp]
	and	eax, 16384				; 00004000H
	je	SHORT $LN76@FloatingMo
	and	DWORD PTR $T2[ebp], -16385		; ffffbfffH
	lea	ecx, DWORD PTR $T3[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ
$LN76@FloatingMo:
	mov	DWORD PTR __$EHRec$[ebp+8], 12		; 0000000cH
	mov	ecx, DWORD PTR $T2[ebp]
	and	ecx, 8192				; 00002000H
	je	SHORT $LN77@FloatingMo
	and	DWORD PTR $T2[ebp], -8193		; ffffdfffH
	lea	ecx, DWORD PTR $T9[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ
$LN77@FloatingMo:
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR $T2[ebp]
	and	edx, 4096				; 00001000H
	je	SHORT $LN78@FloatingMo
	and	DWORD PTR $T2[ebp], -4097		; ffffefffH
	lea	ecx, DWORD PTR $T8[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ
$LN78@FloatingMo:
	movzx	eax, BYTE PTR $T13[ebp]
	test	eax, eax
	je	SHORT $LN5@FloatingMo
	cvtss2sd xmm0, DWORD PTR _deltaTimeS$[ebp]
	mulsd	xmm0, QWORD PTR ?player@@3UPlayer@@A+48
	movsd	QWORD PTR ?player@@3UPlayer@@A+40, xmm0
$LN5@FloatingMo:

; 142  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 1124				; 00000464H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?FloatingMovement@@YAXM@Z$0:
	mov	eax, DWORD PTR $T2[ebp]
	and	eax, 1
	je	$LN16@FloatingMo
	and	DWORD PTR $T2[ebp], -2			; fffffffeH
	lea	ecx, DWORD PTR $T41[ebp]
	jmp	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ
$LN16@FloatingMo:
	ret	0
__unwindfunclet$?FloatingMovement@@YAXM@Z$3:
	mov	eax, DWORD PTR $T2[ebp]
	and	eax, 2
	je	$LN20@FloatingMo
	and	DWORD PTR $T2[ebp], -3			; fffffffdH
	lea	ecx, DWORD PTR $T42[ebp]
	jmp	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ
$LN20@FloatingMo:
	ret	0
__unwindfunclet$?FloatingMovement@@YAXM@Z$4:
	mov	eax, DWORD PTR $T2[ebp]
	and	eax, 4
	je	$LN22@FloatingMo
	and	DWORD PTR $T2[ebp], -5			; fffffffbH
	lea	ecx, DWORD PTR $T36[ebp]
	jmp	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ
$LN22@FloatingMo:
	ret	0
__unwindfunclet$?FloatingMovement@@YAXM@Z$7:
	mov	eax, DWORD PTR $T2[ebp]
	and	eax, 8
	je	$LN26@FloatingMo
	and	DWORD PTR $T2[ebp], -9			; fffffff7H
	lea	ecx, DWORD PTR $T37[ebp]
	jmp	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ
$LN26@FloatingMo:
	ret	0
__unwindfunclet$?FloatingMovement@@YAXM@Z$8:
	mov	eax, DWORD PTR $T2[ebp]
	and	eax, 16					; 00000010H
	je	$LN32@FloatingMo
	and	DWORD PTR $T2[ebp], -17			; ffffffefH
	lea	ecx, DWORD PTR $T30[ebp]
	jmp	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ
$LN32@FloatingMo:
	ret	0
__unwindfunclet$?FloatingMovement@@YAXM@Z$11:
	mov	eax, DWORD PTR $T2[ebp]
	and	eax, 32					; 00000020H
	je	$LN36@FloatingMo
	and	DWORD PTR $T2[ebp], -33			; ffffffdfH
	lea	ecx, DWORD PTR $T31[ebp]
	jmp	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ
$LN36@FloatingMo:
	ret	0
__unwindfunclet$?FloatingMovement@@YAXM@Z$12:
	mov	eax, DWORD PTR $T2[ebp]
	and	eax, 64					; 00000040H
	je	$LN38@FloatingMo
	and	DWORD PTR $T2[ebp], -65			; ffffffbfH
	lea	ecx, DWORD PTR $T25[ebp]
	jmp	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ
$LN38@FloatingMo:
	ret	0
__unwindfunclet$?FloatingMovement@@YAXM@Z$15:
	mov	eax, DWORD PTR $T2[ebp]
	and	eax, 128				; 00000080H
	je	$LN42@FloatingMo
	and	DWORD PTR $T2[ebp], -129		; ffffff7fH
	lea	ecx, DWORD PTR $T26[ebp]
	jmp	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ
$LN42@FloatingMo:
	ret	0
__unwindfunclet$?FloatingMovement@@YAXM@Z$16:
	mov	eax, DWORD PTR $T2[ebp]
	and	eax, 256				; 00000100H
	je	$LN48@FloatingMo
	and	DWORD PTR $T2[ebp], -257		; fffffeffH
	lea	ecx, DWORD PTR $T19[ebp]
	jmp	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ
$LN48@FloatingMo:
	ret	0
__unwindfunclet$?FloatingMovement@@YAXM@Z$19:
	mov	eax, DWORD PTR $T2[ebp]
	and	eax, 512				; 00000200H
	je	$LN52@FloatingMo
	and	DWORD PTR $T2[ebp], -513		; fffffdffH
	lea	ecx, DWORD PTR $T20[ebp]
	jmp	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ
$LN52@FloatingMo:
	ret	0
__unwindfunclet$?FloatingMovement@@YAXM@Z$20:
	mov	eax, DWORD PTR $T2[ebp]
	and	eax, 1024				; 00000400H
	je	$LN54@FloatingMo
	and	DWORD PTR $T2[ebp], -1025		; fffffbffH
	lea	ecx, DWORD PTR $T14[ebp]
	jmp	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ
$LN54@FloatingMo:
	ret	0
__unwindfunclet$?FloatingMovement@@YAXM@Z$23:
	mov	eax, DWORD PTR $T2[ebp]
	and	eax, 2048				; 00000800H
	je	$LN58@FloatingMo
	and	DWORD PTR $T2[ebp], -2049		; fffff7ffH
	lea	ecx, DWORD PTR $T15[ebp]
	jmp	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ
$LN58@FloatingMo:
	ret	0
__unwindfunclet$?FloatingMovement@@YAXM@Z$24:
	mov	eax, DWORD PTR $T2[ebp]
	and	eax, 4096				; 00001000H
	je	$LN64@FloatingMo
	and	DWORD PTR $T2[ebp], -4097		; ffffefffH
	lea	ecx, DWORD PTR $T8[ebp]
	jmp	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ
$LN64@FloatingMo:
	ret	0
__unwindfunclet$?FloatingMovement@@YAXM@Z$27:
	mov	eax, DWORD PTR $T2[ebp]
	and	eax, 8192				; 00002000H
	je	$LN68@FloatingMo
	and	DWORD PTR $T2[ebp], -8193		; ffffdfffH
	lea	ecx, DWORD PTR $T9[ebp]
	jmp	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ
$LN68@FloatingMo:
	ret	0
__unwindfunclet$?FloatingMovement@@YAXM@Z$28:
	mov	eax, DWORD PTR $T2[ebp]
	and	eax, 16384				; 00004000H
	je	$LN70@FloatingMo
	and	DWORD PTR $T2[ebp], -16385		; ffffbfffH
	lea	ecx, DWORD PTR $T3[ebp]
	jmp	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ
$LN70@FloatingMo:
	ret	0
__unwindfunclet$?FloatingMovement@@YAXM@Z$31:
	mov	eax, DWORD PTR $T2[ebp]
	and	eax, 32768				; 00008000H
	je	$LN74@FloatingMo
	and	DWORD PTR $T2[ebp], -32769		; ffff7fffH
	lea	ecx, DWORD PTR $T4[ebp]
	jmp	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ
$LN74@FloatingMo:
	ret	0
__ehhandler$?FloatingMovement@@YAXM@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-1128]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?FloatingMovement@@YAXM@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?FloatingMovement@@YAXM@Z ENDP				; FloatingMovement
; Function compile flags: /Odtp /RTCsu /ZI
; File g:\projects\lotion\lotion\player.cpp
;	COMDAT ?HandleBasicCollision@@YAXUTile@@@Z
_TEXT	SEGMENT
tv223 = -344						; size = 8
tv205 = -344						; size = 8
tv197 = -344						; size = 8
tv184 = -344						; size = 8
tv176 = -344						; size = 8
tv247 = -336						; size = 8
tv245 = -336						; size = 8
tv243 = -336						; size = 8
tv241 = -336						; size = 8
tv239 = -336						; size = 8
tv217 = -328						; size = 8
tv201 = -328						; size = 8
tv193 = -328						; size = 8
tv180 = -328						; size = 8
tv172 = -328						; size = 8
$T1 = -316						; size = 16
$T2 = -292						; size = 16
$T3 = -268						; size = 16
$T4 = -244						; size = 16
_overlapY$ = -28					; size = 8
_overlapX$ = -12					; size = 8
_tile$ = 8						; size = 32
?HandleBasicCollision@@YAXUTile@@@Z PROC		; HandleBasicCollision, COMDAT

; 181  : void HandleBasicCollision(Tile tile) {

	push	ebp
	mov	ebp, esp
	sub	esp, 344				; 00000158H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-344]
	mov	ecx, 86					; 00000056H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 182  : 	double overlapX, overlapY;
; 183  : 	if (player.midpoint().x > tile.midpoint().x) overlapX = tile.right() - player.left();

	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	mov	ecx, OFFSET ?player@@3UPlayer@@A	; player
	call	?midpoint@Player@@QAE?AVVector2@@XZ	; Player::midpoint
	mov	esi, eax
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	lea	ecx, DWORD PTR _tile$[ebp]
	call	?midpoint@Tile@@QAE?AVVector2@@XZ	; Tile::midpoint
	movsd	xmm0, QWORD PTR [esi]
	comisd	xmm0, QWORD PTR [eax]
	jbe	SHORT $LN2@HandleBasi
	lea	ecx, DWORD PTR _tile$[ebp]
	call	?right@Tile@@QAENXZ			; Tile::right
	fstp	QWORD PTR tv172[ebp]
	movsd	xmm0, QWORD PTR tv172[ebp]
	mov	ecx, OFFSET ?player@@3UPlayer@@A	; player
	movsd	QWORD PTR tv239[ebp], xmm0
	call	?left@Player@@QAENXZ			; Player::left
	fstp	QWORD PTR tv176[ebp]
	movsd	xmm0, QWORD PTR tv239[ebp]
	subsd	xmm0, QWORD PTR tv176[ebp]
	movsd	QWORD PTR _overlapX$[ebp], xmm0
	jmp	SHORT $LN3@HandleBasi
$LN2@HandleBasi:

; 184  : 	else overlapX = -(player.right() - tile.left());

	mov	ecx, OFFSET ?player@@3UPlayer@@A	; player
	call	?right@Player@@QAENXZ			; Player::right
	fstp	QWORD PTR tv180[ebp]
	movsd	xmm0, QWORD PTR tv180[ebp]
	lea	ecx, DWORD PTR _tile$[ebp]
	movsd	QWORD PTR tv241[ebp], xmm0
	call	?left@Tile@@QAENXZ			; Tile::left
	fstp	QWORD PTR tv184[ebp]
	movsd	xmm0, QWORD PTR tv241[ebp]
	subsd	xmm0, QWORD PTR tv184[ebp]
	xorps	xmm0, QWORD PTR __xmm@80000000000000008000000000000000
	movsd	QWORD PTR _overlapX$[ebp], xmm0
$LN3@HandleBasi:

; 185  : 	if (player.midpoint().y > tile.midpoint().y) overlapY = tile.bottom() - player.top();

	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, OFFSET ?player@@3UPlayer@@A	; player
	call	?midpoint@Player@@QAE?AVVector2@@XZ	; Player::midpoint
	mov	esi, eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	lea	ecx, DWORD PTR _tile$[ebp]
	call	?midpoint@Tile@@QAE?AVVector2@@XZ	; Tile::midpoint
	movsd	xmm0, QWORD PTR [esi+8]
	comisd	xmm0, QWORD PTR [eax+8]
	jbe	SHORT $LN4@HandleBasi
	lea	ecx, DWORD PTR _tile$[ebp]
	call	?bottom@Tile@@QAENXZ			; Tile::bottom
	fstp	QWORD PTR tv193[ebp]
	movsd	xmm0, QWORD PTR tv193[ebp]
	mov	ecx, OFFSET ?player@@3UPlayer@@A	; player
	movsd	QWORD PTR tv243[ebp], xmm0
	call	?top@Player@@QAENXZ			; Player::top
	fstp	QWORD PTR tv197[ebp]
	movsd	xmm0, QWORD PTR tv243[ebp]
	subsd	xmm0, QWORD PTR tv197[ebp]
	movsd	QWORD PTR _overlapY$[ebp], xmm0
	jmp	SHORT $LN5@HandleBasi
$LN4@HandleBasi:

; 186  : 	else overlapY = -(player.bottom() - tile.top());

	mov	ecx, OFFSET ?player@@3UPlayer@@A	; player
	call	?bottom@Player@@QAENXZ			; Player::bottom
	fstp	QWORD PTR tv201[ebp]
	movsd	xmm0, QWORD PTR tv201[ebp]
	lea	ecx, DWORD PTR _tile$[ebp]
	movsd	QWORD PTR tv245[ebp], xmm0
	call	?top@Tile@@QAENXZ			; Tile::top
	fstp	QWORD PTR tv205[ebp]
	movsd	xmm0, QWORD PTR tv245[ebp]
	subsd	xmm0, QWORD PTR tv205[ebp]
	xorps	xmm0, QWORD PTR __xmm@80000000000000008000000000000000
	movsd	QWORD PTR _overlapY$[ebp], xmm0
$LN5@HandleBasi:

; 187  : 
; 188  : 	if (overlapX != 0 && overlapY != 0) {

	movsd	xmm0, QWORD PTR _overlapX$[ebp]
	ucomisd	xmm0, QWORD PTR __real@0000000000000000
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN8@HandleBasi
	movsd	xmm0, QWORD PTR _overlapY$[ebp]
	ucomisd	xmm0, QWORD PTR __real@0000000000000000
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN8@HandleBasi

; 189  : 		if (abs(overlapY) < abs(overlapX)) {

	sub	esp, 8
	movsd	xmm0, QWORD PTR _overlapY$[ebp]
	movsd	QWORD PTR [esp], xmm0
	call	?abs@@YANN@Z				; abs
	add	esp, 8
	fstp	QWORD PTR tv217[ebp]
	movsd	xmm0, QWORD PTR tv217[ebp]
	sub	esp, 8
	movsd	xmm1, QWORD PTR _overlapX$[ebp]
	movsd	QWORD PTR [esp], xmm1
	movsd	QWORD PTR tv247[ebp], xmm0
	call	?abs@@YANN@Z				; abs
	add	esp, 8
	fstp	QWORD PTR tv223[ebp]
	movsd	xmm0, QWORD PTR tv223[ebp]
	movsd	xmm1, QWORD PTR tv247[ebp]
	comisd	xmm0, xmm1
	jbe	$LN7@HandleBasi

; 190  : 			if (overlapY < 0) {

	xorps	xmm0, xmm0
	comisd	xmm0, QWORD PTR _overlapY$[ebp]
	jbe	SHORT $LN9@HandleBasi

; 191  : 				if (player.velocityY > 0) {

	movsd	xmm0, QWORD PTR ?player@@3UPlayer@@A+40
	comisd	xmm0, QWORD PTR __real@0000000000000000
	jbe	SHORT $LN11@HandleBasi

; 192  : 					player.onGround = true;

	mov	BYTE PTR ?player@@3UPlayer@@A+24, 1

; 193  : 					player.position.y += overlapY; player.velocityY = 0;

	movsd	xmm0, QWORD PTR ?player@@3UPlayer@@A+8
	addsd	xmm0, QWORD PTR _overlapY$[ebp]
	movsd	QWORD PTR ?player@@3UPlayer@@A+8, xmm0
	xorps	xmm0, xmm0
	movsd	QWORD PTR ?player@@3UPlayer@@A+40, xmm0
$LN11@HandleBasi:

; 194  : 				}
; 195  : 			}
; 196  : 			else {

	jmp	SHORT $LN13@HandleBasi
$LN9@HandleBasi:

; 197  : 				if (player.velocityY < 0) {

	xorps	xmm0, xmm0
	comisd	xmm0, QWORD PTR ?player@@3UPlayer@@A+40
	jbe	SHORT $LN13@HandleBasi

; 198  : 					if (CheckCollisionBottom(tile)) { player.position.y += overlapY; player.velocityY = 0; }

	sub	esp, 32					; 00000020H
	mov	ecx, 8
	lea	esi, DWORD PTR _tile$[ebp]
	mov	edi, esp
	rep movsd
	call	?CheckCollisionBottom@@YA_NUTile@@@Z	; CheckCollisionBottom
	add	esp, 32					; 00000020H
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN13@HandleBasi
	movsd	xmm0, QWORD PTR ?player@@3UPlayer@@A+8
	addsd	xmm0, QWORD PTR _overlapY$[ebp]
	movsd	QWORD PTR ?player@@3UPlayer@@A+8, xmm0
	xorps	xmm0, xmm0
	movsd	QWORD PTR ?player@@3UPlayer@@A+40, xmm0
$LN13@HandleBasi:

; 199  : 				}
; 200  : 			}
; 201  : 		}
; 202  : 		else {

	jmp	SHORT $LN8@HandleBasi
$LN7@HandleBasi:

; 203  : 			player.position.x += overlapX; player.velocityX = 0;

	movsd	xmm0, QWORD PTR ?player@@3UPlayer@@A
	addsd	xmm0, QWORD PTR _overlapX$[ebp]
	movsd	QWORD PTR ?player@@3UPlayer@@A, xmm0
	xorps	xmm0, xmm0
	movsd	QWORD PTR ?player@@3UPlayer@@A+32, xmm0
$LN8@HandleBasi:

; 204  : 		}
; 205  : 	}
; 206  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 344				; 00000158H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?HandleBasicCollision@@YAXUTile@@@Z ENDP		; HandleBasicCollision
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File g:\projects\lotion\lotion\player.cpp
;	COMDAT ?HandleCollision@@YAXUTile@@@Z
_TEXT	SEGMENT
tv185 = -433						; size = 1
tv287 = -432						; size = 8
tv269 = -432						; size = 8
tv261 = -432						; size = 8
tv248 = -432						; size = 8
tv240 = -432						; size = 8
tv217 = -432						; size = 4
tv151 = -428						; size = 4
tv333 = -424						; size = 8
tv331 = -424						; size = 8
tv329 = -424						; size = 8
tv327 = -424						; size = 8
tv325 = -424						; size = 8
tv215 = -424						; size = 4
tv212 = -420						; size = 4
tv281 = -416						; size = 8
tv265 = -416						; size = 8
tv257 = -416						; size = 8
tv244 = -416						; size = 8
tv236 = -416						; size = 8
tv208 = -416						; size = 4
tv218 = -412						; size = 4
$T2 = -404						; size = 12
$T3 = -384						; size = 12
$T4 = -364						; size = 4
$T5 = -352						; size = 4
$T6 = -337						; size = 1
$T7 = -328						; size = 16
$T8 = -304						; size = 16
$T9 = -280						; size = 16
$T10 = -256						; size = 16
_overlapY$ = -40					; size = 8
_overlapX$ = -24					; size = 8
__$EHRec$ = -12						; size = 12
_tile$ = 8						; size = 32
?HandleCollision@@YAXUTile@@@Z PROC			; HandleCollision, COMDAT

; 208  : void HandleCollision(Tile tile) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?HandleCollision@@YAXUTile@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 424				; 000001a8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-436]
	mov	ecx, 106				; 0000006aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 209  : 	double overlapX, overlapY;
; 210  : 	if (player.midpoint().x > tile.midpoint().x) overlapX = tile.right() - player.left();

	lea	eax, DWORD PTR $T10[ebp]
	push	eax
	mov	ecx, OFFSET ?player@@3UPlayer@@A	; player
	call	?midpoint@Player@@QAE?AVVector2@@XZ	; Player::midpoint
	mov	esi, eax
	lea	ecx, DWORD PTR $T9[ebp]
	push	ecx
	lea	ecx, DWORD PTR _tile$[ebp]
	call	?midpoint@Tile@@QAE?AVVector2@@XZ	; Tile::midpoint
	movsd	xmm0, QWORD PTR [esi]
	comisd	xmm0, QWORD PTR [eax]
	jbe	SHORT $LN2@HandleColl
	lea	ecx, DWORD PTR _tile$[ebp]
	call	?right@Tile@@QAENXZ			; Tile::right
	fstp	QWORD PTR tv236[ebp]
	movsd	xmm0, QWORD PTR tv236[ebp]
	mov	ecx, OFFSET ?player@@3UPlayer@@A	; player
	movsd	QWORD PTR tv325[ebp], xmm0
	call	?left@Player@@QAENXZ			; Player::left
	fstp	QWORD PTR tv240[ebp]
	movsd	xmm0, QWORD PTR tv325[ebp]
	subsd	xmm0, QWORD PTR tv240[ebp]
	movsd	QWORD PTR _overlapX$[ebp], xmm0
	jmp	SHORT $LN3@HandleColl
$LN2@HandleColl:

; 211  : 	else overlapX = -(player.right() - tile.left());

	mov	ecx, OFFSET ?player@@3UPlayer@@A	; player
	call	?right@Player@@QAENXZ			; Player::right
	fstp	QWORD PTR tv244[ebp]
	movsd	xmm0, QWORD PTR tv244[ebp]
	lea	ecx, DWORD PTR _tile$[ebp]
	movsd	QWORD PTR tv327[ebp], xmm0
	call	?left@Tile@@QAENXZ			; Tile::left
	fstp	QWORD PTR tv248[ebp]
	movsd	xmm0, QWORD PTR tv327[ebp]
	subsd	xmm0, QWORD PTR tv248[ebp]
	xorps	xmm0, QWORD PTR __xmm@80000000000000008000000000000000
	movsd	QWORD PTR _overlapX$[ebp], xmm0
$LN3@HandleColl:

; 212  : 	if (player.midpoint().y > tile.midpoint().y) overlapY = tile.bottom() - player.top();

	lea	eax, DWORD PTR $T8[ebp]
	push	eax
	mov	ecx, OFFSET ?player@@3UPlayer@@A	; player
	call	?midpoint@Player@@QAE?AVVector2@@XZ	; Player::midpoint
	mov	esi, eax
	lea	ecx, DWORD PTR $T7[ebp]
	push	ecx
	lea	ecx, DWORD PTR _tile$[ebp]
	call	?midpoint@Tile@@QAE?AVVector2@@XZ	; Tile::midpoint
	movsd	xmm0, QWORD PTR [esi+8]
	comisd	xmm0, QWORD PTR [eax+8]
	jbe	SHORT $LN4@HandleColl
	lea	ecx, DWORD PTR _tile$[ebp]
	call	?bottom@Tile@@QAENXZ			; Tile::bottom
	fstp	QWORD PTR tv257[ebp]
	movsd	xmm0, QWORD PTR tv257[ebp]
	mov	ecx, OFFSET ?player@@3UPlayer@@A	; player
	movsd	QWORD PTR tv329[ebp], xmm0
	call	?top@Player@@QAENXZ			; Player::top
	fstp	QWORD PTR tv261[ebp]
	movsd	xmm0, QWORD PTR tv329[ebp]
	subsd	xmm0, QWORD PTR tv261[ebp]
	movsd	QWORD PTR _overlapY$[ebp], xmm0
	jmp	SHORT $LN5@HandleColl
$LN4@HandleColl:

; 213  : 	else overlapY = -(player.bottom() - tile.top());

	mov	ecx, OFFSET ?player@@3UPlayer@@A	; player
	call	?bottom@Player@@QAENXZ			; Player::bottom
	fstp	QWORD PTR tv265[ebp]
	movsd	xmm0, QWORD PTR tv265[ebp]
	lea	ecx, DWORD PTR _tile$[ebp]
	movsd	QWORD PTR tv331[ebp], xmm0
	call	?top@Tile@@QAENXZ			; Tile::top
	fstp	QWORD PTR tv269[ebp]
	movsd	xmm0, QWORD PTR tv331[ebp]
	subsd	xmm0, QWORD PTR tv269[ebp]
	xorps	xmm0, QWORD PTR __xmm@80000000000000008000000000000000
	movsd	QWORD PTR _overlapY$[ebp], xmm0
$LN5@HandleColl:

; 214  : 
; 215  : 	if (overlapX != 0 && overlapY != 0) {

	movsd	xmm0, QWORD PTR _overlapX$[ebp]
	ucomisd	xmm0, QWORD PTR __real@0000000000000000
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN8@HandleColl
	movsd	xmm0, QWORD PTR _overlapY$[ebp]
	ucomisd	xmm0, QWORD PTR __real@0000000000000000
	lahf
	test	ah, 68					; 00000044H
	jnp	$LN8@HandleColl

; 216  : 		if (abs(overlapY) < abs(overlapX)) {

	sub	esp, 8
	movsd	xmm0, QWORD PTR _overlapY$[ebp]
	movsd	QWORD PTR [esp], xmm0
	call	?abs@@YANN@Z				; abs
	add	esp, 8
	fstp	QWORD PTR tv281[ebp]
	movsd	xmm0, QWORD PTR tv281[ebp]
	sub	esp, 8
	movsd	xmm1, QWORD PTR _overlapX$[ebp]
	movsd	QWORD PTR [esp], xmm1
	movsd	QWORD PTR tv333[ebp], xmm0
	call	?abs@@YANN@Z				; abs
	add	esp, 8
	fstp	QWORD PTR tv287[ebp]
	movsd	xmm0, QWORD PTR tv287[ebp]
	movsd	xmm1, QWORD PTR tv333[ebp]
	comisd	xmm0, xmm1
	jbe	$LN7@HandleColl

; 217  : 			if (overlapY < 0) {

	xorps	xmm0, xmm0
	comisd	xmm0, QWORD PTR _overlapY$[ebp]
	jbe	$LN9@HandleColl

; 218  : 				if (player.velocityY > 0) {

	movsd	xmm0, QWORD PTR ?player@@3UPlayer@@A+40
	comisd	xmm0, QWORD PTR __real@0000000000000000
	jbe	$LN12@HandleColl

; 219  : 					player.onGround = true;

	mov	BYTE PTR ?player@@3UPlayer@@A+24, 1

; 220  : 					player.position.y += overlapY; player.velocityY = 0;

	movsd	xmm0, QWORD PTR ?player@@3UPlayer@@A+8
	addsd	xmm0, QWORD PTR _overlapY$[ebp]
	movsd	QWORD PTR ?player@@3UPlayer@@A+8, xmm0
	xorps	xmm0, xmm0
	movsd	QWORD PTR ?player@@3UPlayer@@A+40, xmm0

; 221  : 					if (std::find(groundTileList.begin(), groundTileList.end(), tile) == groundTileList.end()) groundTileList.push_back(tile);

	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	mov	ecx, OFFSET ?groundTileList@@3V?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@A ; groundTileList
	call	?end@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@2@XZ ; std::vector<Tile,std::allocator<Tile> >::end
	mov	DWORD PTR tv218[ebp], eax
	mov	ecx, DWORD PTR tv218[ebp]
	mov	DWORD PTR tv208[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	mov	edx, DWORD PTR tv208[ebp]
	push	edx
	lea	eax, DWORD PTR _tile$[ebp]
	push	eax
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T5[ebp], esp
	push	ecx
	mov	ecx, OFFSET ?groundTileList@@3V?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@A ; groundTileList
	call	?end@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@2@XZ ; std::vector<Tile,std::allocator<Tile> >::end
	mov	DWORD PTR tv212[ebp], eax
	sub	esp, 12					; 0000000cH
	mov	edx, esp
	mov	DWORD PTR $T4[ebp], esp
	push	edx
	mov	ecx, OFFSET ?groundTileList@@3V?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@A ; groundTileList
	call	?begin@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@2@XZ ; std::vector<Tile,std::allocator<Tile> >::begin
	mov	DWORD PTR tv215[ebp], eax
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@UTile@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@0@V10@0ABUTile@@@Z ; std::find<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Tile> > >,Tile>
	add	esp, 32					; 00000020H
	mov	DWORD PTR tv151[ebp], eax
	mov	ecx, DWORD PTR tv151[ebp]
	mov	DWORD PTR tv217[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	mov	ecx, DWORD PTR tv217[ebp]
	call	??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Tile> > >::operator==
	mov	BYTE PTR tv185[ebp], al
	mov	dl, BYTE PTR tv185[ebp]
	mov	BYTE PTR $T6[ebp], dl
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR $T3[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T2[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAE@XZ
	movzx	eax, BYTE PTR $T6[ebp]
	test	eax, eax
	je	SHORT $LN12@HandleColl
	lea	eax, DWORD PTR _tile$[ebp]
	push	eax
	mov	ecx, OFFSET ?groundTileList@@3V?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@A ; groundTileList
	call	?push_back@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QAEXABUTile@@@Z ; std::vector<Tile,std::allocator<Tile> >::push_back
$LN12@HandleColl:

; 222  : 				}
; 223  : 			}
; 224  : 			else {

	jmp	SHORT $LN14@HandleColl
$LN9@HandleColl:

; 225  : 				if (player.velocityY < 0) {

	xorps	xmm0, xmm0
	comisd	xmm0, QWORD PTR ?player@@3UPlayer@@A+40
	jbe	SHORT $LN14@HandleColl

; 226  : 					if (CheckCollisionBottom(tile)) { player.position.y += overlapY; player.velocityY = 0; }

	sub	esp, 32					; 00000020H
	mov	ecx, 8
	lea	esi, DWORD PTR _tile$[ebp]
	mov	edi, esp
	rep movsd
	call	?CheckCollisionBottom@@YA_NUTile@@@Z	; CheckCollisionBottom
	add	esp, 32					; 00000020H
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN14@HandleColl
	movsd	xmm0, QWORD PTR ?player@@3UPlayer@@A+8
	addsd	xmm0, QWORD PTR _overlapY$[ebp]
	movsd	QWORD PTR ?player@@3UPlayer@@A+8, xmm0
	xorps	xmm0, xmm0
	movsd	QWORD PTR ?player@@3UPlayer@@A+40, xmm0
$LN14@HandleColl:

; 227  : 				}
; 228  : 			}
; 229  : 		}
; 230  : 		else {

	jmp	SHORT $LN8@HandleColl
$LN7@HandleColl:

; 231  : 			player.position.x += overlapX; player.velocityX = 0;

	movsd	xmm0, QWORD PTR ?player@@3UPlayer@@A
	addsd	xmm0, QWORD PTR _overlapX$[ebp]
	movsd	QWORD PTR ?player@@3UPlayer@@A, xmm0
	xorps	xmm0, xmm0
	movsd	QWORD PTR ?player@@3UPlayer@@A+32, xmm0
$LN8@HandleColl:

; 232  : 		}
; 233  : 	}
; 234  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 436				; 000001b4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?HandleCollision@@YAXUTile@@@Z$0:
	lea	ecx, DWORD PTR $T2[ebp]
	jmp	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$?HandleCollision@@YAXUTile@@@Z$3:
	lea	ecx, DWORD PTR $T3[ebp]
	jmp	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAE@XZ
__ehhandler$?HandleCollision@@YAXUTile@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-440]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?HandleCollision@@YAXUTile@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?HandleCollision@@YAXUTile@@@Z ENDP			; HandleCollision
; Function compile flags: /Odtp /RTCsu /ZI
; File g:\projects\lotion\lotion\player.cpp
;	COMDAT ?CheckCollision@@YA_NUTile@@@Z
_TEXT	SEGMENT
tv154 = -216						; size = 8
tv146 = -216						; size = 8
tv138 = -216						; size = 8
tv130 = -216						; size = 8
tv164 = -208						; size = 8
tv162 = -208						; size = 8
tv160 = -208						; size = 8
tv158 = -208						; size = 8
tv150 = -200						; size = 8
tv142 = -200						; size = 8
tv134 = -200						; size = 8
tv94 = -200						; size = 8
_tile$ = 8						; size = 32
?CheckCollision@@YA_NUTile@@@Z PROC			; CheckCollision, COMDAT

; 149  : bool CheckCollision(Tile tile) {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 150  : 	if (player.left() <= tile.right() &&
; 151  : 		player.right() >= tile.left() &&
; 152  : 		player.top() <= tile.bottom() &&

	mov	ecx, OFFSET ?player@@3UPlayer@@A	; player
	call	?left@Player@@QAENXZ			; Player::left
	fstp	QWORD PTR tv94[ebp]
	movsd	xmm0, QWORD PTR tv94[ebp]
	lea	ecx, DWORD PTR _tile$[ebp]
	movsd	QWORD PTR tv158[ebp], xmm0
	call	?right@Tile@@QAENXZ			; Tile::right
	fstp	QWORD PTR tv130[ebp]
	movsd	xmm0, QWORD PTR tv130[ebp]
	movsd	xmm1, QWORD PTR tv158[ebp]
	comisd	xmm0, xmm1
	jb	$LN2@CheckColli
	mov	ecx, OFFSET ?player@@3UPlayer@@A	; player
	call	?right@Player@@QAENXZ			; Player::right
	fstp	QWORD PTR tv134[ebp]
	movsd	xmm0, QWORD PTR tv134[ebp]
	lea	ecx, DWORD PTR _tile$[ebp]
	movsd	QWORD PTR tv160[ebp], xmm0
	call	?left@Tile@@QAENXZ			; Tile::left
	fstp	QWORD PTR tv138[ebp]
	movsd	xmm0, QWORD PTR tv160[ebp]
	comisd	xmm0, QWORD PTR tv138[ebp]
	jb	$LN2@CheckColli
	mov	ecx, OFFSET ?player@@3UPlayer@@A	; player
	call	?top@Player@@QAENXZ			; Player::top
	fstp	QWORD PTR tv142[ebp]
	movsd	xmm0, QWORD PTR tv142[ebp]
	lea	ecx, DWORD PTR _tile$[ebp]
	movsd	QWORD PTR tv162[ebp], xmm0
	call	?bottom@Tile@@QAENXZ			; Tile::bottom
	fstp	QWORD PTR tv146[ebp]
	movsd	xmm0, QWORD PTR tv146[ebp]
	movsd	xmm1, QWORD PTR tv162[ebp]
	comisd	xmm0, xmm1
	jb	SHORT $LN2@CheckColli
	mov	ecx, OFFSET ?player@@3UPlayer@@A	; player
	call	?bottom@Player@@QAENXZ			; Player::bottom
	fstp	QWORD PTR tv150[ebp]
	movsd	xmm0, QWORD PTR tv150[ebp]
	lea	ecx, DWORD PTR _tile$[ebp]
	movsd	QWORD PTR tv164[ebp], xmm0
	call	?top@Tile@@QAENXZ			; Tile::top
	fstp	QWORD PTR tv154[ebp]
	movsd	xmm0, QWORD PTR tv164[ebp]
	comisd	xmm0, QWORD PTR tv154[ebp]
	jb	SHORT $LN2@CheckColli

; 153  : 		player.bottom() >= tile.top()) {
; 154  : 		return true;

	mov	al, 1
	jmp	SHORT $LN1@CheckColli
$LN2@CheckColli:

; 155  : 	}
; 156  : 
; 157  : 	return false;

	xor	al, al
$LN1@CheckColli:

; 158  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?CheckCollision@@YA_NUTile@@@Z ENDP			; CheckCollision
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File g:\projects\lotion\lotion\player.cpp
;	COMDAT ?CheckCollisionRight@@YA_NUTile@@@Z
_TEXT	SEGMENT
tv157 = -216						; size = 8
tv149 = -216						; size = 8
tv141 = -216						; size = 8
tv133 = -216						; size = 8
tv167 = -208						; size = 8
tv165 = -208						; size = 8
tv163 = -208						; size = 8
tv161 = -208						; size = 8
tv153 = -200						; size = 8
tv145 = -200						; size = 8
tv137 = -200						; size = 8
tv129 = -200						; size = 8
_tile$ = 8						; size = 32
?CheckCollisionRight@@YA_NUTile@@@Z PROC		; CheckCollisionRight, COMDAT

; 171  : bool CheckCollisionRight(Tile tile) {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 172  : 	if (player.left() <= tile.right() && player.left() >= tile.right() - 5 && player.top() <= tile.bottom() - 3 && player.bottom() >= tile.top() + 3) return true;

	mov	ecx, OFFSET ?player@@3UPlayer@@A	; player
	call	?left@Player@@QAENXZ			; Player::left
	fstp	QWORD PTR tv129[ebp]
	movsd	xmm0, QWORD PTR tv129[ebp]
	lea	ecx, DWORD PTR _tile$[ebp]
	movsd	QWORD PTR tv161[ebp], xmm0
	call	?right@Tile@@QAENXZ			; Tile::right
	fstp	QWORD PTR tv133[ebp]
	movsd	xmm0, QWORD PTR tv133[ebp]
	movsd	xmm1, QWORD PTR tv161[ebp]
	comisd	xmm0, xmm1
	jb	$LN2@CheckColli
	mov	ecx, OFFSET ?player@@3UPlayer@@A	; player
	call	?left@Player@@QAENXZ			; Player::left
	fstp	QWORD PTR tv137[ebp]
	movsd	xmm0, QWORD PTR tv137[ebp]
	lea	ecx, DWORD PTR _tile$[ebp]
	movsd	QWORD PTR tv163[ebp], xmm0
	call	?right@Tile@@QAENXZ			; Tile::right
	fstp	QWORD PTR tv141[ebp]
	movsd	xmm0, QWORD PTR tv141[ebp]
	subsd	xmm0, QWORD PTR __real@4014000000000000
	movsd	xmm1, QWORD PTR tv163[ebp]
	comisd	xmm1, xmm0
	jb	$LN2@CheckColli
	mov	ecx, OFFSET ?player@@3UPlayer@@A	; player
	call	?top@Player@@QAENXZ			; Player::top
	fstp	QWORD PTR tv145[ebp]
	movsd	xmm0, QWORD PTR tv145[ebp]
	lea	ecx, DWORD PTR _tile$[ebp]
	movsd	QWORD PTR tv165[ebp], xmm0
	call	?bottom@Tile@@QAENXZ			; Tile::bottom
	fstp	QWORD PTR tv149[ebp]
	movsd	xmm0, QWORD PTR tv149[ebp]
	subsd	xmm0, QWORD PTR __real@4008000000000000
	movsd	xmm1, QWORD PTR tv165[ebp]
	comisd	xmm0, xmm1
	jb	SHORT $LN2@CheckColli
	mov	ecx, OFFSET ?player@@3UPlayer@@A	; player
	call	?bottom@Player@@QAENXZ			; Player::bottom
	fstp	QWORD PTR tv153[ebp]
	movsd	xmm0, QWORD PTR tv153[ebp]
	lea	ecx, DWORD PTR _tile$[ebp]
	movsd	QWORD PTR tv167[ebp], xmm0
	call	?top@Tile@@QAENXZ			; Tile::top
	fstp	QWORD PTR tv157[ebp]
	movsd	xmm0, QWORD PTR tv157[ebp]
	addsd	xmm0, QWORD PTR __real@4008000000000000
	movsd	xmm1, QWORD PTR tv167[ebp]
	comisd	xmm1, xmm0
	jb	SHORT $LN2@CheckColli
	mov	al, 1
	jmp	SHORT $LN1@CheckColli
$LN2@CheckColli:

; 173  : 	return false;

	xor	al, al
$LN1@CheckColli:

; 174  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?CheckCollisionRight@@YA_NUTile@@@Z ENDP		; CheckCollisionRight
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File g:\projects\lotion\lotion\player.cpp
;	COMDAT ?CheckCollisionLeft@@YA_NUTile@@@Z
_TEXT	SEGMENT
tv157 = -216						; size = 8
tv149 = -216						; size = 8
tv141 = -216						; size = 8
tv133 = -216						; size = 8
tv167 = -208						; size = 8
tv165 = -208						; size = 8
tv163 = -208						; size = 8
tv161 = -208						; size = 8
tv153 = -200						; size = 8
tv145 = -200						; size = 8
tv137 = -200						; size = 8
tv129 = -200						; size = 8
_tile$ = 8						; size = 32
?CheckCollisionLeft@@YA_NUTile@@@Z PROC			; CheckCollisionLeft, COMDAT

; 176  : bool CheckCollisionLeft(Tile tile) {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 177  : 	if (player.right() >= tile.left() && player.right() <= tile.left() + 5 && player.top() <= tile.bottom() - 3 && player.bottom() >= tile.top() + 3) return true;

	mov	ecx, OFFSET ?player@@3UPlayer@@A	; player
	call	?right@Player@@QAENXZ			; Player::right
	fstp	QWORD PTR tv129[ebp]
	movsd	xmm0, QWORD PTR tv129[ebp]
	lea	ecx, DWORD PTR _tile$[ebp]
	movsd	QWORD PTR tv161[ebp], xmm0
	call	?left@Tile@@QAENXZ			; Tile::left
	fstp	QWORD PTR tv133[ebp]
	movsd	xmm0, QWORD PTR tv161[ebp]
	comisd	xmm0, QWORD PTR tv133[ebp]
	jb	$LN2@CheckColli
	mov	ecx, OFFSET ?player@@3UPlayer@@A	; player
	call	?right@Player@@QAENXZ			; Player::right
	fstp	QWORD PTR tv137[ebp]
	movsd	xmm0, QWORD PTR tv137[ebp]
	lea	ecx, DWORD PTR _tile$[ebp]
	movsd	QWORD PTR tv163[ebp], xmm0
	call	?left@Tile@@QAENXZ			; Tile::left
	fstp	QWORD PTR tv141[ebp]
	movsd	xmm0, QWORD PTR tv141[ebp]
	addsd	xmm0, QWORD PTR __real@4014000000000000
	movsd	xmm1, QWORD PTR tv163[ebp]
	comisd	xmm0, xmm1
	jb	$LN2@CheckColli
	mov	ecx, OFFSET ?player@@3UPlayer@@A	; player
	call	?top@Player@@QAENXZ			; Player::top
	fstp	QWORD PTR tv145[ebp]
	movsd	xmm0, QWORD PTR tv145[ebp]
	lea	ecx, DWORD PTR _tile$[ebp]
	movsd	QWORD PTR tv165[ebp], xmm0
	call	?bottom@Tile@@QAENXZ			; Tile::bottom
	fstp	QWORD PTR tv149[ebp]
	movsd	xmm0, QWORD PTR tv149[ebp]
	subsd	xmm0, QWORD PTR __real@4008000000000000
	movsd	xmm1, QWORD PTR tv165[ebp]
	comisd	xmm0, xmm1
	jb	SHORT $LN2@CheckColli
	mov	ecx, OFFSET ?player@@3UPlayer@@A	; player
	call	?bottom@Player@@QAENXZ			; Player::bottom
	fstp	QWORD PTR tv153[ebp]
	movsd	xmm0, QWORD PTR tv153[ebp]
	lea	ecx, DWORD PTR _tile$[ebp]
	movsd	QWORD PTR tv167[ebp], xmm0
	call	?top@Tile@@QAENXZ			; Tile::top
	fstp	QWORD PTR tv157[ebp]
	movsd	xmm0, QWORD PTR tv157[ebp]
	addsd	xmm0, QWORD PTR __real@4008000000000000
	movsd	xmm1, QWORD PTR tv167[ebp]
	comisd	xmm1, xmm0
	jb	SHORT $LN2@CheckColli
	mov	al, 1
	jmp	SHORT $LN1@CheckColli
$LN2@CheckColli:

; 178  : 	return false;

	xor	al, al
$LN1@CheckColli:

; 179  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?CheckCollisionLeft@@YA_NUTile@@@Z ENDP			; CheckCollisionLeft
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File g:\projects\lotion\lotion\player.cpp
;	COMDAT ?CheckCollisionBottom@@YA_NUTile@@@Z
_TEXT	SEGMENT
tv157 = -216						; size = 8
tv149 = -216						; size = 8
tv141 = -216						; size = 8
tv133 = -216						; size = 8
tv167 = -208						; size = 8
tv165 = -208						; size = 8
tv163 = -208						; size = 8
tv161 = -208						; size = 8
tv153 = -200						; size = 8
tv145 = -200						; size = 8
tv137 = -200						; size = 8
tv129 = -200						; size = 8
_tile$ = 8						; size = 32
?CheckCollisionBottom@@YA_NUTile@@@Z PROC		; CheckCollisionBottom, COMDAT

; 161  : bool CheckCollisionBottom(Tile tile) {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 162  : 	if (player.top() <= tile.bottom() && player.top() >= tile.bottom() - 5 && player.left() <= tile.right() - 3 && player.right() >= tile.left() + 3) return true;

	mov	ecx, OFFSET ?player@@3UPlayer@@A	; player
	call	?top@Player@@QAENXZ			; Player::top
	fstp	QWORD PTR tv129[ebp]
	movsd	xmm0, QWORD PTR tv129[ebp]
	lea	ecx, DWORD PTR _tile$[ebp]
	movsd	QWORD PTR tv161[ebp], xmm0
	call	?bottom@Tile@@QAENXZ			; Tile::bottom
	fstp	QWORD PTR tv133[ebp]
	movsd	xmm0, QWORD PTR tv133[ebp]
	movsd	xmm1, QWORD PTR tv161[ebp]
	comisd	xmm0, xmm1
	jb	$LN2@CheckColli
	mov	ecx, OFFSET ?player@@3UPlayer@@A	; player
	call	?top@Player@@QAENXZ			; Player::top
	fstp	QWORD PTR tv137[ebp]
	movsd	xmm0, QWORD PTR tv137[ebp]
	lea	ecx, DWORD PTR _tile$[ebp]
	movsd	QWORD PTR tv163[ebp], xmm0
	call	?bottom@Tile@@QAENXZ			; Tile::bottom
	fstp	QWORD PTR tv141[ebp]
	movsd	xmm0, QWORD PTR tv141[ebp]
	subsd	xmm0, QWORD PTR __real@4014000000000000
	movsd	xmm1, QWORD PTR tv163[ebp]
	comisd	xmm1, xmm0
	jb	$LN2@CheckColli
	mov	ecx, OFFSET ?player@@3UPlayer@@A	; player
	call	?left@Player@@QAENXZ			; Player::left
	fstp	QWORD PTR tv145[ebp]
	movsd	xmm0, QWORD PTR tv145[ebp]
	lea	ecx, DWORD PTR _tile$[ebp]
	movsd	QWORD PTR tv165[ebp], xmm0
	call	?right@Tile@@QAENXZ			; Tile::right
	fstp	QWORD PTR tv149[ebp]
	movsd	xmm0, QWORD PTR tv149[ebp]
	subsd	xmm0, QWORD PTR __real@4008000000000000
	movsd	xmm1, QWORD PTR tv165[ebp]
	comisd	xmm0, xmm1
	jb	SHORT $LN2@CheckColli
	mov	ecx, OFFSET ?player@@3UPlayer@@A	; player
	call	?right@Player@@QAENXZ			; Player::right
	fstp	QWORD PTR tv153[ebp]
	movsd	xmm0, QWORD PTR tv153[ebp]
	lea	ecx, DWORD PTR _tile$[ebp]
	movsd	QWORD PTR tv167[ebp], xmm0
	call	?left@Tile@@QAENXZ			; Tile::left
	fstp	QWORD PTR tv157[ebp]
	movsd	xmm0, QWORD PTR tv157[ebp]
	addsd	xmm0, QWORD PTR __real@4008000000000000
	movsd	xmm1, QWORD PTR tv167[ebp]
	comisd	xmm1, xmm0
	jb	SHORT $LN2@CheckColli
	mov	al, 1
	jmp	SHORT $LN1@CheckColli
$LN2@CheckColli:

; 163  : 	return false;

	xor	al, al
$LN1@CheckColli:

; 164  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?CheckCollisionBottom@@YA_NUTile@@@Z ENDP		; CheckCollisionBottom
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File g:\projects\lotion\lotion\player.cpp
;	COMDAT ?CheckCollisionTop@@YA_NUTile@@@Z
_TEXT	SEGMENT
tv157 = -216						; size = 8
tv149 = -216						; size = 8
tv141 = -216						; size = 8
tv133 = -216						; size = 8
tv167 = -208						; size = 8
tv165 = -208						; size = 8
tv163 = -208						; size = 8
tv161 = -208						; size = 8
tv153 = -200						; size = 8
tv145 = -200						; size = 8
tv137 = -200						; size = 8
tv129 = -200						; size = 8
_tile$ = 8						; size = 32
?CheckCollisionTop@@YA_NUTile@@@Z PROC			; CheckCollisionTop, COMDAT

; 166  : bool CheckCollisionTop(Tile tile) {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 167  : 	if (player.bottom() >= tile.top() && player.bottom() <= tile.top() + 5 && player.left() <= tile.right() + 3 && player.right() >= tile.left() + 3) return true;

	mov	ecx, OFFSET ?player@@3UPlayer@@A	; player
	call	?bottom@Player@@QAENXZ			; Player::bottom
	fstp	QWORD PTR tv129[ebp]
	movsd	xmm0, QWORD PTR tv129[ebp]
	lea	ecx, DWORD PTR _tile$[ebp]
	movsd	QWORD PTR tv161[ebp], xmm0
	call	?top@Tile@@QAENXZ			; Tile::top
	fstp	QWORD PTR tv133[ebp]
	movsd	xmm0, QWORD PTR tv161[ebp]
	comisd	xmm0, QWORD PTR tv133[ebp]
	jb	$LN2@CheckColli
	mov	ecx, OFFSET ?player@@3UPlayer@@A	; player
	call	?bottom@Player@@QAENXZ			; Player::bottom
	fstp	QWORD PTR tv137[ebp]
	movsd	xmm0, QWORD PTR tv137[ebp]
	lea	ecx, DWORD PTR _tile$[ebp]
	movsd	QWORD PTR tv163[ebp], xmm0
	call	?top@Tile@@QAENXZ			; Tile::top
	fstp	QWORD PTR tv141[ebp]
	movsd	xmm0, QWORD PTR tv141[ebp]
	addsd	xmm0, QWORD PTR __real@4014000000000000
	movsd	xmm1, QWORD PTR tv163[ebp]
	comisd	xmm0, xmm1
	jb	$LN2@CheckColli
	mov	ecx, OFFSET ?player@@3UPlayer@@A	; player
	call	?left@Player@@QAENXZ			; Player::left
	fstp	QWORD PTR tv145[ebp]
	movsd	xmm0, QWORD PTR tv145[ebp]
	lea	ecx, DWORD PTR _tile$[ebp]
	movsd	QWORD PTR tv165[ebp], xmm0
	call	?right@Tile@@QAENXZ			; Tile::right
	fstp	QWORD PTR tv149[ebp]
	movsd	xmm0, QWORD PTR tv149[ebp]
	addsd	xmm0, QWORD PTR __real@4008000000000000
	movsd	xmm1, QWORD PTR tv165[ebp]
	comisd	xmm0, xmm1
	jb	SHORT $LN2@CheckColli
	mov	ecx, OFFSET ?player@@3UPlayer@@A	; player
	call	?right@Player@@QAENXZ			; Player::right
	fstp	QWORD PTR tv153[ebp]
	movsd	xmm0, QWORD PTR tv153[ebp]
	lea	ecx, DWORD PTR _tile$[ebp]
	movsd	QWORD PTR tv167[ebp], xmm0
	call	?left@Tile@@QAENXZ			; Tile::left
	fstp	QWORD PTR tv157[ebp]
	movsd	xmm0, QWORD PTR tv157[ebp]
	addsd	xmm0, QWORD PTR __real@4008000000000000
	movsd	xmm1, QWORD PTR tv167[ebp]
	comisd	xmm1, xmm0
	jb	SHORT $LN2@CheckColli
	mov	al, 1
	jmp	SHORT $LN1@CheckColli
$LN2@CheckColli:

; 168  : 	return false;

	xor	al, al
$LN1@CheckColli:

; 169  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?CheckCollisionTop@@YA_NUTile@@@Z ENDP			; CheckCollisionTop
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File g:\projects\lotion\lotion\player.cpp
;	COMDAT ?ResetPlayer@@YAXXZ
_TEXT	SEGMENT
$T1 = -212						; size = 16
?ResetPlayer@@YAXXZ PROC				; ResetPlayer, COMDAT

; 129  : void ResetPlayer() {

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 130  : 	player.velocityX = 0; 

	xorps	xmm0, xmm0
	movsd	QWORD PTR ?player@@3UPlayer@@A+32, xmm0

; 131  : 	player.velocityY = 0; 

	xorps	xmm0, xmm0
	movsd	QWORD PTR ?player@@3UPlayer@@A+40, xmm0

; 132  : 	player.position = Vector2(spawnTile.position.x, spawnTile.position.y);

	sub	esp, 8
	movsd	xmm0, QWORD PTR ?spawnTile@@3USpawnTile@@A+8
	movsd	QWORD PTR [esp], xmm0
	sub	esp, 8
	movsd	xmm0, QWORD PTR ?spawnTile@@3USpawnTile@@A
	movsd	QWORD PTR [esp], xmm0
	lea	ecx, DWORD PTR $T1[ebp]
	call	??0Vector2@@QAE@NN@Z			; Vector2::Vector2
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR ?player@@3UPlayer@@A, ecx
	mov	edx, DWORD PTR [eax+4]
	mov	DWORD PTR ?player@@3UPlayer@@A+4, edx
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR ?player@@3UPlayer@@A+8, ecx
	mov	edx, DWORD PTR [eax+12]
	mov	DWORD PTR ?player@@3UPlayer@@A+12, edx

; 133  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?ResetPlayer@@YAXXZ ENDP				; ResetPlayer
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File g:\projects\lotion\lotion\player.cpp
;	COMDAT ??__Eplayer@@YAXXZ
text$di	SEGMENT
??__Eplayer@@YAXXZ PROC					; `dynamic initializer for 'player'', COMDAT

; 3    : Player player;

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	ecx, OFFSET ?player@@3UPlayer@@A	; player
	call	??0Player@@QAE@XZ
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??__Eplayer@@YAXXZ ENDP					; `dynamic initializer for 'player''
text$di	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File g:\projects\lotion\lotion\player.cpp
;	COMDAT ?DrawPlayer@@YAXXZ
_TEXT	SEGMENT
_texture$ = -8						; size = 4
?DrawPlayer@@YAXXZ PROC					; DrawPlayer, COMDAT

; 236  : void DrawPlayer() {

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 237  : 	GLint texture = LoadTexture("../Content/player.bmp");

	push	OFFSET ??_C@_0BG@EIAGFEK@?4?4?1Content?1player?4bmp?$AA@
	call	?LoadTexture@@YAIPBD@Z			; LoadTexture
	add	esp, 4
	mov	DWORD PTR _texture$[ebp], eax

; 238  : 	DrawRect(texture, player.position, player.width, player.height);

	mov	eax, DWORD PTR ?player@@3UPlayer@@A+20
	push	eax
	mov	ecx, DWORD PTR ?player@@3UPlayer@@A+16
	push	ecx
	sub	esp, 16					; 00000010H
	mov	edx, esp
	mov	eax, DWORD PTR ?player@@3UPlayer@@A
	mov	DWORD PTR [edx], eax
	mov	ecx, DWORD PTR ?player@@3UPlayer@@A+4
	mov	DWORD PTR [edx+4], ecx
	mov	eax, DWORD PTR ?player@@3UPlayer@@A+8
	mov	DWORD PTR [edx+8], eax
	mov	ecx, DWORD PTR ?player@@3UPlayer@@A+12
	mov	DWORD PTR [edx+12], ecx
	mov	edx, DWORD PTR _texture$[ebp]
	push	edx
	call	?DrawRect@@YAXIVVector2@@HH@Z		; DrawRect
	add	esp, 28					; 0000001cH

; 239  : }

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?DrawPlayer@@YAXXZ ENDP					; DrawPlayer
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File g:\projects\lotion\lotion\player.cpp
;	COMDAT ?UpdatePlayer@@YAXH@Z
_TEXT	SEGMENT
tv611 = -2032						; size = 4
tv504 = -2032						; size = 4
tv596 = -2025						; size = 1
tv489 = -2025						; size = 1
tv1214 = -2024						; size = 4
tv1172 = -2024						; size = 4
tv562 = -2020						; size = 4
tv455 = -2020						; size = 4
tv1209 = -2016						; size = 4
tv1167 = -2016						; size = 4
tv1260 = -2012						; size = 4
tv1206 = -2012						; size = 4
tv1164 = -2012						; size = 4
tv1271 = -2008						; size = 4
tv1202 = -2008						; size = 4
tv1160 = -2008						; size = 4
tv1327 = -2004						; size = 4
tv1313 = -2004						; size = 4
tv1269 = -2004						; size = 4
tv1045 = -2000						; size = 4
tv793 = -1997						; size = 1
tv707 = -1997						; size = 1
tv548 = -1997						; size = 1
tv441 = -1997						; size = 1
tv359 = -1997						; size = 1
tv305 = -1997						; size = 1
tv255 = -1997						; size = 1
tv1267 = -1996						; size = 4
tv1246 = -1996						; size = 4
tv1235 = -1996						; size = 4
tv1197 = -1996						; size = 4
tv1155 = -1996						; size = 4
tv1138 = -1996						; size = 4
tv1127 = -1996						; size = 4
tv1116 = -1996						; size = 4
tv1264 = -1992						; size = 4
tv727 = -1992						; size = 4
tv673 = -1992						; size = 4
tv514 = -1992						; size = 4
tv375 = -1992						; size = 4
tv325 = -1992						; size = 4
tv271 = -1992						; size = 4
tv221 = -1992						; size = 4
tv1662 = -1988						; size = 8
tv1259 = -1988						; size = 4
tv1244 = -1988						; size = 4
tv1233 = -1988						; size = 4
tv1192 = -1988						; size = 4
tv1150 = -1988						; size = 4
tv1136 = -1988						; size = 4
tv1125 = -1988						; size = 4
tv1114 = -1988						; size = 4
tv1241 = -1984						; size = 4
tv1230 = -1984						; size = 4
tv1189 = -1984						; size = 4
tv1147 = -1984						; size = 4
tv1133 = -1984						; size = 4
tv1122 = -1984						; size = 4
tv1111 = -1984						; size = 4
tv985 = -1984						; size = 4
tv1757 = -1980						; size = 8
tv1257 = -1980						; size = 4
tv1237 = -1980						; size = 4
tv1226 = -1980						; size = 4
tv1185 = -1980						; size = 4
tv1143 = -1980						; size = 4
tv1129 = -1980						; size = 4
tv1118 = -1980						; size = 4
tv1107 = -1980						; size = 4
tv1105 = -1980						; size = 4
tv1102 = -1980						; size = 4
tv1099 = -1980						; size = 4
tv1096 = -1980						; size = 4
tv1320 = -1976						; size = 4
tv1274 = -1976						; size = 4
tv1273 = -1976						; size = 4
tv1104 = -1976						; size = 4
tv1101 = -1976						; size = 4
tv1098 = -1976						; size = 4
tv1095 = -1976						; size = 4
tv991 = -1976						; size = 4
tv626 = -1976						; size = 4
tv620 = -1976						; size = 4
tv320 = -1976						; size = 4
tv75 = -1976						; size = 4
tv69 = -1976						; size = 4
$T2 = -1968						; size = 4
$T3 = -1956						; size = 12
$T4 = -1936						; size = 12
$T5 = -1916						; size = 4
$T6 = -1904						; size = 4
$T7 = -1892						; size = 4
$T8 = -1880						; size = 12
$T9 = -1860						; size = 4
$T10 = -1848						; size = 12
$T11 = -1828						; size = 12
$T12 = -1808						; size = 4
$T13 = -1796						; size = 4
$T14 = -1784						; size = 4
$T15 = -1769						; size = 1
$T16 = -1760						; size = 12
$T17 = -1740						; size = 12
$T18 = -1720						; size = 4
$T19 = -1708						; size = 4
$T20 = -1696						; size = 4
$T21 = -1681						; size = 1
$T22 = -1672						; size = 12
$T23 = -1652						; size = 12
$T24 = -1632						; size = 4
$T25 = -1620						; size = 4
$T26 = -1608						; size = 4
$T27 = -1596						; size = 12
$T28 = -1576						; size = 12
$T29 = -1556						; size = 4
$T30 = -1544						; size = 4
$T31 = -1532						; size = 4
$T32 = -1517						; size = 1
$T33 = -1508						; size = 12
$T34 = -1488						; size = 12
$T35 = -1468						; size = 4
$T36 = -1456						; size = 4
$T37 = -1444						; size = 4
$T38 = -1432						; size = 12
$T39 = -1412						; size = 12
$T40 = -1392						; size = 4
$T41 = -1380						; size = 4
$T42 = -1368						; size = 4
$T43 = -1353						; size = 1
$T44 = -1344						; size = 12
$T45 = -1324						; size = 12
$T46 = -1304						; size = 4
$T47 = -1292						; size = 4
$T48 = -1280						; size = 4
$T49 = -1265						; size = 1
$T50 = -1256						; size = 12
$T51 = -1236						; size = 12
$T52 = -1216						; size = 4
$T53 = -1204						; size = 4
$T54 = -1192						; size = 4
$T55 = -1177						; size = 1
$T56 = -1168						; size = 12
$T57 = -1148						; size = 12
$T58 = -1128						; size = 4
$T59 = -1116						; size = 4
$T60 = -1104						; size = 4
$T61 = -1089						; size = 1
$T62 = -1080						; size = 4
$T63 = -1068						; size = 4
$T64 = -1056						; size = 4
$T65 = -1044						; size = 4
_tile$66 = -456						; size = 4
_<end>$L5$67 = -444					; size = 12
_<begin>$L5$68 = -424					; size = 12
_<range>$L5$69 = -404					; size = 4
_tile$70 = -392						; size = 4
_<end>$L4$71 = -380					; size = 12
_<begin>$L4$72 = -360					; size = 12
_<range>$L4$73 = -340					; size = 4
_tempGroundTileList$ = -328				; size = 16
_tile$74 = -304						; size = 4
_<end>$L3$75 = -292					; size = 12
_<begin>$L3$76 = -272					; size = 12
_<range>$L3$77 = -252					; size = 4
_movingTileCollision$ = -237				; size = 1
_tile$78 = -228						; size = 4
_<end>$L2$79 = -216					; size = 12
_<begin>$L2$80 = -196					; size = 12
_<range>$L2$81 = -176					; size = 4
_trampolineCollison$ = -161				; size = 1
_tile$82 = -152						; size = 4
_<end>$L1$83 = -140					; size = 12
_<begin>$L1$84 = -120					; size = 12
_<range>$L1$85 = -100					; size = 4
_tile$86 = -88						; size = 4
_<end>$L0$87 = -76					; size = 12
_<begin>$L0$88 = -56					; size = 12
_<range>$L0$89 = -36					; size = 4
_deltaTimeS$ = -24					; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_gameTime$ = 8						; size = 4
?UpdatePlayer@@YAXH@Z PROC				; UpdatePlayer, COMDAT

; 20   : void UpdatePlayer(int gameTime) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?UpdatePlayer@@YAXH@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 2020				; 000007e4H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-2032]
	mov	ecx, 505				; 000001f9H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR $T2[ebp], 0

; 21   : 	float deltaTimeS = (float)(gameTime) / 1000;

	cvtsi2ss xmm0, DWORD PTR _gameTime$[ebp]
	divss	xmm0, DWORD PTR __real@447a0000
	movss	DWORD PTR _deltaTimeS$[ebp], xmm0

; 22   : 
; 23   : 	for (auto &tile : pushTileMap) {

	mov	DWORD PTR _<range>$L0$89[ebp], OFFSET ?pushTileMap@@3V?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@A ; pushTileMap
	push	12					; 0000000cH
	lea	ecx, DWORD PTR _<begin>$L0$88[ebp]
	call	?__autoclassinit2@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@QAEXI@Z
	lea	eax, DWORD PTR _<begin>$L0$88[ebp]
	push	eax
	mov	ecx, DWORD PTR _<range>$L0$89[ebp]
	call	?begin@?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@2@XZ ; std::vector<PushTile,std::allocator<PushTile> >::begin
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	push	12					; 0000000cH
	lea	ecx, DWORD PTR _<end>$L0$87[ebp]
	call	?__autoclassinit2@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@QAEXI@Z
	lea	eax, DWORD PTR _<end>$L0$87[ebp]
	push	eax
	mov	ecx, DWORD PTR _<range>$L0$89[ebp]
	call	?end@?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@2@XZ ; std::vector<PushTile,std::allocator<PushTile> >::end
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	jmp	SHORT $LN4@UpdatePlay
$LN2@UpdatePlay:
	lea	ecx, DWORD PTR _<begin>$L0$88[ebp]
	call	??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<PushTile> > >::operator++
$LN4@UpdatePlay:
	lea	eax, DWORD PTR _<end>$L0$87[ebp]
	push	eax
	lea	ecx, DWORD PTR _<begin>$L0$88[ebp]
	call	??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PushTile> > >::operator!=
	movzx	ecx, al
	test	ecx, ecx
	je	$LN3@UpdatePlay
	lea	ecx, DWORD PTR _<begin>$L0$88[ebp]
	call	??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@QBEAAUPushTile@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<PushTile> > >::operator*
	mov	DWORD PTR _tile$86[ebp], eax

; 24   : 		if (CheckCollision(tile.tile) == true) {

	mov	esi, DWORD PTR _tile$86[ebp]
	sub	esp, 32					; 00000020H
	mov	ecx, 8
	mov	edi, esp
	rep movsd
	call	?CheckCollision@@YA_NUTile@@@Z		; CheckCollision
	add	esp, 32					; 00000020H
	movzx	eax, al
	cmp	eax, 1
	jne	$LN24@UpdatePlay

; 25   : 			//0=up 1=down 2=right 3=left
; 26   : 			if (tile.GetDirection(pushTileMap) == 0) { player.velocityY = tile.force * deltaTimeS; player.velocityX = 0; }

	sub	esp, 16					; 00000010H
	mov	ecx, esp
	mov	DWORD PTR $T65[ebp], esp
	push	OFFSET ?pushTileMap@@3V?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@A ; pushTileMap
	call	??0?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@QAE@ABV01@@Z ; std::vector<PushTile,std::allocator<PushTile> >::vector<PushTile,std::allocator<PushTile> >
	mov	DWORD PTR tv1095[ebp], eax
	mov	ecx, DWORD PTR _tile$86[ebp]
	call	?GetDirection@PushTile@@QAEHV?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@Z ; PushTile::GetDirection
	mov	DWORD PTR tv1096[ebp], eax
	cmp	DWORD PTR tv1096[ebp], 0
	jne	SHORT $LN21@UpdatePlay
	cvtss2sd xmm0, DWORD PTR _deltaTimeS$[ebp]
	mov	eax, DWORD PTR _tile$86[ebp]
	mulsd	xmm0, QWORD PTR [eax+32]
	movsd	QWORD PTR ?player@@3UPlayer@@A+40, xmm0
	xorps	xmm0, xmm0
	movsd	QWORD PTR ?player@@3UPlayer@@A+32, xmm0
$LN21@UpdatePlay:

; 27   : 			if (tile.GetDirection(pushTileMap) == 1) { player.velocityY = -tile.force * deltaTimeS; player.velocityX = 0; }

	sub	esp, 16					; 00000010H
	mov	ecx, esp
	mov	DWORD PTR $T64[ebp], esp
	push	OFFSET ?pushTileMap@@3V?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@A ; pushTileMap
	call	??0?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@QAE@ABV01@@Z ; std::vector<PushTile,std::allocator<PushTile> >::vector<PushTile,std::allocator<PushTile> >
	mov	DWORD PTR tv1098[ebp], eax
	mov	ecx, DWORD PTR _tile$86[ebp]
	call	?GetDirection@PushTile@@QAEHV?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@Z ; PushTile::GetDirection
	mov	DWORD PTR tv1099[ebp], eax
	cmp	DWORD PTR tv1099[ebp], 1
	jne	SHORT $LN22@UpdatePlay
	mov	eax, DWORD PTR _tile$86[ebp]
	movsd	xmm0, QWORD PTR [eax+32]
	xorps	xmm0, QWORD PTR __xmm@80000000000000008000000000000000
	cvtss2sd xmm1, DWORD PTR _deltaTimeS$[ebp]
	mulsd	xmm0, xmm1
	movsd	QWORD PTR ?player@@3UPlayer@@A+40, xmm0
	xorps	xmm0, xmm0
	movsd	QWORD PTR ?player@@3UPlayer@@A+32, xmm0
$LN22@UpdatePlay:

; 28   : 			if (tile.GetDirection(pushTileMap) == 2) { player.velocityX = tile.force * deltaTimeS; player.velocityY = 0; }

	sub	esp, 16					; 00000010H
	mov	ecx, esp
	mov	DWORD PTR $T63[ebp], esp
	push	OFFSET ?pushTileMap@@3V?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@A ; pushTileMap
	call	??0?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@QAE@ABV01@@Z ; std::vector<PushTile,std::allocator<PushTile> >::vector<PushTile,std::allocator<PushTile> >
	mov	DWORD PTR tv1101[ebp], eax
	mov	ecx, DWORD PTR _tile$86[ebp]
	call	?GetDirection@PushTile@@QAEHV?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@Z ; PushTile::GetDirection
	mov	DWORD PTR tv1102[ebp], eax
	cmp	DWORD PTR tv1102[ebp], 2
	jne	SHORT $LN23@UpdatePlay
	cvtss2sd xmm0, DWORD PTR _deltaTimeS$[ebp]
	mov	eax, DWORD PTR _tile$86[ebp]
	mulsd	xmm0, QWORD PTR [eax+32]
	movsd	QWORD PTR ?player@@3UPlayer@@A+32, xmm0
	xorps	xmm0, xmm0
	movsd	QWORD PTR ?player@@3UPlayer@@A+40, xmm0
$LN23@UpdatePlay:

; 29   : 			if (tile.GetDirection(pushTileMap) == 3) { player.velocityX = -tile.force * deltaTimeS; player.velocityY = 0; }

	sub	esp, 16					; 00000010H
	mov	ecx, esp
	mov	DWORD PTR $T62[ebp], esp
	push	OFFSET ?pushTileMap@@3V?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@A ; pushTileMap
	call	??0?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@QAE@ABV01@@Z ; std::vector<PushTile,std::allocator<PushTile> >::vector<PushTile,std::allocator<PushTile> >
	mov	DWORD PTR tv1104[ebp], eax
	mov	ecx, DWORD PTR _tile$86[ebp]
	call	?GetDirection@PushTile@@QAEHV?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@Z ; PushTile::GetDirection
	mov	DWORD PTR tv1105[ebp], eax
	cmp	DWORD PTR tv1105[ebp], 3
	jne	SHORT $LN24@UpdatePlay
	mov	eax, DWORD PTR _tile$86[ebp]
	movsd	xmm0, QWORD PTR [eax+32]
	xorps	xmm0, QWORD PTR __xmm@80000000000000008000000000000000
	cvtss2sd xmm1, DWORD PTR _deltaTimeS$[ebp]
	mulsd	xmm0, xmm1
	movsd	QWORD PTR ?player@@3UPlayer@@A+32, xmm0
	xorps	xmm0, xmm0
	movsd	QWORD PTR ?player@@3UPlayer@@A+40, xmm0
$LN24@UpdatePlay:

; 30   : 		}

	jmp	$LN2@UpdatePlay
$LN3@UpdatePlay:

; 31   : 	}

	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _<end>$L0$87[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _<begin>$L0$88[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@QAE@XZ

; 32   : 
; 33   : 	if (floatingMovement) FloatingMovement(deltaTimeS);

	movzx	eax, BYTE PTR ?floatingMovement@@3_NA	; floatingMovement
	test	eax, eax
	je	SHORT $LN25@UpdatePlay
	push	ecx
	movss	xmm0, DWORD PTR _deltaTimeS$[ebp]
	movss	DWORD PTR [esp], xmm0
	call	?FloatingMovement@@YAXM@Z		; FloatingMovement
	add	esp, 4
$LN25@UpdatePlay:

; 34   : 
; 35   : 	player.position.x += player.velocityX;

	movsd	xmm0, QWORD PTR ?player@@3UPlayer@@A
	addsd	xmm0, QWORD PTR ?player@@3UPlayer@@A+32
	movsd	QWORD PTR ?player@@3UPlayer@@A, xmm0

; 36   : 	player.position.y += player.velocityY;

	movsd	xmm0, QWORD PTR ?player@@3UPlayer@@A+8
	addsd	xmm0, QWORD PTR ?player@@3UPlayer@@A+40
	movsd	QWORD PTR ?player@@3UPlayer@@A+8, xmm0

; 37   : 	player.velocityX = 0;

	xorps	xmm0, xmm0
	movsd	QWORD PTR ?player@@3UPlayer@@A+32, xmm0

; 38   : 
; 39   : 	if (std::find(pressKeyList.begin(), pressKeyList.end(), SDLK_r) != pressKeyList.end()) { ResetPlayer(); }

	mov	DWORD PTR $T60[ebp], 114		; 00000072H
	lea	eax, DWORD PTR $T56[ebp]
	push	eax
	mov	ecx, OFFSET ?pressKeyList@@3V?$vector@HV?$allocator@H@std@@@std@@A ; pressKeyList
	call	?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ ; std::vector<int,std::allocator<int> >::end
	mov	DWORD PTR tv75[ebp], eax
	mov	ecx, DWORD PTR tv75[ebp]
	mov	DWORD PTR tv1107[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	mov	edx, DWORD PTR tv1107[ebp]
	push	edx
	lea	eax, DWORD PTR $T60[ebp]
	push	eax
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T59[ebp], esp
	push	ecx
	mov	ecx, OFFSET ?pressKeyList@@3V?$vector@HV?$allocator@H@std@@@std@@A ; pressKeyList
	call	?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ ; std::vector<int,std::allocator<int> >::end
	mov	DWORD PTR tv1111[ebp], eax
	sub	esp, 12					; 0000000cH
	mov	edx, esp
	mov	DWORD PTR $T58[ebp], esp
	push	edx
	mov	ecx, OFFSET ?pressKeyList@@3V?$vector@HV?$allocator@H@std@@@std@@A ; pressKeyList
	call	?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ ; std::vector<int,std::allocator<int> >::begin
	mov	DWORD PTR tv1114[ebp], eax
	lea	eax, DWORD PTR $T57[ebp]
	push	eax
	call	??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@W4<unnamed-enum-SDLK_UNKNOWN>@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@V10@0ABW4<unnamed-enum-SDLK_UNKNOWN>@@@Z ; std::find<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >,enum <unnamed-enum-SDLK_UNKNOWN> >
	add	esp, 32					; 00000020H
	mov	DWORD PTR tv221[ebp], eax
	mov	ecx, DWORD PTR tv221[ebp]
	mov	DWORD PTR tv1116[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	mov	ecx, DWORD PTR tv1116[ebp]
	call	??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int> > >::operator!=
	mov	BYTE PTR tv255[ebp], al
	mov	dl, BYTE PTR tv255[ebp]
	mov	BYTE PTR $T61[ebp], dl
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	lea	ecx, DWORD PTR $T57[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T56[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ
	movzx	eax, BYTE PTR $T61[ebp]
	test	eax, eax
	je	SHORT $LN26@UpdatePlay
	call	?ResetPlayer@@YAXXZ			; ResetPlayer
$LN26@UpdatePlay:

; 40   : 	if (std::find(pressKeyList.begin(), pressKeyList.end(), SDLK_f) != pressKeyList.end()) floatingMovement = !floatingMovement;

	mov	DWORD PTR $T54[ebp], 102		; 00000066H
	lea	eax, DWORD PTR $T50[ebp]
	push	eax
	mov	ecx, OFFSET ?pressKeyList@@3V?$vector@HV?$allocator@H@std@@@std@@A ; pressKeyList
	call	?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ ; std::vector<int,std::allocator<int> >::end
	mov	DWORD PTR tv69[ebp], eax
	mov	ecx, DWORD PTR tv69[ebp]
	mov	DWORD PTR tv1118[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 4
	mov	edx, DWORD PTR tv1118[ebp]
	push	edx
	lea	eax, DWORD PTR $T54[ebp]
	push	eax
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T53[ebp], esp
	push	ecx
	mov	ecx, OFFSET ?pressKeyList@@3V?$vector@HV?$allocator@H@std@@@std@@A ; pressKeyList
	call	?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ ; std::vector<int,std::allocator<int> >::end
	mov	DWORD PTR tv1122[ebp], eax
	sub	esp, 12					; 0000000cH
	mov	edx, esp
	mov	DWORD PTR $T52[ebp], esp
	push	edx
	mov	ecx, OFFSET ?pressKeyList@@3V?$vector@HV?$allocator@H@std@@@std@@A ; pressKeyList
	call	?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ ; std::vector<int,std::allocator<int> >::begin
	mov	DWORD PTR tv1125[ebp], eax
	lea	eax, DWORD PTR $T51[ebp]
	push	eax
	call	??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@W4<unnamed-enum-SDLK_UNKNOWN>@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@V10@0ABW4<unnamed-enum-SDLK_UNKNOWN>@@@Z ; std::find<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >,enum <unnamed-enum-SDLK_UNKNOWN> >
	add	esp, 32					; 00000020H
	mov	DWORD PTR tv271[ebp], eax
	mov	ecx, DWORD PTR tv271[ebp]
	mov	DWORD PTR tv1127[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 5
	mov	ecx, DWORD PTR tv1127[ebp]
	call	??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int> > >::operator!=
	mov	BYTE PTR tv305[ebp], al
	mov	dl, BYTE PTR tv305[ebp]
	mov	BYTE PTR $T55[ebp], dl
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	lea	ecx, DWORD PTR $T51[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T50[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ
	movzx	eax, BYTE PTR $T55[ebp]
	test	eax, eax
	je	SHORT $LN27@UpdatePlay
	movzx	eax, BYTE PTR ?floatingMovement@@3_NA	; floatingMovement
	test	eax, eax
	jne	SHORT $LN62@UpdatePlay
	mov	DWORD PTR tv320[ebp], 1
	jmp	SHORT $LN63@UpdatePlay
$LN62@UpdatePlay:
	mov	DWORD PTR tv320[ebp], 0
$LN63@UpdatePlay:
	mov	cl, BYTE PTR tv320[ebp]
	mov	BYTE PTR ?floatingMovement@@3_NA, cl	; floatingMovement
$LN27@UpdatePlay:

; 41   : 
; 42   : 	if (std::find(keyList.begin(), keyList.end(), SDLK_LCTRL) != keyList.end()) { player.speed = 65; }

	mov	DWORD PTR $T48[ebp], 1073742048		; 400000e0H
	lea	eax, DWORD PTR $T44[ebp]
	push	eax
	mov	ecx, OFFSET ?keyList@@3V?$vector@HV?$allocator@H@std@@@std@@A ; keyList
	call	?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ ; std::vector<int,std::allocator<int> >::end
	mov	DWORD PTR tv1273[ebp], eax
	mov	ecx, DWORD PTR tv1273[ebp]
	mov	DWORD PTR tv1129[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 6
	mov	edx, DWORD PTR tv1129[ebp]
	push	edx
	lea	eax, DWORD PTR $T48[ebp]
	push	eax
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T47[ebp], esp
	push	ecx
	mov	ecx, OFFSET ?keyList@@3V?$vector@HV?$allocator@H@std@@@std@@A ; keyList
	call	?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ ; std::vector<int,std::allocator<int> >::end
	mov	DWORD PTR tv1133[ebp], eax
	sub	esp, 12					; 0000000cH
	mov	edx, esp
	mov	DWORD PTR $T46[ebp], esp
	push	edx
	mov	ecx, OFFSET ?keyList@@3V?$vector@HV?$allocator@H@std@@@std@@A ; keyList
	call	?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ ; std::vector<int,std::allocator<int> >::begin
	mov	DWORD PTR tv1136[ebp], eax
	lea	eax, DWORD PTR $T45[ebp]
	push	eax
	call	??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@W4<unnamed-enum-SDLK_UNKNOWN>@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@V10@0ABW4<unnamed-enum-SDLK_UNKNOWN>@@@Z ; std::find<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >,enum <unnamed-enum-SDLK_UNKNOWN> >
	add	esp, 32					; 00000020H
	mov	DWORD PTR tv325[ebp], eax
	mov	ecx, DWORD PTR tv325[ebp]
	mov	DWORD PTR tv1138[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 7
	mov	ecx, DWORD PTR tv1138[ebp]
	call	??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int> > >::operator!=
	mov	BYTE PTR tv359[ebp], al
	mov	dl, BYTE PTR tv359[ebp]
	mov	BYTE PTR $T49[ebp], dl
	mov	BYTE PTR __$EHRec$[ebp+8], 6
	lea	ecx, DWORD PTR $T45[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T44[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ
	movzx	eax, BYTE PTR $T49[ebp]
	test	eax, eax
	je	SHORT $LN28@UpdatePlay
	movsd	xmm0, QWORD PTR __real@4050400000000000
	movsd	QWORD PTR ?player@@3UPlayer@@A+48, xmm0
	jmp	SHORT $LN29@UpdatePlay
$LN28@UpdatePlay:

; 43   : 	else { player.speed = 50; }

	movsd	xmm0, QWORD PTR __real@4049000000000000
	movsd	QWORD PTR ?player@@3UPlayer@@A+48, xmm0
$LN29@UpdatePlay:

; 44   : 	if (std::find(keyList.begin(), keyList.end(), SDLK_LEFT) != keyList.end() && std::find(keyList.begin(), keyList.end(), SDLK_RIGHT) == keyList.end()) player.velocityX = -player.speed * deltaTimeS;

	mov	DWORD PTR $T42[ebp], 1073741904		; 40000050H
	lea	eax, DWORD PTR $T38[ebp]
	push	eax
	mov	ecx, OFFSET ?keyList@@3V?$vector@HV?$allocator@H@std@@@std@@A ; keyList
	call	?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ ; std::vector<int,std::allocator<int> >::end
	mov	DWORD PTR tv1274[ebp], eax
	mov	ecx, DWORD PTR tv1274[ebp]
	mov	DWORD PTR tv1143[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 8
	mov	edx, DWORD PTR $T2[ebp]
	or	edx, 1
	mov	DWORD PTR $T2[ebp], edx
	mov	eax, DWORD PTR tv1143[ebp]
	push	eax
	lea	ecx, DWORD PTR $T42[ebp]
	push	ecx
	sub	esp, 12					; 0000000cH
	mov	edx, esp
	mov	DWORD PTR $T41[ebp], esp
	push	edx
	mov	ecx, OFFSET ?keyList@@3V?$vector@HV?$allocator@H@std@@@std@@A ; keyList
	call	?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ ; std::vector<int,std::allocator<int> >::end
	mov	DWORD PTR tv1147[ebp], eax
	sub	esp, 12					; 0000000cH
	mov	eax, esp
	mov	DWORD PTR $T40[ebp], esp
	push	eax
	mov	ecx, OFFSET ?keyList@@3V?$vector@HV?$allocator@H@std@@@std@@A ; keyList
	call	?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ ; std::vector<int,std::allocator<int> >::begin
	mov	DWORD PTR tv1150[ebp], eax
	lea	ecx, DWORD PTR $T39[ebp]
	push	ecx
	call	??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@W4<unnamed-enum-SDLK_UNKNOWN>@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@V10@0ABW4<unnamed-enum-SDLK_UNKNOWN>@@@Z ; std::find<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >,enum <unnamed-enum-SDLK_UNKNOWN> >
	add	esp, 32					; 00000020H
	mov	DWORD PTR tv375[ebp], eax
	mov	edx, DWORD PTR tv375[ebp]
	mov	DWORD PTR tv1155[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], 9
	mov	eax, DWORD PTR $T2[ebp]
	or	eax, 2
	mov	DWORD PTR $T2[ebp], eax
	mov	ecx, DWORD PTR tv1155[ebp]
	call	??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int> > >::operator!=
	mov	BYTE PTR tv441[ebp], al
	movzx	ecx, BYTE PTR tv441[ebp]
	test	ecx, ecx
	je	$LN64@UpdatePlay
	mov	DWORD PTR $T37[ebp], 1073741903		; 4000004fH
	lea	edx, DWORD PTR $T33[ebp]
	push	edx
	mov	ecx, OFFSET ?keyList@@3V?$vector@HV?$allocator@H@std@@@std@@A ; keyList
	call	?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ ; std::vector<int,std::allocator<int> >::end
	mov	DWORD PTR tv1313[ebp], eax
	mov	eax, DWORD PTR tv1313[ebp]
	mov	DWORD PTR tv1160[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 10		; 0000000aH
	mov	ecx, DWORD PTR $T2[ebp]
	or	ecx, 4
	mov	DWORD PTR $T2[ebp], ecx
	mov	edx, DWORD PTR tv1160[ebp]
	push	edx
	lea	eax, DWORD PTR $T37[ebp]
	push	eax
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T36[ebp], esp
	push	ecx
	mov	ecx, OFFSET ?keyList@@3V?$vector@HV?$allocator@H@std@@@std@@A ; keyList
	call	?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ ; std::vector<int,std::allocator<int> >::end
	mov	DWORD PTR tv1164[ebp], eax
	sub	esp, 12					; 0000000cH
	mov	edx, esp
	mov	DWORD PTR $T35[ebp], esp
	push	edx
	mov	ecx, OFFSET ?keyList@@3V?$vector@HV?$allocator@H@std@@@std@@A ; keyList
	call	?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ ; std::vector<int,std::allocator<int> >::begin
	mov	DWORD PTR tv1167[ebp], eax
	lea	eax, DWORD PTR $T34[ebp]
	push	eax
	call	??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@W4<unnamed-enum-SDLK_UNKNOWN>@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@V10@0ABW4<unnamed-enum-SDLK_UNKNOWN>@@@Z ; std::find<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >,enum <unnamed-enum-SDLK_UNKNOWN> >
	add	esp, 32					; 00000020H
	mov	DWORD PTR tv455[ebp], eax
	mov	ecx, DWORD PTR tv455[ebp]
	mov	DWORD PTR tv1172[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 11		; 0000000bH
	mov	edx, DWORD PTR $T2[ebp]
	or	edx, 8
	mov	DWORD PTR $T2[ebp], edx
	mov	ecx, DWORD PTR tv1172[ebp]
	call	??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int> > >::operator==
	mov	BYTE PTR tv489[ebp], al
	movzx	eax, BYTE PTR tv489[ebp]
	test	eax, eax
	je	SHORT $LN64@UpdatePlay
	mov	DWORD PTR tv504[ebp], 1
	jmp	SHORT $LN65@UpdatePlay
$LN64@UpdatePlay:
	mov	DWORD PTR tv504[ebp], 0
$LN65@UpdatePlay:
	mov	cl, BYTE PTR tv504[ebp]
	mov	BYTE PTR $T43[ebp], cl
	mov	DWORD PTR __$EHRec$[ebp+8], 10		; 0000000aH
	mov	edx, DWORD PTR $T2[ebp]
	and	edx, 8
	je	SHORT $LN98@UpdatePlay
	and	DWORD PTR $T2[ebp], -9			; fffffff7H
	lea	ecx, DWORD PTR $T34[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ
$LN98@UpdatePlay:
	mov	DWORD PTR __$EHRec$[ebp+8], 9
	mov	eax, DWORD PTR $T2[ebp]
	and	eax, 4
	je	SHORT $LN99@UpdatePlay
	and	DWORD PTR $T2[ebp], -5			; fffffffbH
	lea	ecx, DWORD PTR $T33[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ
$LN99@UpdatePlay:
	mov	DWORD PTR __$EHRec$[ebp+8], 8
	mov	ecx, DWORD PTR $T2[ebp]
	and	ecx, 2
	je	SHORT $LN100@UpdatePlay
	and	DWORD PTR $T2[ebp], -3			; fffffffdH
	lea	ecx, DWORD PTR $T39[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ
$LN100@UpdatePlay:
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR $T2[ebp]
	and	edx, 1
	je	SHORT $LN101@UpdatePlay
	and	DWORD PTR $T2[ebp], -2			; fffffffeH
	lea	ecx, DWORD PTR $T38[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ
$LN101@UpdatePlay:
	movzx	eax, BYTE PTR $T43[ebp]
	test	eax, eax
	je	SHORT $LN30@UpdatePlay
	movsd	xmm0, QWORD PTR ?player@@3UPlayer@@A+48
	xorps	xmm0, QWORD PTR __xmm@80000000000000008000000000000000
	cvtss2sd xmm1, DWORD PTR _deltaTimeS$[ebp]
	mulsd	xmm0, xmm1
	movsd	QWORD PTR ?player@@3UPlayer@@A+32, xmm0
$LN30@UpdatePlay:

; 45   : 	if (std::find(keyList.begin(), keyList.end(), SDLK_RIGHT) != keyList.end() && std::find(keyList.begin(), keyList.end(), SDLK_LEFT) == keyList.end()) player.velocityX = player.speed * deltaTimeS;

	mov	DWORD PTR $T31[ebp], 1073741903		; 4000004fH
	lea	eax, DWORD PTR $T27[ebp]
	push	eax
	mov	ecx, OFFSET ?keyList@@3V?$vector@HV?$allocator@H@std@@@std@@A ; keyList
	call	?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ ; std::vector<int,std::allocator<int> >::end
	mov	DWORD PTR tv1320[ebp], eax
	mov	ecx, DWORD PTR tv1320[ebp]
	mov	DWORD PTR tv1185[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 12		; 0000000cH
	mov	edx, DWORD PTR $T2[ebp]
	or	edx, 16					; 00000010H
	mov	DWORD PTR $T2[ebp], edx
	mov	eax, DWORD PTR tv1185[ebp]
	push	eax
	lea	ecx, DWORD PTR $T31[ebp]
	push	ecx
	sub	esp, 12					; 0000000cH
	mov	edx, esp
	mov	DWORD PTR $T30[ebp], esp
	push	edx
	mov	ecx, OFFSET ?keyList@@3V?$vector@HV?$allocator@H@std@@@std@@A ; keyList
	call	?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ ; std::vector<int,std::allocator<int> >::end
	mov	DWORD PTR tv1189[ebp], eax
	sub	esp, 12					; 0000000cH
	mov	eax, esp
	mov	DWORD PTR $T29[ebp], esp
	push	eax
	mov	ecx, OFFSET ?keyList@@3V?$vector@HV?$allocator@H@std@@@std@@A ; keyList
	call	?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ ; std::vector<int,std::allocator<int> >::begin
	mov	DWORD PTR tv1192[ebp], eax
	lea	ecx, DWORD PTR $T28[ebp]
	push	ecx
	call	??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@W4<unnamed-enum-SDLK_UNKNOWN>@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@V10@0ABW4<unnamed-enum-SDLK_UNKNOWN>@@@Z ; std::find<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >,enum <unnamed-enum-SDLK_UNKNOWN> >
	add	esp, 32					; 00000020H
	mov	DWORD PTR tv514[ebp], eax
	mov	edx, DWORD PTR tv514[ebp]
	mov	DWORD PTR tv1197[ebp], edx
	mov	DWORD PTR __$EHRec$[ebp+8], 13		; 0000000dH
	mov	eax, DWORD PTR $T2[ebp]
	or	eax, 32					; 00000020H
	mov	DWORD PTR $T2[ebp], eax
	mov	ecx, DWORD PTR tv1197[ebp]
	call	??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int> > >::operator!=
	mov	BYTE PTR tv548[ebp], al
	movzx	ecx, BYTE PTR tv548[ebp]
	test	ecx, ecx
	je	$LN66@UpdatePlay
	mov	DWORD PTR $T26[ebp], 1073741904		; 40000050H
	lea	edx, DWORD PTR $T22[ebp]
	push	edx
	mov	ecx, OFFSET ?keyList@@3V?$vector@HV?$allocator@H@std@@@std@@A ; keyList
	call	?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ ; std::vector<int,std::allocator<int> >::end
	mov	DWORD PTR tv1327[ebp], eax
	mov	eax, DWORD PTR tv1327[ebp]
	mov	DWORD PTR tv1202[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 14		; 0000000eH
	mov	ecx, DWORD PTR $T2[ebp]
	or	ecx, 64					; 00000040H
	mov	DWORD PTR $T2[ebp], ecx
	mov	edx, DWORD PTR tv1202[ebp]
	push	edx
	lea	eax, DWORD PTR $T26[ebp]
	push	eax
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T25[ebp], esp
	push	ecx
	mov	ecx, OFFSET ?keyList@@3V?$vector@HV?$allocator@H@std@@@std@@A ; keyList
	call	?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ ; std::vector<int,std::allocator<int> >::end
	mov	DWORD PTR tv1206[ebp], eax
	sub	esp, 12					; 0000000cH
	mov	edx, esp
	mov	DWORD PTR $T24[ebp], esp
	push	edx
	mov	ecx, OFFSET ?keyList@@3V?$vector@HV?$allocator@H@std@@@std@@A ; keyList
	call	?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ ; std::vector<int,std::allocator<int> >::begin
	mov	DWORD PTR tv1209[ebp], eax
	lea	eax, DWORD PTR $T23[ebp]
	push	eax
	call	??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@W4<unnamed-enum-SDLK_UNKNOWN>@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@V10@0ABW4<unnamed-enum-SDLK_UNKNOWN>@@@Z ; std::find<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >,enum <unnamed-enum-SDLK_UNKNOWN> >
	add	esp, 32					; 00000020H
	mov	DWORD PTR tv562[ebp], eax
	mov	ecx, DWORD PTR tv562[ebp]
	mov	DWORD PTR tv1214[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 15		; 0000000fH
	mov	edx, DWORD PTR $T2[ebp]
	or	edx, 128				; 00000080H
	mov	DWORD PTR $T2[ebp], edx
	mov	ecx, DWORD PTR tv1214[ebp]
	call	??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int> > >::operator==
	mov	BYTE PTR tv596[ebp], al
	movzx	eax, BYTE PTR tv596[ebp]
	test	eax, eax
	je	SHORT $LN66@UpdatePlay
	mov	DWORD PTR tv611[ebp], 1
	jmp	SHORT $LN67@UpdatePlay
$LN66@UpdatePlay:
	mov	DWORD PTR tv611[ebp], 0
$LN67@UpdatePlay:
	mov	cl, BYTE PTR tv611[ebp]
	mov	BYTE PTR $T32[ebp], cl
	mov	DWORD PTR __$EHRec$[ebp+8], 14		; 0000000eH
	mov	edx, DWORD PTR $T2[ebp]
	and	edx, 128				; 00000080H
	je	SHORT $LN114@UpdatePlay
	and	DWORD PTR $T2[ebp], -129		; ffffff7fH
	lea	ecx, DWORD PTR $T23[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ
$LN114@UpdatePlay:
	mov	DWORD PTR __$EHRec$[ebp+8], 13		; 0000000dH
	mov	eax, DWORD PTR $T2[ebp]
	and	eax, 64					; 00000040H
	je	SHORT $LN115@UpdatePlay
	and	DWORD PTR $T2[ebp], -65			; ffffffbfH
	lea	ecx, DWORD PTR $T22[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ
$LN115@UpdatePlay:
	mov	DWORD PTR __$EHRec$[ebp+8], 12		; 0000000cH
	mov	ecx, DWORD PTR $T2[ebp]
	and	ecx, 32					; 00000020H
	je	SHORT $LN116@UpdatePlay
	and	DWORD PTR $T2[ebp], -33			; ffffffdfH
	lea	ecx, DWORD PTR $T28[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ
$LN116@UpdatePlay:
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	edx, DWORD PTR $T2[ebp]
	and	edx, 16					; 00000010H
	je	SHORT $LN117@UpdatePlay
	and	DWORD PTR $T2[ebp], -17			; ffffffefH
	lea	ecx, DWORD PTR $T27[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ
$LN117@UpdatePlay:
	movzx	eax, BYTE PTR $T32[ebp]
	test	eax, eax
	je	SHORT $LN31@UpdatePlay
	cvtss2sd xmm0, DWORD PTR _deltaTimeS$[ebp]
	mulsd	xmm0, QWORD PTR ?player@@3UPlayer@@A+48
	movsd	QWORD PTR ?player@@3UPlayer@@A+32, xmm0
$LN31@UpdatePlay:

; 46   : 
; 47   : 	for (auto &tile : airTileMap) {

	mov	DWORD PTR _<range>$L1$85[ebp], OFFSET ?airTileMap@@3V?$vector@UAirTile@@V?$allocator@UAirTile@@@std@@@std@@A ; airTileMap
	push	12					; 0000000cH
	lea	ecx, DWORD PTR _<begin>$L1$84[ebp]
	call	?__autoclassinit2@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UAirTile@@@std@@@std@@@std@@QAEXI@Z
	lea	eax, DWORD PTR _<begin>$L1$84[ebp]
	push	eax
	mov	ecx, DWORD PTR _<range>$L1$85[ebp]
	call	?begin@?$vector@UAirTile@@V?$allocator@UAirTile@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UAirTile@@@std@@@std@@@2@XZ ; std::vector<AirTile,std::allocator<AirTile> >::begin
	mov	DWORD PTR __$EHRec$[ebp+8], 16		; 00000010H
	push	12					; 0000000cH
	lea	ecx, DWORD PTR _<end>$L1$83[ebp]
	call	?__autoclassinit2@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UAirTile@@@std@@@std@@@std@@QAEXI@Z
	lea	eax, DWORD PTR _<end>$L1$83[ebp]
	push	eax
	mov	ecx, DWORD PTR _<range>$L1$85[ebp]
	call	?end@?$vector@UAirTile@@V?$allocator@UAirTile@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UAirTile@@@std@@@std@@@2@XZ ; std::vector<AirTile,std::allocator<AirTile> >::end
	mov	BYTE PTR __$EHRec$[ebp+8], 17		; 00000011H
	jmp	SHORT $LN7@UpdatePlay
$LN5@UpdatePlay:
	lea	ecx, DWORD PTR _<begin>$L1$84[ebp]
	call	??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UAirTile@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<AirTile> > >::operator++
$LN7@UpdatePlay:
	lea	eax, DWORD PTR _<end>$L1$83[ebp]
	push	eax
	lea	ecx, DWORD PTR _<begin>$L1$84[ebp]
	call	??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UAirTile@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<AirTile> > >::operator!=
	movzx	ecx, al
	test	ecx, ecx
	je	$LN6@UpdatePlay
	lea	ecx, DWORD PTR _<begin>$L1$84[ebp]
	call	??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UAirTile@@@std@@@std@@@std@@QBEAAUAirTile@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<AirTile> > >::operator*
	mov	DWORD PTR _tile$82[ebp], eax

; 48   : 		if (CheckCollision(tile.tile) == true) {

	mov	esi, DWORD PTR _tile$82[ebp]
	sub	esp, 32					; 00000020H
	mov	ecx, 8
	mov	edi, esp
	rep movsd
	call	?CheckCollision@@YA_NUTile@@@Z		; CheckCollision
	add	esp, 32					; 00000020H
	movzx	eax, al
	cmp	eax, 1
	jne	$LN36@UpdatePlay

; 49   : 			if (tile.direction == 1) { player.position.y -= tile.speed; }

	mov	eax, DWORD PTR _tile$82[ebp]
	cmp	DWORD PTR [eax+32], 1
	jne	SHORT $LN33@UpdatePlay
	mov	eax, DWORD PTR _tile$82[ebp]
	movsd	xmm0, QWORD PTR ?player@@3UPlayer@@A+8
	subsd	xmm0, QWORD PTR [eax+40]
	movsd	QWORD PTR ?player@@3UPlayer@@A+8, xmm0
$LN33@UpdatePlay:

; 50   : 			if (tile.direction == 2) { player.position.y += tile.speed; }

	mov	eax, DWORD PTR _tile$82[ebp]
	cmp	DWORD PTR [eax+32], 2
	jne	SHORT $LN34@UpdatePlay
	mov	eax, DWORD PTR _tile$82[ebp]
	movsd	xmm0, QWORD PTR ?player@@3UPlayer@@A+8
	addsd	xmm0, QWORD PTR [eax+40]
	movsd	QWORD PTR ?player@@3UPlayer@@A+8, xmm0
$LN34@UpdatePlay:

; 51   : 			if (tile.direction == 3) { player.position.x -= tile.speed; }

	mov	eax, DWORD PTR _tile$82[ebp]
	cmp	DWORD PTR [eax+32], 3
	jne	SHORT $LN35@UpdatePlay
	mov	eax, DWORD PTR _tile$82[ebp]
	movsd	xmm0, QWORD PTR ?player@@3UPlayer@@A
	subsd	xmm0, QWORD PTR [eax+40]
	movsd	QWORD PTR ?player@@3UPlayer@@A, xmm0
$LN35@UpdatePlay:

; 52   : 			if (tile.direction == 4) { player.position.x += tile.speed; }

	mov	eax, DWORD PTR _tile$82[ebp]
	cmp	DWORD PTR [eax+32], 4
	jne	SHORT $LN36@UpdatePlay
	mov	eax, DWORD PTR _tile$82[ebp]
	movsd	xmm0, QWORD PTR ?player@@3UPlayer@@A
	addsd	xmm0, QWORD PTR [eax+40]
	movsd	QWORD PTR ?player@@3UPlayer@@A, xmm0
$LN36@UpdatePlay:

; 53   : 		}

	jmp	$LN5@UpdatePlay
$LN6@UpdatePlay:

; 54   : 	}

	mov	BYTE PTR __$EHRec$[ebp+8], 16		; 00000010H
	lea	ecx, DWORD PTR _<end>$L1$83[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UAirTile@@@std@@@std@@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _<begin>$L1$84[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UAirTile@@@std@@@std@@@std@@QAE@XZ

; 55   : 
; 56   : 	if (player.onGround == true) {

	movzx	eax, BYTE PTR ?player@@3UPlayer@@A+24
	cmp	eax, 1
	jne	$LN37@UpdatePlay

; 57   : 		if (jumpPress == false) {

	movzx	eax, BYTE PTR ?jumpPress@@3_NA		; jumpPress
	test	eax, eax
	jne	$LN40@UpdatePlay

; 58   : 			if (std::find(keyList.begin(), keyList.end(), SDLK_SPACE) != keyList.end()) {

	mov	DWORD PTR $T20[ebp], 32			; 00000020H
	lea	eax, DWORD PTR $T16[ebp]
	push	eax
	mov	ecx, OFFSET ?keyList@@3V?$vector@HV?$allocator@H@std@@@std@@A ; keyList
	call	?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ ; std::vector<int,std::allocator<int> >::end
	mov	DWORD PTR tv626[ebp], eax
	mov	ecx, DWORD PTR tv626[ebp]
	mov	DWORD PTR tv1226[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 18		; 00000012H
	mov	edx, DWORD PTR tv1226[ebp]
	push	edx
	lea	eax, DWORD PTR $T20[ebp]
	push	eax
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T19[ebp], esp
	push	ecx
	mov	ecx, OFFSET ?keyList@@3V?$vector@HV?$allocator@H@std@@@std@@A ; keyList
	call	?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ ; std::vector<int,std::allocator<int> >::end
	mov	DWORD PTR tv1230[ebp], eax
	sub	esp, 12					; 0000000cH
	mov	edx, esp
	mov	DWORD PTR $T18[ebp], esp
	push	edx
	mov	ecx, OFFSET ?keyList@@3V?$vector@HV?$allocator@H@std@@@std@@A ; keyList
	call	?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ ; std::vector<int,std::allocator<int> >::begin
	mov	DWORD PTR tv1233[ebp], eax
	lea	eax, DWORD PTR $T17[ebp]
	push	eax
	call	??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@W4<unnamed-enum-SDLK_UNKNOWN>@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@V10@0ABW4<unnamed-enum-SDLK_UNKNOWN>@@@Z ; std::find<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >,enum <unnamed-enum-SDLK_UNKNOWN> >
	add	esp, 32					; 00000020H
	mov	DWORD PTR tv673[ebp], eax
	mov	ecx, DWORD PTR tv673[ebp]
	mov	DWORD PTR tv1235[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 19		; 00000013H
	mov	ecx, DWORD PTR tv1235[ebp]
	call	??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int> > >::operator!=
	mov	BYTE PTR tv707[ebp], al
	mov	dl, BYTE PTR tv707[ebp]
	mov	BYTE PTR $T21[ebp], dl
	mov	BYTE PTR __$EHRec$[ebp+8], 18		; 00000012H
	lea	ecx, DWORD PTR $T17[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T16[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ
	movzx	eax, BYTE PTR $T21[ebp]
	test	eax, eax
	je	SHORT $LN40@UpdatePlay

; 59   : 				player.velocityY = -player.jumpSpeed; player.onGround = false; jumpPress = true;

	movsd	xmm0, QWORD PTR ?player@@3UPlayer@@A+56
	xorps	xmm0, QWORD PTR __xmm@80000000000000008000000000000000
	movsd	QWORD PTR ?player@@3UPlayer@@A+40, xmm0
	mov	BYTE PTR ?player@@3UPlayer@@A+24, 0
	mov	BYTE PTR ?jumpPress@@3_NA, 1		; jumpPress
$LN40@UpdatePlay:

; 60   : 			}
; 61   : 		}
; 62   : 	}
; 63   : 	else {

	jmp	SHORT $LN38@UpdatePlay
$LN37@UpdatePlay:

; 64   : 		player.velocityY += 9.8 * deltaTimeS;

	cvtss2sd xmm0, DWORD PTR _deltaTimeS$[ebp]
	mulsd	xmm0, QWORD PTR __real@402399999999999a
	addsd	xmm0, QWORD PTR ?player@@3UPlayer@@A+40
	movsd	QWORD PTR ?player@@3UPlayer@@A+40, xmm0
$LN38@UpdatePlay:

; 65   : 	}
; 66   : 
; 67   : 	if (std::find(keyList.begin(), keyList.end(), SDLK_SPACE) == keyList.end()) {

	mov	DWORD PTR $T14[ebp], 32			; 00000020H
	lea	eax, DWORD PTR $T10[ebp]
	push	eax
	mov	ecx, OFFSET ?keyList@@3V?$vector@HV?$allocator@H@std@@@std@@A ; keyList
	call	?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ ; std::vector<int,std::allocator<int> >::end
	mov	DWORD PTR tv620[ebp], eax
	mov	ecx, DWORD PTR tv620[ebp]
	mov	DWORD PTR tv1237[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 20		; 00000014H
	mov	edx, DWORD PTR tv1237[ebp]
	push	edx
	lea	eax, DWORD PTR $T14[ebp]
	push	eax
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T13[ebp], esp
	push	ecx
	mov	ecx, OFFSET ?keyList@@3V?$vector@HV?$allocator@H@std@@@std@@A ; keyList
	call	?end@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ ; std::vector<int,std::allocator<int> >::end
	mov	DWORD PTR tv1241[ebp], eax
	sub	esp, 12					; 0000000cH
	mov	edx, esp
	mov	DWORD PTR $T12[ebp], esp
	push	edx
	mov	ecx, OFFSET ?keyList@@3V?$vector@HV?$allocator@H@std@@@std@@A ; keyList
	call	?begin@?$vector@HV?$allocator@H@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@2@XZ ; std::vector<int,std::allocator<int> >::begin
	mov	DWORD PTR tv1244[ebp], eax
	lea	eax, DWORD PTR $T11[ebp]
	push	eax
	call	??$find@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@W4<unnamed-enum-SDLK_UNKNOWN>@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@0@V10@0ABW4<unnamed-enum-SDLK_UNKNOWN>@@@Z ; std::find<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<int> > >,enum <unnamed-enum-SDLK_UNKNOWN> >
	add	esp, 32					; 00000020H
	mov	DWORD PTR tv727[ebp], eax
	mov	ecx, DWORD PTR tv727[ebp]
	mov	DWORD PTR tv1246[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 21		; 00000015H
	mov	ecx, DWORD PTR tv1246[ebp]
	call	??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<int> > >::operator==
	mov	BYTE PTR tv793[ebp], al
	mov	dl, BYTE PTR tv793[ebp]
	mov	BYTE PTR $T15[ebp], dl
	mov	BYTE PTR __$EHRec$[ebp+8], 20		; 00000014H
	lea	ecx, DWORD PTR $T11[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR $T10[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ
	movzx	eax, BYTE PTR $T15[ebp]
	test	eax, eax
	je	SHORT $LN43@UpdatePlay

; 68   : 		if (player.velocityY < 0 && player.onGround == false) player.velocityY += 9.8 * deltaTimeS;

	xorps	xmm0, xmm0
	comisd	xmm0, QWORD PTR ?player@@3UPlayer@@A+40
	jbe	SHORT $LN42@UpdatePlay
	movzx	eax, BYTE PTR ?player@@3UPlayer@@A+24
	test	eax, eax
	jne	SHORT $LN42@UpdatePlay
	cvtss2sd xmm0, DWORD PTR _deltaTimeS$[ebp]
	mulsd	xmm0, QWORD PTR __real@402399999999999a
	addsd	xmm0, QWORD PTR ?player@@3UPlayer@@A+40
	movsd	QWORD PTR ?player@@3UPlayer@@A+40, xmm0
$LN42@UpdatePlay:

; 69   : 		if (player.onGround == true) jumpPress = false;

	movzx	eax, BYTE PTR ?player@@3UPlayer@@A+24
	cmp	eax, 1
	jne	SHORT $LN43@UpdatePlay
	mov	BYTE PTR ?jumpPress@@3_NA, 0		; jumpPress
$LN43@UpdatePlay:

; 70   : 	}
; 71   : 
; 72   : 	bool trampolineCollison = false;

	mov	BYTE PTR _trampolineCollison$[ebp], 0

; 73   : 	for (auto &tile : tileMap) {

	mov	DWORD PTR _<range>$L2$81[ebp], OFFSET ?tileMap@@3V?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@A ; tileMap
	push	12					; 0000000cH
	lea	ecx, DWORD PTR _<begin>$L2$80[ebp]
	call	?__autoclassinit2@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAEXI@Z
	lea	eax, DWORD PTR _<begin>$L2$80[ebp]
	push	eax
	mov	ecx, DWORD PTR _<range>$L2$81[ebp]
	call	?begin@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@2@XZ ; std::vector<Tile,std::allocator<Tile> >::begin
	mov	DWORD PTR __$EHRec$[ebp+8], 22		; 00000016H
	push	12					; 0000000cH
	lea	ecx, DWORD PTR _<end>$L2$79[ebp]
	call	?__autoclassinit2@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAEXI@Z
	lea	eax, DWORD PTR _<end>$L2$79[ebp]
	push	eax
	mov	ecx, DWORD PTR _<range>$L2$81[ebp]
	call	?end@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@2@XZ ; std::vector<Tile,std::allocator<Tile> >::end
	mov	BYTE PTR __$EHRec$[ebp+8], 23		; 00000017H
	jmp	SHORT $LN10@UpdatePlay
$LN8@UpdatePlay:
	lea	ecx, DWORD PTR _<begin>$L2$80[ebp]
	call	??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Tile> > >::operator++
$LN10@UpdatePlay:
	lea	eax, DWORD PTR _<end>$L2$79[ebp]
	push	eax
	lea	ecx, DWORD PTR _<begin>$L2$80[ebp]
	call	??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Tile> > >::operator!=
	movzx	ecx, al
	test	ecx, ecx
	je	$LN9@UpdatePlay
	lea	ecx, DWORD PTR _<begin>$L2$80[ebp]
	call	??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QBEAAUTile@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Tile> > >::operator*
	mov	DWORD PTR _tile$78[ebp], eax

; 74   : 		if (CheckCollision(tile) == true) {

	mov	esi, DWORD PTR _tile$78[ebp]
	sub	esp, 32					; 00000020H
	mov	ecx, 8
	mov	edi, esp
	rep movsd
	call	?CheckCollision@@YA_NUTile@@@Z		; CheckCollision
	add	esp, 32					; 00000020H
	movzx	eax, al
	cmp	eax, 1
	jne	$LN51@UpdatePlay

; 75   : 			if (tile.tileID == 1) { HandleCollision(tile); }

	mov	eax, DWORD PTR _tile$78[ebp]
	cmp	DWORD PTR [eax+24], 1
	jne	SHORT $LN45@UpdatePlay
	mov	esi, DWORD PTR _tile$78[ebp]
	sub	esp, 32					; 00000020H
	mov	ecx, 8
	mov	edi, esp
	rep movsd
	call	?HandleCollision@@YAXUTile@@@Z		; HandleCollision
	add	esp, 32					; 00000020H
$LN45@UpdatePlay:

; 76   : 			if (tile.tileID == 5) { ResetPlayer(); }

	mov	eax, DWORD PTR _tile$78[ebp]
	cmp	DWORD PTR [eax+24], 5
	jne	SHORT $LN46@UpdatePlay
	call	?ResetPlayer@@YAXXZ			; ResetPlayer
$LN46@UpdatePlay:

; 77   : 
; 78   : 			if (tile.tileID == 6) { 

	mov	eax, DWORD PTR _tile$78[ebp]
	cmp	DWORD PTR [eax+24], 6
	jne	SHORT $LN47@UpdatePlay

; 79   : 				if (CheckCollisionTop(tile) && trampolineCollison == false) { if (player.velocityY != 0) { player.velocityY = -player.velocityY; } }

	mov	esi, DWORD PTR _tile$78[ebp]
	sub	esp, 32					; 00000020H
	mov	ecx, 8
	mov	edi, esp
	rep movsd
	call	?CheckCollisionTop@@YA_NUTile@@@Z	; CheckCollisionTop
	add	esp, 32					; 00000020H
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN48@UpdatePlay
	movzx	eax, BYTE PTR _trampolineCollison$[ebp]
	test	eax, eax
	jne	SHORT $LN48@UpdatePlay
	movsd	xmm0, QWORD PTR ?player@@3UPlayer@@A+40
	ucomisd	xmm0, QWORD PTR __real@0000000000000000
	lahf
	test	ah, 68					; 00000044H
	jnp	SHORT $LN50@UpdatePlay
	movsd	xmm0, QWORD PTR ?player@@3UPlayer@@A+40
	xorps	xmm0, QWORD PTR __xmm@80000000000000008000000000000000
	movsd	QWORD PTR ?player@@3UPlayer@@A+40, xmm0
$LN50@UpdatePlay:
	jmp	SHORT $LN49@UpdatePlay
$LN48@UpdatePlay:

; 80   : 				else { HandleCollision(tile); }

	mov	esi, DWORD PTR _tile$78[ebp]
	sub	esp, 32					; 00000020H
	mov	ecx, 8
	mov	edi, esp
	rep movsd
	call	?HandleCollision@@YAXUTile@@@Z		; HandleCollision
	add	esp, 32					; 00000020H
$LN49@UpdatePlay:

; 81   : 
; 82   : 				trampolineCollison = true;

	mov	BYTE PTR _trampolineCollison$[ebp], 1
$LN47@UpdatePlay:

; 83   : 			}
; 84   : 
; 85   : 			if (tile.tileID == 7) {

	mov	eax, DWORD PTR _tile$78[ebp]
	cmp	DWORD PTR [eax+24], 7
	jne	$LN51@UpdatePlay

; 86   : 				if (CheckCollision(tile) && trampolineCollison == false) {

	mov	esi, DWORD PTR _tile$78[ebp]
	sub	esp, 32					; 00000020H
	mov	ecx, 8
	mov	edi, esp
	rep movsd
	call	?CheckCollision@@YA_NUTile@@@Z		; CheckCollision
	add	esp, 32					; 00000020H
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN52@UpdatePlay
	movzx	eax, BYTE PTR _trampolineCollison$[ebp]
	test	eax, eax
	jne	SHORT $LN52@UpdatePlay

; 87   : 					player.velocityY = (-player.velocityY / abs(player.velocityY)) * 2.5;

	movsd	xmm0, QWORD PTR ?player@@3UPlayer@@A+40
	xorps	xmm0, QWORD PTR __xmm@80000000000000008000000000000000
	sub	esp, 8
	movsd	xmm1, QWORD PTR ?player@@3UPlayer@@A+40
	movsd	QWORD PTR [esp], xmm1
	movsd	QWORD PTR tv1757[ebp], xmm0
	call	?abs@@YANN@Z				; abs
	add	esp, 8
	fstp	QWORD PTR tv1662[ebp]
	movsd	xmm0, QWORD PTR tv1757[ebp]
	divsd	xmm0, QWORD PTR tv1662[ebp]
	mulsd	xmm0, QWORD PTR __real@4004000000000000
	movsd	QWORD PTR ?player@@3UPlayer@@A+40, xmm0
$LN52@UpdatePlay:

; 88   : 				}
; 89   : 
; 90   : 				trampolineCollison = true;

	mov	BYTE PTR _trampolineCollison$[ebp], 1
$LN51@UpdatePlay:

; 91   : 			}
; 92   : 		}

	jmp	$LN8@UpdatePlay
$LN9@UpdatePlay:

; 93   : 	}

	mov	BYTE PTR __$EHRec$[ebp+8], 22		; 00000016H
	lea	ecx, DWORD PTR _<end>$L2$79[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _<begin>$L2$80[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAE@XZ

; 94   : 
; 95   : 	bool movingTileCollision = false;

	mov	BYTE PTR _movingTileCollision$[ebp], 0

; 96   : 	for (auto &tile : movingTileMap) {

	mov	DWORD PTR _<range>$L3$77[ebp], OFFSET ?movingTileMap@@3V?$vector@UMovingTile@@V?$allocator@UMovingTile@@@std@@@std@@A ; movingTileMap
	push	12					; 0000000cH
	lea	ecx, DWORD PTR _<begin>$L3$76[ebp]
	call	?__autoclassinit2@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UMovingTile@@@std@@@std@@@std@@QAEXI@Z
	lea	eax, DWORD PTR _<begin>$L3$76[ebp]
	push	eax
	mov	ecx, DWORD PTR _<range>$L3$77[ebp]
	call	?begin@?$vector@UMovingTile@@V?$allocator@UMovingTile@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UMovingTile@@@std@@@std@@@2@XZ ; std::vector<MovingTile,std::allocator<MovingTile> >::begin
	mov	DWORD PTR __$EHRec$[ebp+8], 24		; 00000018H
	push	12					; 0000000cH
	lea	ecx, DWORD PTR _<end>$L3$75[ebp]
	call	?__autoclassinit2@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UMovingTile@@@std@@@std@@@std@@QAEXI@Z
	lea	eax, DWORD PTR _<end>$L3$75[ebp]
	push	eax
	mov	ecx, DWORD PTR _<range>$L3$77[ebp]
	call	?end@?$vector@UMovingTile@@V?$allocator@UMovingTile@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UMovingTile@@@std@@@std@@@2@XZ ; std::vector<MovingTile,std::allocator<MovingTile> >::end
	mov	BYTE PTR __$EHRec$[ebp+8], 25		; 00000019H
	jmp	SHORT $LN13@UpdatePlay
$LN11@UpdatePlay:
	lea	ecx, DWORD PTR _<begin>$L3$76[ebp]
	call	??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UMovingTile@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<MovingTile> > >::operator++
$LN13@UpdatePlay:
	lea	eax, DWORD PTR _<end>$L3$75[ebp]
	push	eax
	lea	ecx, DWORD PTR _<begin>$L3$76[ebp]
	call	??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UMovingTile@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<MovingTile> > >::operator!=
	movzx	ecx, al
	test	ecx, ecx
	je	$LN12@UpdatePlay
	lea	ecx, DWORD PTR _<begin>$L3$76[ebp]
	call	??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UMovingTile@@@std@@@std@@@std@@QBEAAUMovingTile@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<MovingTile> > >::operator*
	mov	DWORD PTR _tile$74[ebp], eax

; 97   : 		if (CheckCollision(tile.tile) == true) {

	mov	esi, DWORD PTR _tile$74[ebp]
	sub	esp, 32					; 00000020H
	mov	ecx, 8
	mov	edi, esp
	rep movsd
	call	?CheckCollision@@YA_NUTile@@@Z		; CheckCollision
	add	esp, 32					; 00000020H
	movzx	eax, al
	cmp	eax, 1
	jne	$LN58@UpdatePlay

; 98   : 			movingTileCollision = true;

	mov	BYTE PTR _movingTileCollision$[ebp], 1

; 99   : 			HandleBasicCollision(tile.tile);

	mov	esi, DWORD PTR _tile$74[ebp]
	sub	esp, 32					; 00000020H
	mov	ecx, 8
	mov	edi, esp
	rep movsd
	call	?HandleBasicCollision@@YAXUTile@@@Z	; HandleBasicCollision
	add	esp, 32					; 00000020H

; 100  : 
; 101  : 			if (CheckCollisionLeft(tile.tile) == true) { tile.movingLeft = false; }

	mov	esi, DWORD PTR _tile$74[ebp]
	sub	esp, 32					; 00000020H
	mov	ecx, 8
	mov	edi, esp
	rep movsd
	call	?CheckCollisionLeft@@YA_NUTile@@@Z	; CheckCollisionLeft
	add	esp, 32					; 00000020H
	movzx	eax, al
	cmp	eax, 1
	jne	SHORT $LN54@UpdatePlay
	mov	eax, DWORD PTR _tile$74[ebp]
	mov	BYTE PTR [eax+40], 0
$LN54@UpdatePlay:

; 102  : 			if (CheckCollisionRight(tile.tile) == true) { tile.movingLeft = true; }

	mov	esi, DWORD PTR _tile$74[ebp]
	sub	esp, 32					; 00000020H
	mov	ecx, 8
	mov	edi, esp
	rep movsd
	call	?CheckCollisionRight@@YA_NUTile@@@Z	; CheckCollisionRight
	add	esp, 32					; 00000020H
	movzx	eax, al
	cmp	eax, 1
	jne	SHORT $LN55@UpdatePlay
	mov	eax, DWORD PTR _tile$74[ebp]
	mov	BYTE PTR [eax+40], 1
$LN55@UpdatePlay:

; 103  : 			if (CheckCollisionLeft(tile.tile) == false && CheckCollisionRight(tile.tile) == false) {

	mov	esi, DWORD PTR _tile$74[ebp]
	sub	esp, 32					; 00000020H
	mov	ecx, 8
	mov	edi, esp
	rep movsd
	call	?CheckCollisionLeft@@YA_NUTile@@@Z	; CheckCollisionLeft
	add	esp, 32					; 00000020H
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN58@UpdatePlay
	mov	esi, DWORD PTR _tile$74[ebp]
	sub	esp, 32					; 00000020H
	mov	ecx, 8
	mov	edi, esp
	rep movsd
	call	?CheckCollisionRight@@YA_NUTile@@@Z	; CheckCollisionRight
	add	esp, 32					; 00000020H
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN58@UpdatePlay

; 104  : 				if (tile.movingLeft == true) {

	mov	eax, DWORD PTR _tile$74[ebp]
	movzx	ecx, BYTE PTR [eax+40]
	cmp	ecx, 1
	jne	SHORT $LN57@UpdatePlay

; 105  : 					player.position.x -= tile.speed * deltaTimeS;

	cvtss2sd xmm0, DWORD PTR _deltaTimeS$[ebp]
	mov	eax, DWORD PTR _tile$74[ebp]
	mulsd	xmm0, QWORD PTR [eax+32]
	movsd	xmm1, QWORD PTR ?player@@3UPlayer@@A
	subsd	xmm1, xmm0
	movsd	QWORD PTR ?player@@3UPlayer@@A, xmm1

; 106  : 				}
; 107  : 				else {

	jmp	SHORT $LN58@UpdatePlay
$LN57@UpdatePlay:

; 108  : 					player.position.x += tile.speed * deltaTimeS;

	cvtss2sd xmm0, DWORD PTR _deltaTimeS$[ebp]
	mov	eax, DWORD PTR _tile$74[ebp]
	mulsd	xmm0, QWORD PTR [eax+32]
	addsd	xmm0, QWORD PTR ?player@@3UPlayer@@A
	movsd	QWORD PTR ?player@@3UPlayer@@A, xmm0
$LN58@UpdatePlay:

; 109  : 				}
; 110  : 			}
; 111  : 		}

	jmp	$LN11@UpdatePlay
$LN12@UpdatePlay:

; 112  : 	}

	mov	BYTE PTR __$EHRec$[ebp+8], 24		; 00000018H
	lea	ecx, DWORD PTR _<end>$L3$75[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UMovingTile@@@std@@@std@@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _<begin>$L3$76[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UMovingTile@@@std@@@std@@@std@@QAE@XZ

; 113  : 
; 114  : 	std::vector<Tile> tempGroundTileList;

	push	16					; 00000010H
	lea	ecx, DWORD PTR _tempGroundTileList$[ebp]
	call	?__autoclassinit2@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QAEXI@Z
	lea	ecx, DWORD PTR _tempGroundTileList$[ebp]
	call	??0?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QAE@XZ ; std::vector<Tile,std::allocator<Tile> >::vector<Tile,std::allocator<Tile> >
	mov	DWORD PTR __$EHRec$[ebp+8], 26		; 0000001aH

; 115  : 	for (auto &tile : groundTileList) {

	mov	DWORD PTR _<range>$L4$73[ebp], OFFSET ?groundTileList@@3V?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@A ; groundTileList
	push	12					; 0000000cH
	lea	ecx, DWORD PTR _<begin>$L4$72[ebp]
	call	?__autoclassinit2@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAEXI@Z
	lea	eax, DWORD PTR _<begin>$L4$72[ebp]
	push	eax
	mov	ecx, DWORD PTR _<range>$L4$73[ebp]
	call	?begin@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@2@XZ ; std::vector<Tile,std::allocator<Tile> >::begin
	mov	BYTE PTR __$EHRec$[ebp+8], 27		; 0000001bH
	push	12					; 0000000cH
	lea	ecx, DWORD PTR _<end>$L4$71[ebp]
	call	?__autoclassinit2@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAEXI@Z
	lea	eax, DWORD PTR _<end>$L4$71[ebp]
	push	eax
	mov	ecx, DWORD PTR _<range>$L4$73[ebp]
	call	?end@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@2@XZ ; std::vector<Tile,std::allocator<Tile> >::end
	mov	BYTE PTR __$EHRec$[ebp+8], 28		; 0000001cH
	jmp	SHORT $LN16@UpdatePlay
$LN14@UpdatePlay:
	lea	ecx, DWORD PTR _<begin>$L4$72[ebp]
	call	??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Tile> > >::operator++
$LN16@UpdatePlay:
	lea	eax, DWORD PTR _<end>$L4$71[ebp]
	push	eax
	lea	ecx, DWORD PTR _<begin>$L4$72[ebp]
	call	??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Tile> > >::operator!=
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN15@UpdatePlay
	lea	ecx, DWORD PTR _<begin>$L4$72[ebp]
	call	??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QBEAAUTile@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Tile> > >::operator*
	mov	DWORD PTR _tile$70[ebp], eax

; 116  : 		if (CheckCollision(tile) == false) {

	mov	esi, DWORD PTR _tile$70[ebp]
	sub	esp, 32					; 00000020H
	mov	ecx, 8
	mov	edi, esp
	rep movsd
	call	?CheckCollision@@YA_NUTile@@@Z		; CheckCollision
	add	esp, 32					; 00000020H
	movzx	eax, al
	test	eax, eax
	jne	SHORT $LN59@UpdatePlay

; 117  : 			tempGroundTileList.push_back(tile);

	mov	eax, DWORD PTR _tile$70[ebp]
	push	eax
	lea	ecx, DWORD PTR _tempGroundTileList$[ebp]
	call	?push_back@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QAEXABUTile@@@Z ; std::vector<Tile,std::allocator<Tile> >::push_back
$LN59@UpdatePlay:

; 118  : 		}

	jmp	SHORT $LN14@UpdatePlay
$LN15@UpdatePlay:

; 119  : 	}

	mov	BYTE PTR __$EHRec$[ebp+8], 27		; 0000001bH
	lea	ecx, DWORD PTR _<end>$L4$71[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 26		; 0000001aH
	lea	ecx, DWORD PTR _<begin>$L4$72[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAE@XZ

; 120  : 
; 121  : 	for (auto &tile : tempGroundTileList) {

	lea	eax, DWORD PTR _tempGroundTileList$[ebp]
	mov	DWORD PTR _<range>$L5$69[ebp], eax
	push	12					; 0000000cH
	lea	ecx, DWORD PTR _<begin>$L5$68[ebp]
	call	?__autoclassinit2@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAEXI@Z
	lea	eax, DWORD PTR _<begin>$L5$68[ebp]
	push	eax
	mov	ecx, DWORD PTR _<range>$L5$69[ebp]
	call	?begin@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@2@XZ ; std::vector<Tile,std::allocator<Tile> >::begin
	mov	BYTE PTR __$EHRec$[ebp+8], 29		; 0000001dH
	push	12					; 0000000cH
	lea	ecx, DWORD PTR _<end>$L5$67[ebp]
	call	?__autoclassinit2@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAEXI@Z
	lea	eax, DWORD PTR _<end>$L5$67[ebp]
	push	eax
	mov	ecx, DWORD PTR _<range>$L5$69[ebp]
	call	?end@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@2@XZ ; std::vector<Tile,std::allocator<Tile> >::end
	mov	BYTE PTR __$EHRec$[ebp+8], 30		; 0000001eH
	jmp	SHORT $LN19@UpdatePlay
$LN17@UpdatePlay:
	lea	ecx, DWORD PTR _<begin>$L5$68[ebp]
	call	??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Tile> > >::operator++
$LN19@UpdatePlay:
	lea	eax, DWORD PTR _<end>$L5$67[ebp]
	push	eax
	lea	ecx, DWORD PTR _<begin>$L5$68[ebp]
	call	??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Tile> > >::operator!=
	movzx	ecx, al
	test	ecx, ecx
	je	$LN18@UpdatePlay
	lea	ecx, DWORD PTR _<begin>$L5$68[ebp]
	call	??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QBEAAUTile@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Tile> > >::operator*
	mov	DWORD PTR _tile$66[ebp], eax

; 122  : 		groundTileList.erase(std::remove(groundTileList.begin(), groundTileList.end(), tile), groundTileList.end());

	lea	eax, DWORD PTR $T8[ebp]
	push	eax
	mov	ecx, OFFSET ?groundTileList@@3V?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@A ; groundTileList
	call	?end@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@2@XZ ; std::vector<Tile,std::allocator<Tile> >::end
	mov	DWORD PTR tv991[ebp], eax
	mov	ecx, DWORD PTR tv991[ebp]
	mov	DWORD PTR tv1257[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 31		; 0000001fH
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T9[ebp], esp
	mov	edx, DWORD PTR tv1257[ebp]
	push	edx
	call	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAE@$$QAV01@@Z
	mov	DWORD PTR tv985[ebp], eax
	mov	eax, DWORD PTR tv985[ebp]
	mov	DWORD PTR tv1259[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 32		; 00000020H
	mov	ecx, DWORD PTR _tile$66[ebp]
	push	ecx
	sub	esp, 12					; 0000000cH
	mov	edx, esp
	mov	DWORD PTR $T6[ebp], esp
	push	edx
	mov	ecx, OFFSET ?groundTileList@@3V?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@A ; groundTileList
	call	?end@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@2@XZ ; std::vector<Tile,std::allocator<Tile> >::end
	mov	DWORD PTR tv1264[ebp], eax
	sub	esp, 12					; 0000000cH
	mov	eax, esp
	mov	DWORD PTR $T5[ebp], esp
	push	eax
	mov	ecx, OFFSET ?groundTileList@@3V?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@A ; groundTileList
	call	?begin@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@2@XZ ; std::vector<Tile,std::allocator<Tile> >::begin
	mov	DWORD PTR tv1267[ebp], eax
	lea	ecx, DWORD PTR $T4[ebp]
	push	ecx
	call	??$remove@V?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@UTile@@@std@@YA?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@0@V10@0ABUTile@@@Z ; std::remove<std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Tile> > >,Tile>
	add	esp, 32					; 00000020H
	mov	DWORD PTR tv1045[ebp], eax
	mov	edx, DWORD PTR tv1045[ebp]
	mov	DWORD PTR tv1269[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 33		; 00000021H
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T7[ebp], esp
	mov	eax, DWORD PTR tv1269[ebp]
	push	eax
	call	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAE@$$QAV01@@Z
	mov	DWORD PTR tv1271[ebp], eax
	lea	ecx, DWORD PTR $T3[ebp]
	push	ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 34		; 00000022H
	mov	ecx, OFFSET ?groundTileList@@3V?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@A ; groundTileList
	call	?erase@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@2@0@Z ; std::vector<Tile,std::allocator<Tile> >::erase
	mov	DWORD PTR tv1260[ebp], eax
	lea	ecx, DWORD PTR $T3[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 31		; 0000001fH
	lea	ecx, DWORD PTR $T4[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 30		; 0000001eH
	lea	ecx, DWORD PTR $T8[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAE@XZ
	jmp	$LN17@UpdatePlay
$LN18@UpdatePlay:

; 123  : 	}

	mov	BYTE PTR __$EHRec$[ebp+8], 29		; 0000001dH
	lea	ecx, DWORD PTR _<end>$L5$67[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 26		; 0000001aH
	lea	ecx, DWORD PTR _<begin>$L5$68[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAE@XZ

; 124  : 	tempGroundTileList.clear();

	lea	ecx, DWORD PTR _tempGroundTileList$[ebp]
	call	?clear@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QAEXXZ ; std::vector<Tile,std::allocator<Tile> >::clear

; 125  : 
; 126  : 	if (groundTileList.size() == 0 && movingTileCollision == false) player.onGround = false;

	mov	ecx, OFFSET ?groundTileList@@3V?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@A ; groundTileList
	call	?size@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QBEIXZ ; std::vector<Tile,std::allocator<Tile> >::size
	test	eax, eax
	jne	SHORT $LN60@UpdatePlay
	movzx	eax, BYTE PTR _movingTileCollision$[ebp]
	test	eax, eax
	jne	SHORT $LN60@UpdatePlay
	mov	BYTE PTR ?player@@3UPlayer@@A+24, 0
$LN60@UpdatePlay:

; 127  : }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tempGroundTileList$[ebp]
	call	??1?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QAE@XZ ; std::vector<Tile,std::allocator<Tile> >::~vector<Tile,std::allocator<Tile> >
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN159@UpdatePlay
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 2032				; 000007f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN159@UpdatePlay:
	DD	13					; 0000000dH
	DD	$LN158@UpdatePlay
$LN158@UpdatePlay:
	DD	-56					; ffffffc8H
	DD	12					; 0000000cH
	DD	$LN144@UpdatePlay
	DD	-76					; ffffffb4H
	DD	12					; 0000000cH
	DD	$LN145@UpdatePlay
	DD	-120					; ffffff88H
	DD	12					; 0000000cH
	DD	$LN146@UpdatePlay
	DD	-140					; ffffff74H
	DD	12					; 0000000cH
	DD	$LN147@UpdatePlay
	DD	-196					; ffffff3cH
	DD	12					; 0000000cH
	DD	$LN148@UpdatePlay
	DD	-216					; ffffff28H
	DD	12					; 0000000cH
	DD	$LN149@UpdatePlay
	DD	-272					; fffffef0H
	DD	12					; 0000000cH
	DD	$LN150@UpdatePlay
	DD	-292					; fffffedcH
	DD	12					; 0000000cH
	DD	$LN151@UpdatePlay
	DD	-328					; fffffeb8H
	DD	16					; 00000010H
	DD	$LN152@UpdatePlay
	DD	-360					; fffffe98H
	DD	12					; 0000000cH
	DD	$LN153@UpdatePlay
	DD	-380					; fffffe84H
	DD	12					; 0000000cH
	DD	$LN154@UpdatePlay
	DD	-424					; fffffe58H
	DD	12					; 0000000cH
	DD	$LN155@UpdatePlay
	DD	-444					; fffffe44H
	DD	12					; 0000000cH
	DD	$LN156@UpdatePlay
$LN156@UpdatePlay:
	DB	60					; 0000003cH
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	100					; 00000064H
	DB	62					; 0000003eH
	DB	36					; 00000024H
	DB	76					; 0000004cH
	DB	53					; 00000035H
	DB	0
$LN155@UpdatePlay:
	DB	60					; 0000003cH
	DB	98					; 00000062H
	DB	101					; 00000065H
	DB	103					; 00000067H
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	62					; 0000003eH
	DB	36					; 00000024H
	DB	76					; 0000004cH
	DB	53					; 00000035H
	DB	0
$LN154@UpdatePlay:
	DB	60					; 0000003cH
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	100					; 00000064H
	DB	62					; 0000003eH
	DB	36					; 00000024H
	DB	76					; 0000004cH
	DB	52					; 00000034H
	DB	0
$LN153@UpdatePlay:
	DB	60					; 0000003cH
	DB	98					; 00000062H
	DB	101					; 00000065H
	DB	103					; 00000067H
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	62					; 0000003eH
	DB	36					; 00000024H
	DB	76					; 0000004cH
	DB	52					; 00000034H
	DB	0
$LN152@UpdatePlay:
	DB	116					; 00000074H
	DB	101					; 00000065H
	DB	109					; 0000006dH
	DB	112					; 00000070H
	DB	71					; 00000047H
	DB	114					; 00000072H
	DB	111					; 0000006fH
	DB	117					; 00000075H
	DB	110					; 0000006eH
	DB	100					; 00000064H
	DB	84					; 00000054H
	DB	105					; 00000069H
	DB	108					; 0000006cH
	DB	101					; 00000065H
	DB	76					; 0000004cH
	DB	105					; 00000069H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	0
$LN151@UpdatePlay:
	DB	60					; 0000003cH
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	100					; 00000064H
	DB	62					; 0000003eH
	DB	36					; 00000024H
	DB	76					; 0000004cH
	DB	51					; 00000033H
	DB	0
$LN150@UpdatePlay:
	DB	60					; 0000003cH
	DB	98					; 00000062H
	DB	101					; 00000065H
	DB	103					; 00000067H
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	62					; 0000003eH
	DB	36					; 00000024H
	DB	76					; 0000004cH
	DB	51					; 00000033H
	DB	0
$LN149@UpdatePlay:
	DB	60					; 0000003cH
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	100					; 00000064H
	DB	62					; 0000003eH
	DB	36					; 00000024H
	DB	76					; 0000004cH
	DB	50					; 00000032H
	DB	0
$LN148@UpdatePlay:
	DB	60					; 0000003cH
	DB	98					; 00000062H
	DB	101					; 00000065H
	DB	103					; 00000067H
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	62					; 0000003eH
	DB	36					; 00000024H
	DB	76					; 0000004cH
	DB	50					; 00000032H
	DB	0
$LN147@UpdatePlay:
	DB	60					; 0000003cH
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	100					; 00000064H
	DB	62					; 0000003eH
	DB	36					; 00000024H
	DB	76					; 0000004cH
	DB	49					; 00000031H
	DB	0
$LN146@UpdatePlay:
	DB	60					; 0000003cH
	DB	98					; 00000062H
	DB	101					; 00000065H
	DB	103					; 00000067H
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	62					; 0000003eH
	DB	36					; 00000024H
	DB	76					; 0000004cH
	DB	49					; 00000031H
	DB	0
$LN145@UpdatePlay:
	DB	60					; 0000003cH
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	100					; 00000064H
	DB	62					; 0000003eH
	DB	36					; 00000024H
	DB	76					; 0000004cH
	DB	48					; 00000030H
	DB	0
$LN144@UpdatePlay:
	DB	60					; 0000003cH
	DB	98					; 00000062H
	DB	101					; 00000065H
	DB	103					; 00000067H
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	62					; 0000003eH
	DB	36					; 00000024H
	DB	76					; 0000004cH
	DB	48					; 00000030H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?UpdatePlayer@@YAXH@Z$0:
	lea	ecx, DWORD PTR _<begin>$L0$88[ebp]
	jmp	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$?UpdatePlayer@@YAXH@Z$1:
	lea	ecx, DWORD PTR _<end>$L0$87[ebp]
	jmp	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$?UpdatePlayer@@YAXH@Z$6:
	lea	ecx, DWORD PTR $T56[ebp]
	jmp	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ
__unwindfunclet$?UpdatePlayer@@YAXH@Z$9:
	lea	ecx, DWORD PTR $T57[ebp]
	jmp	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ
__unwindfunclet$?UpdatePlayer@@YAXH@Z$10:
	lea	ecx, DWORD PTR $T50[ebp]
	jmp	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ
__unwindfunclet$?UpdatePlayer@@YAXH@Z$13:
	lea	ecx, DWORD PTR $T51[ebp]
	jmp	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ
__unwindfunclet$?UpdatePlayer@@YAXH@Z$14:
	lea	ecx, DWORD PTR $T44[ebp]
	jmp	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ
__unwindfunclet$?UpdatePlayer@@YAXH@Z$17:
	lea	ecx, DWORD PTR $T45[ebp]
	jmp	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ
__unwindfunclet$?UpdatePlayer@@YAXH@Z$18:
	mov	eax, DWORD PTR $T2[ebp]
	and	eax, 1
	je	$LN87@UpdatePlay
	and	DWORD PTR $T2[ebp], -2			; fffffffeH
	lea	ecx, DWORD PTR $T38[ebp]
	jmp	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ
$LN87@UpdatePlay:
	ret	0
__unwindfunclet$?UpdatePlayer@@YAXH@Z$21:
	mov	eax, DWORD PTR $T2[ebp]
	and	eax, 2
	je	$LN91@UpdatePlay
	and	DWORD PTR $T2[ebp], -3			; fffffffdH
	lea	ecx, DWORD PTR $T39[ebp]
	jmp	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ
$LN91@UpdatePlay:
	ret	0
__unwindfunclet$?UpdatePlayer@@YAXH@Z$22:
	mov	eax, DWORD PTR $T2[ebp]
	and	eax, 4
	je	$LN93@UpdatePlay
	and	DWORD PTR $T2[ebp], -5			; fffffffbH
	lea	ecx, DWORD PTR $T33[ebp]
	jmp	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ
$LN93@UpdatePlay:
	ret	0
__unwindfunclet$?UpdatePlayer@@YAXH@Z$25:
	mov	eax, DWORD PTR $T2[ebp]
	and	eax, 8
	je	$LN97@UpdatePlay
	and	DWORD PTR $T2[ebp], -9			; fffffff7H
	lea	ecx, DWORD PTR $T34[ebp]
	jmp	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ
$LN97@UpdatePlay:
	ret	0
__unwindfunclet$?UpdatePlayer@@YAXH@Z$26:
	mov	eax, DWORD PTR $T2[ebp]
	and	eax, 16					; 00000010H
	je	$LN103@UpdatePlay
	and	DWORD PTR $T2[ebp], -17			; ffffffefH
	lea	ecx, DWORD PTR $T27[ebp]
	jmp	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ
$LN103@UpdatePlay:
	ret	0
__unwindfunclet$?UpdatePlayer@@YAXH@Z$29:
	mov	eax, DWORD PTR $T2[ebp]
	and	eax, 32					; 00000020H
	je	$LN107@UpdatePlay
	and	DWORD PTR $T2[ebp], -33			; ffffffdfH
	lea	ecx, DWORD PTR $T28[ebp]
	jmp	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ
$LN107@UpdatePlay:
	ret	0
__unwindfunclet$?UpdatePlayer@@YAXH@Z$30:
	mov	eax, DWORD PTR $T2[ebp]
	and	eax, 64					; 00000040H
	je	$LN109@UpdatePlay
	and	DWORD PTR $T2[ebp], -65			; ffffffbfH
	lea	ecx, DWORD PTR $T22[ebp]
	jmp	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ
$LN109@UpdatePlay:
	ret	0
__unwindfunclet$?UpdatePlayer@@YAXH@Z$33:
	mov	eax, DWORD PTR $T2[ebp]
	and	eax, 128				; 00000080H
	je	$LN113@UpdatePlay
	and	DWORD PTR $T2[ebp], -129		; ffffff7fH
	lea	ecx, DWORD PTR $T23[ebp]
	jmp	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ
$LN113@UpdatePlay:
	ret	0
__unwindfunclet$?UpdatePlayer@@YAXH@Z$34:
	lea	ecx, DWORD PTR _<begin>$L1$84[ebp]
	jmp	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UAirTile@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$?UpdatePlayer@@YAXH@Z$35:
	lea	ecx, DWORD PTR _<end>$L1$83[ebp]
	jmp	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UAirTile@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$?UpdatePlayer@@YAXH@Z$36:
	lea	ecx, DWORD PTR $T16[ebp]
	jmp	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ
__unwindfunclet$?UpdatePlayer@@YAXH@Z$39:
	lea	ecx, DWORD PTR $T17[ebp]
	jmp	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ
__unwindfunclet$?UpdatePlayer@@YAXH@Z$40:
	lea	ecx, DWORD PTR $T10[ebp]
	jmp	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ
__unwindfunclet$?UpdatePlayer@@YAXH@Z$43:
	lea	ecx, DWORD PTR $T11[ebp]
	jmp	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@H@std@@@std@@@std@@QAE@XZ
__unwindfunclet$?UpdatePlayer@@YAXH@Z$44:
	lea	ecx, DWORD PTR _<begin>$L2$80[ebp]
	jmp	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$?UpdatePlayer@@YAXH@Z$45:
	lea	ecx, DWORD PTR _<end>$L2$79[ebp]
	jmp	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$?UpdatePlayer@@YAXH@Z$46:
	lea	ecx, DWORD PTR _<begin>$L3$76[ebp]
	jmp	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UMovingTile@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$?UpdatePlayer@@YAXH@Z$47:
	lea	ecx, DWORD PTR _<end>$L3$75[ebp]
	jmp	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UMovingTile@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$?UpdatePlayer@@YAXH@Z$48:
	lea	ecx, DWORD PTR _tempGroundTileList$[ebp]
	jmp	??1?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QAE@XZ ; std::vector<Tile,std::allocator<Tile> >::~vector<Tile,std::allocator<Tile> >
__unwindfunclet$?UpdatePlayer@@YAXH@Z$49:
	lea	ecx, DWORD PTR _<begin>$L4$72[ebp]
	jmp	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$?UpdatePlayer@@YAXH@Z$50:
	lea	ecx, DWORD PTR _<end>$L4$71[ebp]
	jmp	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$?UpdatePlayer@@YAXH@Z$51:
	lea	ecx, DWORD PTR _<begin>$L5$68[ebp]
	jmp	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$?UpdatePlayer@@YAXH@Z$52:
	lea	ecx, DWORD PTR _<end>$L5$67[ebp]
	jmp	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$?UpdatePlayer@@YAXH@Z$53:
	lea	ecx, DWORD PTR $T8[ebp]
	jmp	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$?UpdatePlayer@@YAXH@Z$54:
	mov	ecx, DWORD PTR $T9[ebp]
	jmp	??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$?UpdatePlayer@@YAXH@Z$57:
	lea	ecx, DWORD PTR $T4[ebp]
	jmp	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAE@XZ
__ehhandler$?UpdatePlayer@@YAXH@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-2036]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?UpdatePlayer@@YAXH@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?UpdatePlayer@@YAXH@Z ENDP				; UpdatePlayer
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??0Player@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0Player@@QAE@XZ PROC					; Player::Player, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0Vector2@@QAE@XZ			; Vector2::Vector2
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+16], 5
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+20], 5
	mov	eax, DWORD PTR _this$[ebp]
	mov	BYTE PTR [eax+24], 0
	mov	eax, DWORD PTR _this$[ebp]
	movsd	xmm0, QWORD PTR __real@4049000000000000
	movsd	QWORD PTR [eax+48], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	movsd	xmm0, QWORD PTR __real@3ffc000000000000
	movsd	QWORD PTR [eax+56], xmm0
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0Player@@QAE@XZ ENDP					; Player::Player
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File g:\projects\lotion\lotion\player.h
;	COMDAT ?right@Player@@QAENXZ
_TEXT	SEGMENT
tv73 = -212						; size = 8
_this$ = -8						; size = 4
?right@Player@@QAENXZ PROC				; Player::right, COMDAT
; _this$ = ecx

; 14   : 	inline double right() { return position.x + width; }

	push	ebp
	mov	ebp, esp
	sub	esp, 212				; 000000d4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-212]
	mov	ecx, 53					; 00000035H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	cvtsi2sd xmm0, DWORD PTR [eax+16]
	mov	ecx, DWORD PTR _this$[ebp]
	addsd	xmm0, QWORD PTR [ecx]
	movsd	QWORD PTR tv73[ebp], xmm0
	fld	QWORD PTR tv73[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?right@Player@@QAENXZ ENDP				; Player::right
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File g:\projects\lotion\lotion\player.h
;	COMDAT ?left@Player@@QAENXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?left@Player@@QAENXZ PROC				; Player::left, COMDAT
; _this$ = ecx

; 13   : 	inline double left() { return position.x; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	QWORD PTR [eax]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?left@Player@@QAENXZ ENDP				; Player::left
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File g:\projects\lotion\lotion\player.h
;	COMDAT ?bottom@Player@@QAENXZ
_TEXT	SEGMENT
tv73 = -212						; size = 8
_this$ = -8						; size = 4
?bottom@Player@@QAENXZ PROC				; Player::bottom, COMDAT
; _this$ = ecx

; 12   : 	inline double bottom() { return position.y + height; }

	push	ebp
	mov	ebp, esp
	sub	esp, 212				; 000000d4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-212]
	mov	ecx, 53					; 00000035H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	cvtsi2sd xmm0, DWORD PTR [eax+20]
	mov	ecx, DWORD PTR _this$[ebp]
	addsd	xmm0, QWORD PTR [ecx+8]
	movsd	QWORD PTR tv73[ebp], xmm0
	fld	QWORD PTR tv73[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?bottom@Player@@QAENXZ ENDP				; Player::bottom
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File g:\projects\lotion\lotion\player.h
;	COMDAT ?top@Player@@QAENXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?top@Player@@QAENXZ PROC				; Player::top, COMDAT
; _this$ = ecx

; 11   : 	inline double top() { return position.y; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	QWORD PTR [eax+8]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?top@Player@@QAENXZ ENDP				; Player::top
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File g:\projects\lotion\lotion\player.h
;	COMDAT ?midpoint@Player@@QAE?AVVector2@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
?midpoint@Player@@QAE?AVVector2@@XZ PROC		; Player::midpoint, COMDAT
; _this$ = ecx

; 9    : 	inline Vector2 midpoint() { return Vector2(position.x + (position.x / 2), position.y + (position.y / 2)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movsd	xmm0, QWORD PTR [eax+8]
	divsd	xmm0, QWORD PTR __real@4000000000000000
	mov	ecx, DWORD PTR _this$[ebp]
	addsd	xmm0, QWORD PTR [ecx+8]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	movsd	xmm0, QWORD PTR [edx]
	divsd	xmm0, QWORD PTR __real@4000000000000000
	mov	eax, DWORD PTR _this$[ebp]
	addsd	xmm0, QWORD PTR [eax]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector2@@QAE@NN@Z			; Vector2::Vector2
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?midpoint@Player@@QAE?AVVector2@@XZ ENDP		; Player::midpoint
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?__autoclassinit2@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_classSize$ = 8						; size = 4
?__autoclassinit2@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@QAEXI@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<PushTile> > >::__autoclassinit2, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _classSize$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?__autoclassinit2@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@QAEXI@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<PushTile> > >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<PushTile> > >::~_Vector_iterator<std::_Vector_val<std::_Simple_types<PushTile> > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@QAE@XZ
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<PushTile> > >::~_Vector_iterator<std::_Vector_val<std::_Simple_types<PushTile> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<PushTile> > >::operator++, COMDAT
; _this$ = ecx

; 340  : 		{	// preincrement

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 341  : 		++*(_Mybase *)this;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PushTile> > >::operator++

; 342  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 343  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<PushTile> > >::operator++
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@QBEAAUPushTile@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@QBEAAUPushTile@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<PushTile> > >::operator*, COMDAT
; _this$ = ecx

; 330  : 		{	// return designated object

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 331  : 		return ((reference)**(_Mybase *)this);

	mov	ecx, DWORD PTR _this$[ebp]
	call	??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@QBEABUPushTile@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PushTile> > >::operator*

; 332  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@QBEAAUPushTile@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<PushTile> > >::operator*
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@QAE@PAUPushTile@@PBU_Container_base12@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@QAE@PAUPushTile@@PBU_Container_base12@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<PushTile> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<PushTile> > >, COMDAT
; _this$ = ecx

; 313  : 		{	// construct with pointer _Parg

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 312  : 		: _Mybase(_Parg, _Pvector)

	mov	eax, DWORD PTR __Pvector$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Parg$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@QAE@PAUPushTile@@PBU_Container_base12@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PushTile> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PushTile> > >

; 314  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@QAE@PAUPushTile@@PBU_Container_base12@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<PushTile> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<PushTile> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___that$ = 8						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@QAE@ABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PushTile> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PushTile> > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Iterator012@Urandom_access_iterator_tag@std@@UPushTile@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PushTile> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PushTile> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PushTile> > >::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PushTile> > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Iterator012@Urandom_access_iterator_tag@std@@UPushTile@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PushTile> > >::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PushTile> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PushTile> > >::_Compat, COMDAT
; _this$ = ecx

; 245  : 		{	// test for compatible iterator pair

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 246  : 		if (this->_Getcont() != _Right._Getcont())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
	mov	esi, eax
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
	cmp	esi, eax
	je	$LN1@Compat

; 247  : 			{
; 248  : 			_DEBUG_ERROR("vector iterators incompatible");

	mov	esi, esp
	push	248					; 000000f8H
	push	OFFSET ??_C@_1IM@NCODKBJH@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	OFFSET ??_C@_1DM@HINDPMBP@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AAs?$AA?5?$AAi?$AAn?$AAc?$AAo?$AAm?$AAp?$AAa?$AAt?$AAi?$AAb?$AAl?$AAe?$AA?$AA@
	call	DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 249  : 			_SCL_SECURE_INVALID_ARGUMENT;

	mov	eax, OFFSET ??_C@_0CI@FNPHFCCM@Standard?5C?$CL?$CL?5Libraries?5Invalid?5A@
	test	eax, eax
	je	SHORT $LN4@Compat
	xor	ecx, ecx
	jne	SHORT $LN5@Compat
$LN4@Compat:
	mov	esi, esp
	push	OFFSET ??_C@_1FO@GJIHNDLM@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5@
	push	OFFSET ??_C@_17CNPHIMPH@?$AA?$CF?$AAl?$AAs?$AA?$AA@
	push	0
	push	249					; 000000f9H
	push	OFFSET ??_C@_1IM@NCODKBJH@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	2
	call	DWORD PTR __imp___CrtDbgReportW
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN5@Compat
	int	3
$LN5@Compat:
	mov	esi, esp
	push	0
	push	249					; 000000f9H
	push	OFFSET ??_C@_1IM@NCODKBJH@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	OFFSET ??_C@_1NG@COIFKLBO@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
	push	OFFSET ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN1@Compat:

; 250  : 			}
; 251  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PushTile> > >::_Compat
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv69 = -208						; size = 4
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PushTile> > >::operator!=, COMDAT
; _this$ = ecx

; 218  : 		{	// test for iterator inequality

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 219  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PushTile> > >::operator==
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv69[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv69[ebp]

; 220  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PushTile> > >::operator!=
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv69 = -208						; size = 4
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PushTile> > >::operator==, COMDAT
; _this$ = ecx

; 212  : 		{	// test for iterator equality

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 213  : 		_Compat(_Right);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PushTile> > >::_Compat

; 214  : 		return (_Ptr == _Right._Ptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+8]
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv69[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv69[ebp]

; 215  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PushTile> > >::operator==
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
__Mycont$ = -20						; size = 4
_this$ = -8						; size = 4
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PushTile> > >::operator++, COMDAT
; _this$ = ecx

; 95   : 		{	// preincrement

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 96   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 97   : 		const auto _Mycont = static_cast<const _Myvec *>(this->_Getcont());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
	mov	DWORD PTR __Mycont$[ebp], eax

; 98   : 		if (_Mycont == 0
; 99   : 			|| _Ptr == nullptr_t{}
; 100  : 			|| _Mycont->_Mylast <= _Ptr)

	cmp	DWORD PTR __Mycont$[ebp], 0
	je	SHORT $LN3@operator
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN3@operator
	mov	eax, DWORD PTR __Mycont$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+8]
	ja	SHORT $LN2@operator
$LN3@operator:

; 101  : 			{	// report error
; 102  : 			_DEBUG_ERROR("vector iterator not incrementable");

	mov	esi, esp
	push	102					; 00000066H
	push	OFFSET ??_C@_1IM@NCODKBJH@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	OFFSET ??_C@_1EE@EJDKCLKB@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAi?$AAn?$AAc?$AAr?$AAe?$AAm?$AAe?$AAn?$AAt?$AAa?$AAb?$AAl@
	call	DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 103  : 			_SCL_SECURE_OUT_OF_RANGE;

	mov	eax, OFFSET ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@
	test	eax, eax
	je	SHORT $LN5@operator
	xor	ecx, ecx
	jne	SHORT $LN6@operator
$LN5@operator:
	mov	esi, esp
	push	OFFSET ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@
	push	OFFSET ??_C@_17CNPHIMPH@?$AA?$CF?$AAl?$AAs?$AA?$AA@
	push	0
	push	103					; 00000067H
	push	OFFSET ??_C@_1IM@NCODKBJH@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	2
	call	DWORD PTR __imp___CrtDbgReportW
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN6@operator
	int	3
$LN6@operator:
	mov	esi, esp
	push	0
	push	103					; 00000067H
	push	OFFSET ??_C@_1IM@NCODKBJH@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	OFFSET ??_C@_1NO@MMDDECIN@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
	push	OFFSET ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@operator:

; 104  : 			}
; 105  : 
; 106  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 107  : 		_SCL_SECURE_VALIDATE(_Ptr != _Tptr());
; 108  : 		const auto _Mycont = static_cast<const _Myvec *>(this->_Getcont());
; 109  : 		_SCL_SECURE_VALIDATE(_Mycont != 0);
; 110  : 		_SCL_SECURE_VALIDATE_RANGE(_Ptr < _Mycont->_Mylast);
; 111  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 112  : 
; 113  : 		++_Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, 48					; 00000030H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 114  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 115  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PushTile> > >::operator++
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@QBEABUPushTile@@XZ
_TEXT	SEGMENT
__Mycont$ = -20						; size = 4
_this$ = -8						; size = 4
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@QBEABUPushTile@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PushTile> > >::operator*, COMDAT
; _this$ = ecx

; 65   : 		{	// return designated object

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 66   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 67   : 		const auto _Mycont = static_cast<const _Myvec *>(this->_Getcont());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
	mov	DWORD PTR __Mycont$[ebp], eax

; 68   : 		if (_Mycont == 0
; 69   : 			|| _Ptr == _Tptr()
; 70   : 			|| _Ptr < _Mycont->_Myfirst
; 71   : 			|| _Mycont->_Mylast <= _Ptr)

	cmp	DWORD PTR __Mycont$[ebp], 0
	je	SHORT $LN3@operator
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN3@operator
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Mycont$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+4]
	jb	SHORT $LN3@operator
	mov	eax, DWORD PTR __Mycont$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+8]
	ja	SHORT $LN2@operator
$LN3@operator:

; 72   : 			{	// report error
; 73   : 			_DEBUG_ERROR("vector iterator not dereferencable");

	mov	esi, esp
	push	73					; 00000049H
	push	OFFSET ??_C@_1IM@NCODKBJH@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	OFFSET ??_C@_1EG@FOHJJHAC@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe?$AAn?$AAc?$AAa?$AAb@
	call	DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 74   : 			_SCL_SECURE_OUT_OF_RANGE;

	mov	eax, OFFSET ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@
	test	eax, eax
	je	SHORT $LN5@operator
	xor	ecx, ecx
	jne	SHORT $LN6@operator
$LN5@operator:
	mov	esi, esp
	push	OFFSET ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@
	push	OFFSET ??_C@_17CNPHIMPH@?$AA?$CF?$AAl?$AAs?$AA?$AA@
	push	0
	push	74					; 0000004aH
	push	OFFSET ??_C@_1IM@NCODKBJH@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	2
	call	DWORD PTR __imp___CrtDbgReportW
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN6@operator
	int	3
$LN6@operator:
	mov	esi, esp
	push	0
	push	74					; 0000004aH
	push	OFFSET ??_C@_1IM@NCODKBJH@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	OFFSET ??_C@_1NM@EONCPDKK@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
	push	OFFSET ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@operator:

; 75   : 			}
; 76   : 
; 77   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 78   : 		_SCL_SECURE_VALIDATE(_Ptr != _Tptr());
; 79   : 		const auto _Mycont = static_cast<const _Myvec *>(this->_Getcont());
; 80   : 		_SCL_SECURE_VALIDATE(_Mycont != 0);
; 81   : 		_SCL_SECURE_VALIDATE_RANGE(_Mycont->_Myfirst <= _Ptr && _Ptr < _Mycont->_Mylast);
; 82   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 83   : 
; 84   : 		_Analysis_assume_(_Ptr != _Tptr());
; 85   : 
; 86   : 		return (*_Ptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]

; 87   : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@QBEABUPushTile@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PushTile> > >::operator*
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Unchecked@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@QBEPBUPushTile@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Unchecked@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@QBEPBUPushTile@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PushTile> > >::_Unchecked, COMDAT
; _this$ = ecx

; 60   : 		{	// make an unchecked iterator

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 61   : 		return (_Ptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]

; 62   : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?_Unchecked@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@QBEPBUPushTile@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PushTile> > >::_Unchecked
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@QAE@PAUPushTile@@PBU_Container_base12@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@QAE@PAUPushTile@@PBU_Container_base12@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PushTile> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PushTile> > >, COMDAT
; _this$ = ecx

; 47   : 		{	// construct with pointer _Parg

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@QAE@PAUPushTile@@PBU_Container_base12@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Iterator012@Urandom_access_iterator_tag@std@@UPushTile@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 46   : 		: _Ptr(_Parg)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Parg$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 48   : 		this->_Adopt(_Pvector);

	mov	eax, DWORD PTR __Pvector$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt

; 49   : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@QAE@PAUPushTile@@PBU_Container_base12@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Iterator012@Urandom_access_iterator_tag@std@@UPushTile@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ
__ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@QAE@PAUPushTile@@PBU_Container_base12@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@QAE@PAUPushTile@@PBU_Container_base12@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@QAE@PAUPushTile@@PBU_Container_base12@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PushTile> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PushTile> > >
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??0?$_Iterator012@Urandom_access_iterator_tag@std@@UPushTile@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___that$ = 8						; size = 4
??0?$_Iterator012@Urandom_access_iterator_tag@std@@UPushTile@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z PROC ; std::_Iterator012<std::random_access_iterator_tag,PushTile,int,PushTile const *,PushTile const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,PushTile,int,PushTile const *,PushTile const &,std::_Iterator_base12>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Iterator_base12@std@@QAE@ABU01@@Z	; std::_Iterator_base12::_Iterator_base12
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_Iterator012@Urandom_access_iterator_tag@std@@UPushTile@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z ENDP ; std::_Iterator012<std::random_access_iterator_tag,PushTile,int,PushTile const *,PushTile const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,PushTile,int,PushTile const *,PushTile const &,std::_Iterator_base12>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1?$_Iterator012@Urandom_access_iterator_tag@std@@UPushTile@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$_Iterator012@Urandom_access_iterator_tag@std@@UPushTile@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ PROC ; std::_Iterator012<std::random_access_iterator_tag,PushTile,int,PushTile const *,PushTile const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,PushTile,int,PushTile const *,PushTile const &,std::_Iterator_base12>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Iterator_base12@std@@QAE@XZ		; std::_Iterator_base12::~_Iterator_base12
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Iterator012@Urandom_access_iterator_tag@std@@UPushTile@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ ENDP ; std::_Iterator012<std::random_access_iterator_tag,PushTile,int,PushTile const *,PushTile const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,PushTile,int,PushTile const *,PushTile const &,std::_Iterator_base12>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??0?$_Iterator012@Urandom_access_iterator_tag@std@@UPushTile@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$_Iterator012@Urandom_access_iterator_tag@std@@UPushTile@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ PROC ; std::_Iterator012<std::random_access_iterator_tag,PushTile,int,PushTile const *,PushTile const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,PushTile,int,PushTile const *,PushTile const &,std::_Iterator_base12>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Iterator_base12@std@@QAE@XZ		; std::_Iterator_base12::_Iterator_base12
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Iterator012@Urandom_access_iterator_tag@std@@UPushTile@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ ENDP ; std::_Iterator012<std::random_access_iterator_tag,PushTile,int,PushTile const *,PushTile const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,PushTile,int,PushTile const *,PushTile const &,std::_Iterator_base12>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Xlen@?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Xlen@?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@IBEXXZ PROC ; std::vector<PushTile,std::allocator<PushTile> >::_Xlen, COMDAT
; _this$ = ecx

; 1764 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1765 : 		_Xlength_error("vector<T> too long");

	mov	esi, esp
	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@Xlen:

; 1766 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Xlen@?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@IBEXXZ ENDP ; std::vector<PushTile,std::allocator<PushTile> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Tidy@?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Tidy@?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@IAEXXZ PROC ; std::vector<PushTile,std::allocator<PushTile> >::_Tidy, COMDAT
; _this$ = ecx

; 1636 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1637 : 		if (this->_Myfirst() != pointer())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@std@@QAEAAPAUPushTile@@XZ ; std::_Vector_alloc<std::_Vec_base_types<PushTile,std::allocator<PushTile> > >::_Myfirst
	cmp	DWORD PTR [eax], 0
	je	$LN1@Tidy

; 1638 : 			{	// something to free, destroy and deallocate it
; 1639 : 			this->_Orphan_all();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<std::_Vec_base_types<PushTile,std::allocator<PushTile> > >::_Orphan_all

; 1640 : 			_Destroy(this->_Myfirst(), this->_Mylast());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@std@@QAEAAPAUPushTile@@XZ ; std::_Vector_alloc<std::_Vec_base_types<PushTile,std::allocator<PushTile> > >::_Mylast
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@std@@QAEAAPAUPushTile@@XZ ; std::_Vector_alloc<std::_Vec_base_types<PushTile,std::allocator<PushTile> > >::_Myfirst
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@IAEXPAUPushTile@@0@Z ; std::vector<PushTile,std::allocator<PushTile> >::_Destroy

; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myend@?$_Vector_alloc@U?$_Vec_base_types@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@std@@QAEAAPAUPushTile@@XZ ; std::_Vector_alloc<std::_Vec_base_types<PushTile,std::allocator<PushTile> > >::_Myend
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@std@@QAEAAPAUPushTile@@XZ ; std::_Vector_alloc<std::_Vec_base_types<PushTile,std::allocator<PushTile> > >::_Myfirst
	mov	ecx, DWORD PTR [esi]
	sub	ecx, DWORD PTR [eax]
	mov	eax, ecx
	cdq
	mov	ecx, 48					; 00000030H
	idiv	ecx
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@std@@QAEAAPAUPushTile@@XZ ; std::_Vector_alloc<std::_Vec_base_types<PushTile,std::allocator<PushTile> > >::_Myfirst
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<PushTile,std::allocator<PushTile> > >::_Getal
	mov	ecx, eax
	call	?deallocate@?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@std@@QAEXPAUPushTile@@I@Z ; std::_Wrap_alloc<std::allocator<PushTile> >::deallocate

; 1642 : 				this->_Myend() - this->_Myfirst());
; 1643 : 			this->_Myfirst() = pointer();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@std@@QAEAAPAUPushTile@@XZ ; std::_Vector_alloc<std::_Vec_base_types<PushTile,std::allocator<PushTile> > >::_Myfirst
	mov	DWORD PTR [eax], 0

; 1644 : 			this->_Mylast() = pointer();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@std@@QAEAAPAUPushTile@@XZ ; std::_Vector_alloc<std::_Vec_base_types<PushTile,std::allocator<PushTile> > >::_Mylast
	mov	DWORD PTR [eax], 0

; 1645 : 			this->_Myend() = pointer();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myend@?$_Vector_alloc@U?$_Vec_base_types@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@std@@QAEAAPAUPushTile@@XZ ; std::_Vector_alloc<std::_Vec_base_types<PushTile,std::allocator<PushTile> > >::_Myend
	mov	DWORD PTR [eax], 0
$LN1@Tidy:

; 1646 : 			}
; 1647 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@IAEXXZ ENDP ; std::vector<PushTile,std::allocator<PushTile> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Destroy@?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@IAEXPAUPushTile@@0@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@IAEXPAUPushTile@@0@Z PROC ; std::vector<PushTile,std::allocator<PushTile> >::_Destroy, COMDAT
; _this$ = ecx

; 1580 : 		{	// destroy [_First, _Last) using allocator

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1581 : 		_Destroy_range(_First, _Last, this->_Getal());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<PushTile,std::allocator<PushTile> > >::_Getal
	push	eax
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Destroy_range@V?$allocator@UPushTile@@@std@@PAUPushTile@@@std@@YAXPAUPushTile@@0AAU?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<PushTile>,PushTile *>
	add	esp, 12					; 0000000cH

; 1582 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?_Destroy@?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@IAEXPAUPushTile@@0@Z ENDP ; std::vector<PushTile,std::allocator<PushTile> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Buy@?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@IAE_NI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Capacity$ = 8						; size = 4
?_Buy@?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@IAE_NI@Z PROC ; std::vector<PushTile,std::allocator<PushTile> >::_Buy, COMDAT
; _this$ = ecx

; 1561 : 		{	// allocate array with _Capacity elements

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1562 : 		this->_Myfirst() = pointer();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@std@@QAEAAPAUPushTile@@XZ ; std::_Vector_alloc<std::_Vec_base_types<PushTile,std::allocator<PushTile> > >::_Myfirst
	mov	DWORD PTR [eax], 0

; 1563 : 		this->_Mylast() = pointer();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@std@@QAEAAPAUPushTile@@XZ ; std::_Vector_alloc<std::_Vec_base_types<PushTile,std::allocator<PushTile> > >::_Mylast
	mov	DWORD PTR [eax], 0

; 1564 : 		this->_Myend() = pointer();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myend@?$_Vector_alloc@U?$_Vec_base_types@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@std@@QAEAAPAUPushTile@@XZ ; std::_Vector_alloc<std::_Vec_base_types<PushTile,std::allocator<PushTile> > >::_Myend
	mov	DWORD PTR [eax], 0

; 1565 : 
; 1566 : 		if (_Capacity == 0)

	cmp	DWORD PTR __Capacity$[ebp], 0
	jne	SHORT $LN2@Buy

; 1567 : 			return (false);

	xor	al, al
	jmp	SHORT $LN6@Buy
	jmp	SHORT $LN3@Buy
$LN2@Buy:

; 1568 : 		else if (max_size() < _Capacity)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@QBEIXZ ; std::vector<PushTile,std::allocator<PushTile> >::max_size
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN4@Buy

; 1569 : 			_Xlen();	// result too long

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xlen@?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@IBEXXZ ; std::vector<PushTile,std::allocator<PushTile> >::_Xlen

; 1570 : 		else

	jmp	SHORT $LN3@Buy
$LN4@Buy:

; 1571 : 			{	// nonempty array, allocate storage
; 1572 : 			this->_Myfirst() = this->_Getal().allocate(_Capacity);

	mov	eax, DWORD PTR __Capacity$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<PushTile,std::allocator<PushTile> > >::_Getal
	mov	ecx, eax
	call	?allocate@?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@std@@QAEPAUPushTile@@I@Z ; std::_Wrap_alloc<std::allocator<PushTile> >::allocate
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@std@@QAEAAPAUPushTile@@XZ ; std::_Vector_alloc<std::_Vec_base_types<PushTile,std::allocator<PushTile> > >::_Myfirst
	mov	DWORD PTR [eax], esi

; 1573 : 			this->_Mylast() = this->_Myfirst();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@std@@QAEAAPAUPushTile@@XZ ; std::_Vector_alloc<std::_Vec_base_types<PushTile,std::allocator<PushTile> > >::_Myfirst
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@std@@QAEAAPAUPushTile@@XZ ; std::_Vector_alloc<std::_Vec_base_types<PushTile,std::allocator<PushTile> > >::_Mylast
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax], ecx

; 1574 : 			this->_Myend() = this->_Myfirst() + _Capacity;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@std@@QAEAAPAUPushTile@@XZ ; std::_Vector_alloc<std::_Vec_base_types<PushTile,std::allocator<PushTile> > >::_Myfirst
	imul	esi, DWORD PTR __Capacity$[ebp], 48
	add	esi, DWORD PTR [eax]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myend@?$_Vector_alloc@U?$_Vec_base_types@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@std@@QAEAAPAUPushTile@@XZ ; std::_Vector_alloc<std::_Vec_base_types<PushTile,std::allocator<PushTile> > >::_Myend
	mov	DWORD PTR [eax], esi
$LN3@Buy:

; 1575 : 			}
; 1576 : 		return (true);

	mov	al, 1
$LN6@Buy:

; 1577 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?_Buy@?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@IAE_NI@Z ENDP ; std::vector<PushTile,std::allocator<PushTile> >::_Buy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?max_size@?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
$T1 = -209						; size = 1
_this$ = -8						; size = 4
?max_size@?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@QBEIXZ PROC ; std::vector<PushTile,std::allocator<PushTile> >::max_size, COMDAT
; _this$ = ecx

; 1184 : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1185 : 		return (this->_Getal().max_size());

	movzx	eax, BYTE PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<PushTile,std::allocator<PushTile> > >::_Getal
	mov	ecx, eax
	call	?max_size@?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@std@@QBEIU_Nil@2@@Z ; std::_Wrap_alloc<std::allocator<PushTile> >::max_size

; 1186 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@QBEIXZ ENDP ; std::vector<PushTile,std::allocator<PushTile> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?size@?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?size@?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@QBEIXZ PROC ; std::vector<PushTile,std::allocator<PushTile> >::size, COMDAT
; _this$ = ecx

; 1179 : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@std@@QBEABQAUPushTile@@XZ ; std::_Vector_alloc<std::_Vec_base_types<PushTile,std::allocator<PushTile> > >::_Mylast
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@std@@QBEABQAUPushTile@@XZ ; std::_Vector_alloc<std::_Vec_base_types<PushTile,std::allocator<PushTile> > >::_Myfirst
	mov	ecx, DWORD PTR [esi]
	sub	ecx, DWORD PTR [eax]
	mov	eax, ecx
	cdq
	mov	ecx, 48					; 00000030H
	idiv	ecx

; 1181 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@QBEIXZ ENDP ; std::vector<PushTile,std::allocator<PushTile> >::size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?end@?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@2@XZ PROC ; std::vector<PushTile,std::allocator<PushTile> >::end, COMDAT
; _this$ = ecx

; 1072 : 		{	// return iterator for end of nonmutable sequence

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?end@?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@2@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1073 : 		return (const_iterator(this->_Mylast(), &this->_Get_data()));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<PushTile,std::allocator<PushTile> > >::_Get_data
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@std@@QBEABQAUPushTile@@XZ ; std::_Vector_alloc<std::_Vec_base_types<PushTile,std::allocator<PushTile> > >::_Mylast
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@QAE@PAUPushTile@@PBU_Container_base12@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PushTile> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PushTile> > >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1074 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?end@?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@2@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?end@?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@2@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?end@?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@2@XZ ENDP ; std::vector<PushTile,std::allocator<PushTile> >::end
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?end@?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@2@XZ PROC ; std::vector<PushTile,std::allocator<PushTile> >::end, COMDAT
; _this$ = ecx

; 1067 : 		{	// return iterator for end of mutable sequence

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?end@?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@2@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1068 : 		return (iterator(this->_Mylast(), &this->_Get_data()));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<PushTile,std::allocator<PushTile> > >::_Get_data
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@std@@QAEAAPAUPushTile@@XZ ; std::_Vector_alloc<std::_Vec_base_types<PushTile,std::allocator<PushTile> > >::_Mylast
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@QAE@PAUPushTile@@PBU_Container_base12@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<PushTile> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<PushTile> > >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1069 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?end@?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@2@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?end@?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@2@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?end@?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@2@XZ ENDP ; std::vector<PushTile,std::allocator<PushTile> >::end
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?begin@?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@2@XZ PROC ; std::vector<PushTile,std::allocator<PushTile> >::begin, COMDAT
; _this$ = ecx

; 1062 : 		{	// return iterator for beginning of nonmutable sequence

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?begin@?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@2@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1063 : 		return (const_iterator(this->_Myfirst(), &this->_Get_data()));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<PushTile,std::allocator<PushTile> > >::_Get_data
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@std@@QBEABQAUPushTile@@XZ ; std::_Vector_alloc<std::_Vec_base_types<PushTile,std::allocator<PushTile> > >::_Myfirst
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@QAE@PAUPushTile@@PBU_Container_base12@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PushTile> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PushTile> > >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1064 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?begin@?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@2@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?begin@?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@2@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?begin@?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@2@XZ ENDP ; std::vector<PushTile,std::allocator<PushTile> >::begin
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?begin@?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@2@XZ PROC ; std::vector<PushTile,std::allocator<PushTile> >::begin, COMDAT
; _this$ = ecx

; 1057 : 		{	// return iterator for beginning of mutable sequence

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?begin@?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@2@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1058 : 		return (iterator(this->_Myfirst(), &this->_Get_data()));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<PushTile,std::allocator<PushTile> > >::_Get_data
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@std@@QAEAAPAUPushTile@@XZ ; std::_Vector_alloc<std::_Vec_base_types<PushTile,std::allocator<PushTile> > >::_Myfirst
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@QAE@PAUPushTile@@PBU_Container_base12@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<PushTile> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<PushTile> > >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1059 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?begin@?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@2@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?begin@?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@2@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?begin@?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@2@XZ ENDP ; std::vector<PushTile,std::allocator<PushTile> >::begin
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??1?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@QAE@XZ PROC ; std::vector<PushTile,std::allocator<PushTile> >::~vector<PushTile,std::allocator<PushTile> >, COMDAT
; _this$ = ecx

; 975  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 976  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@IAEXXZ ; std::vector<PushTile,std::allocator<PushTile> >::_Tidy

; 977  : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Vector_alloc@U?$_Vec_base_types@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<std::_Vec_base_types<PushTile,std::allocator<PushTile> > >::~_Vector_alloc<std::_Vec_base_types<PushTile,std::allocator<PushTile> > >
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@QAE@XZ ENDP ; std::vector<PushTile,std::allocator<PushTile> >::~vector<PushTile,std::allocator<PushTile> >
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
tv132 = -280						; size = 4
tv176 = -276						; size = 4
tv173 = -272						; size = 4
$T2 = -264						; size = 4
$T3 = -252						; size = 4
$T4 = -237						; size = 1
$T5 = -225						; size = 1
_this$ = -24						; size = 4
__$EHRec$ = -16						; size = 16
__Right$ = 8						; size = 4
??0?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@QAE@ABV01@@Z PROC ; std::vector<PushTile,std::allocator<PushTile> >::vector<PushTile,std::allocator<PushTile> >, COMDAT
; _this$ = ecx

; 748  : 		{	// construct by copying _Right

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 264				; 00000108H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-280]
	mov	ecx, 66					; 00000042H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 745  : 		: _Mybase(_Right._Getal().select_on_container_copy_construction())

	movzx	eax, BYTE PTR $T5[ebp]
	push	eax
	lea	ecx, DWORD PTR $T4[ebp]
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<PushTile,std::allocator<PushTile> > >::_Getal
	mov	ecx, eax
	call	?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@std@@QBE?AU12@U_Nil@2@@Z ; std::_Wrap_alloc<std::allocator<PushTile> >::select_on_container_copy_construction
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$?0U?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@std@@X@?$_Vector_alloc@U?$_Vec_base_types@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@std@@QAE@$$QAU?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@1@@Z ; std::_Vector_alloc<std::_Vec_base_types<PushTile,std::allocator<PushTile> > >::_Vector_alloc<std::_Vec_base_types<PushTile,std::allocator<PushTile> > ><std::_Wrap_alloc<std::allocator<PushTile> >,void>
	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 749  : 		if (_Buy(_Right.size()))

	mov	ecx, DWORD PTR __Right$[ebp]
	call	?size@?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@QBEIXZ ; std::vector<PushTile,std::allocator<PushTile> >::size
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Buy@?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@IAE_NI@Z ; std::vector<PushTile,std::allocator<PushTile> >::_Buy
	movzx	eax, al
	test	eax, eax
	je	$LN1@vector

; 750  : 			_TRY_BEGIN

	mov	BYTE PTR __$EHRec$[ebp+12], 1

; 751  : 			this->_Mylast() = _Ucopy(_Right.begin(), _Right.end(),

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@std@@QAEAAPAUPushTile@@XZ ; std::_Vector_alloc<std::_Vec_base_types<PushTile,std::allocator<PushTile> > >::_Myfirst
	mov	eax, DWORD PTR [eax]
	push	eax
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T3[ebp], esp
	push	ecx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?end@?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@2@XZ ; std::vector<PushTile,std::allocator<PushTile> >::end
	mov	DWORD PTR tv173[ebp], eax
	sub	esp, 12					; 0000000cH
	mov	edx, esp
	mov	DWORD PTR $T2[ebp], esp
	push	edx
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?begin@?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@QBE?AV?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@2@XZ ; std::vector<PushTile,std::allocator<PushTile> >::begin
	mov	DWORD PTR tv176[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Ucopy@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@@?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@IAEPAUPushTile@@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@1@0PAU2@@Z ; std::vector<PushTile,std::allocator<PushTile> >::_Ucopy<std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PushTile> > > >
	mov	DWORD PTR tv132[ebp], eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@std@@QAEAAPAUPushTile@@XZ ; std::_Vector_alloc<std::_Vec_base_types<PushTile,std::allocator<PushTile> > >::_Mylast
	mov	ecx, DWORD PTR tv132[ebp]
	mov	DWORD PTR [eax], ecx
	jmp	SHORT $LN5@vector
__catch$??0?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@QAE@ABV01@@Z$0:

; 752  : 				this->_Myfirst());
; 753  : 			_CATCH_ALL
; 754  : 			_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@IAEXXZ ; std::vector<PushTile,std::allocator<PushTile> >::_Tidy

; 755  : 			_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 756  : 			_CATCH_END

	mov	eax, $LN11@vector
	ret	0
$LN5@vector:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
	jmp	SHORT $LN1@vector
$LN11@vector:
	mov	DWORD PTR __$EHRec$[ebp+12], 0
$LN1@vector:

; 757  : 		}

	mov	DWORD PTR __$EHRec$[ebp+12], -1
	mov	eax, DWORD PTR _this$[ebp]
$LN4@vector:
	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 280				; 00000118H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@QAE@ABV01@@Z$2:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Vector_alloc@U?$_Vec_base_types@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<std::_Vec_base_types<PushTile,std::allocator<PushTile> > >::~_Vector_alloc<std::_Vec_base_types<PushTile,std::allocator<PushTile> > >
__ehhandler$??0?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@QAE@ABV01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-284]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@QAE@ABV01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::vector<PushTile,std::allocator<PushTile> >::vector<PushTile,std::allocator<PushTile> >
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@2@$00@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@2@$00@std@@QAE@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<PushTile> >,std::_Vector_val<std::_Simple_types<PushTile> >,1>::~_Compressed_pair<std::_Wrap_alloc<std::allocator<PushTile> >,std::_Vector_val<std::_Simple_types<PushTile> >,1>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@QAE@XZ
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@2@$00@std@@QAE@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<PushTile> >,std::_Vector_val<std::_Simple_types<PushTile> >,1>::~_Compressed_pair<std::_Wrap_alloc<std::allocator<PushTile> >,std::_Vector_val<std::_Simple_types<PushTile> >,1>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<PushTile> >,std::_Vector_val<std::_Simple_types<PushTile> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 319  : 		{	// return const reference to second

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 320  : 		return (_Myval2);

	mov	eax, DWORD PTR _this$[ebp]

; 321  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<PushTile> >,std::_Vector_val<std::_Simple_types<PushTile> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<PushTile> >,std::_Vector_val<std::_Simple_types<PushTile> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 314  : 		{	// return reference to second

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 315  : 		return (_Myval2);

	mov	eax, DWORD PTR _this$[ebp]

; 316  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<PushTile> >,std::_Vector_val<std::_Simple_types<PushTile> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<PushTile> >,std::_Vector_val<std::_Simple_types<PushTile> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 299  : 		{	// return const reference to first

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 300  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 301  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<PushTile> >,std::_Vector_val<std::_Simple_types<PushTile> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<PushTile> >,std::_Vector_val<std::_Simple_types<PushTile> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 294  : 		{	// return reference to first

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 295  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 296  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<PushTile> >,std::_Vector_val<std::_Simple_types<PushTile> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<PushTile> >::~_Vector_val<std::_Simple_types<PushTile> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Container_base12@std@@QAE@XZ	; std::_Container_base12::~_Container_base12
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<PushTile> >::~_Vector_val<std::_Simple_types<PushTile> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<PushTile> >::_Vector_val<std::_Simple_types<PushTile> >, COMDAT
; _this$ = ecx

; 488  : 		{	// initialize values

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Container_base12@std@@QAE@XZ	; std::_Container_base12::_Container_base12

; 485  : 		: _Myfirst(),

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 486  : 		_Mylast(),

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 487  : 		_Myend()

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0

; 489  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<PushTile> >::_Vector_val<std::_Simple_types<PushTile> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@std@@QAEAAPAUPushTile@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@std@@QAEAAPAUPushTile@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<PushTile,std::allocator<PushTile> > >::_Myend, COMDAT
; _this$ = ecx

; 662  : 		{	// return reference to _Myend

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 663  : 		return (_Get_data()._Myend);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<PushTile,std::allocator<PushTile> > >::_Get_data
	add	eax, 12					; 0000000cH

; 664  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@std@@QAEAAPAUPushTile@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<PushTile,std::allocator<PushTile> > >::_Myend
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@std@@QBEABQAUPushTile@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@std@@QBEABQAUPushTile@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<PushTile,std::allocator<PushTile> > >::_Mylast, COMDAT
; _this$ = ecx

; 657  : 		{	// return const reference to _Mylast

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 658  : 		return (_Get_data()._Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<PushTile,std::allocator<PushTile> > >::_Get_data
	add	eax, 8

; 659  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@std@@QBEABQAUPushTile@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<PushTile,std::allocator<PushTile> > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@std@@QAEAAPAUPushTile@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@std@@QAEAAPAUPushTile@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<PushTile,std::allocator<PushTile> > >::_Mylast, COMDAT
; _this$ = ecx

; 652  : 		{	// return reference to _Mylast

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 653  : 		return (_Get_data()._Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<PushTile,std::allocator<PushTile> > >::_Get_data
	add	eax, 8

; 654  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@std@@QAEAAPAUPushTile@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<PushTile,std::allocator<PushTile> > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@std@@QBEABQAUPushTile@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@std@@QBEABQAUPushTile@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<PushTile,std::allocator<PushTile> > >::_Myfirst, COMDAT
; _this$ = ecx

; 647  : 		{	// return const reference to _Myfirst

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 648  : 		return (_Get_data()._Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<PushTile,std::allocator<PushTile> > >::_Get_data
	add	eax, 4

; 649  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@std@@QBEABQAUPushTile@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<PushTile,std::allocator<PushTile> > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@std@@QAEAAPAUPushTile@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@std@@QAEAAPAUPushTile@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<PushTile,std::allocator<PushTile> > >::_Myfirst, COMDAT
; _this$ = ecx

; 642  : 		{	// return reference to _Myfirst

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 643  : 		return (_Get_data()._Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<PushTile,std::allocator<PushTile> > >::_Get_data
	add	eax, 4

; 644  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@std@@QAEAAPAUPushTile@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<PushTile,std::allocator<PushTile> > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<PushTile,std::allocator<PushTile> > >::_Get_data, COMDAT
; _this$ = ecx

; 637  : 		{	// return const reference to _Vector_val

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 638  : 		return (_Mypair._Get_second());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<PushTile> >,std::_Vector_val<std::_Simple_types<PushTile> >,1>::_Get_second

; 639  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<PushTile,std::allocator<PushTile> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<PushTile,std::allocator<PushTile> > >::_Get_data, COMDAT
; _this$ = ecx

; 632  : 		{	// return reference to _Vector_val

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 633  : 		return (_Mypair._Get_second());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<PushTile> >,std::_Vector_val<std::_Simple_types<PushTile> >,1>::_Get_second

; 634  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<PushTile,std::allocator<PushTile> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<PushTile,std::allocator<PushTile> > >::_Getal, COMDAT
; _this$ = ecx

; 627  : 		{	// return const reference to allocator

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 628  : 		return (_Mypair._Get_first());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<PushTile> >,std::_Vector_val<std::_Simple_types<PushTile> >,1>::_Get_first

; 629  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<PushTile,std::allocator<PushTile> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<PushTile,std::allocator<PushTile> > >::_Getal, COMDAT
; _this$ = ecx

; 622  : 		{	// return reference to allocator

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 623  : 		return (_Mypair._Get_first());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<PushTile> >,std::_Vector_val<std::_Simple_types<PushTile> >,1>::_Get_first

; 624  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<PushTile,std::allocator<PushTile> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@std@@QAEXXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<PushTile,std::allocator<PushTile> > >::_Orphan_all, COMDAT
; _this$ = ecx

; 612  : 		{	// orphan all iterators

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 613  : 		_Get_data()._Orphan_all();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<PushTile,std::allocator<PushTile> > >::_Get_data
	mov	ecx, eax
	call	?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all

; 614  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@std@@QAEXXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<PushTile,std::allocator<PushTile> > >::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myproxy@?$_Vector_alloc@U?$_Vec_base_types@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Myproxy@?$_Vector_alloc@U?$_Vec_base_types@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<PushTile,std::allocator<PushTile> > >::_Myproxy, COMDAT
; _this$ = ecx

; 601  : 		{	// return reference to _Myproxy

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 602  : 		return (_Get_data()._Myproxy);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<PushTile,std::allocator<PushTile> > >::_Get_data

; 603  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Myproxy@?$_Vector_alloc@U?$_Vec_base_types@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<PushTile,std::allocator<PushTile> > >::_Myproxy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Free_proxy@?$_Vector_alloc@U?$_Vec_base_types@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__Alproxy$ = -21					; size = 1
_this$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
?_Free_proxy@?$_Vector_alloc@U?$_Vec_base_types@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@std@@QAEXXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<PushTile,std::allocator<PushTile> > >::_Free_proxy, COMDAT
; _this$ = ecx

; 586  : 		{	// destroy proxy

	push	ebp
	mov	ebp, esp
	sub	esp, 220				; 000000dcH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-220]
	mov	ecx, 55					; 00000037H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 587  : 		typename _Alty::template rebind<_Container_proxy>::other
; 588  : 			_Alproxy(_Getal());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<PushTile,std::allocator<PushTile> > >::_Getal
	push	eax
	lea	ecx, DWORD PTR __Alproxy$[ebp]
	call	??$?0AAU?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAU?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::_Wrap_alloc<std::allocator<std::_Container_proxy> ><std::_Wrap_alloc<std::allocator<PushTile> > &>

; 589  : 		_Orphan_all();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<std::_Vec_base_types<PushTile,std::allocator<PushTile> > >::_Orphan_all

; 590  : 		_Alproxy.destroy(_Myproxy());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myproxy@?$_Vector_alloc@U?$_Vec_base_types@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<PushTile,std::allocator<PushTile> > >::_Myproxy
	mov	eax, DWORD PTR [eax]
	push	eax
	lea	ecx, DWORD PTR __Alproxy$[ebp]
	call	??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::destroy<std::_Container_proxy>

; 591  : 		_Alproxy.deallocate(_Alproxy.address(*_Myproxy()), 1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myproxy@?$_Vector_alloc@U?$_Vec_base_types@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<PushTile,std::allocator<PushTile> > >::_Myproxy
	mov	eax, DWORD PTR [eax]
	push	eax
	lea	ecx, DWORD PTR __Alproxy$[ebp]
	call	?address@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QBEPAU_Container_proxy@2@AAU32@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::address
	push	eax
	lea	ecx, DWORD PTR __Alproxy$[ebp]
	call	?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::deallocate

; 592  : 		_Myproxy() = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myproxy@?$_Vector_alloc@U?$_Vec_base_types@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<PushTile,std::allocator<PushTile> > >::_Myproxy
	mov	DWORD PTR [eax], 0

; 593  : 		}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@Free_proxy
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 220				; 000000dcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@Free_proxy:
	DD	1
	DD	$LN4@Free_proxy
$LN4@Free_proxy:
	DD	-21					; ffffffebH
	DD	1
	DD	$LN3@Free_proxy
$LN3@Free_proxy:
	DB	95					; 0000005fH
	DB	65					; 00000041H
	DB	108					; 0000006cH
	DB	112					; 00000070H
	DB	114					; 00000072H
	DB	111					; 0000006fH
	DB	120					; 00000078H
	DB	121					; 00000079H
	DB	0
?_Free_proxy@?$_Vector_alloc@U?$_Vec_base_types@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@std@@QAEXXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<PushTile,std::allocator<PushTile> > >::_Free_proxy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Alloc_proxy@?$_Vector_alloc@U?$_Vec_base_types@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T1 = -232						; size = 8
__Alproxy$ = -21					; size = 1
_this$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
?_Alloc_proxy@?$_Vector_alloc@U?$_Vec_base_types@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@std@@QAEXXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<PushTile,std::allocator<PushTile> > >::_Alloc_proxy, COMDAT
; _this$ = ecx

; 577  : 		{	// construct proxy

	push	ebp
	mov	ebp, esp
	sub	esp, 236				; 000000ecH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-236]
	mov	ecx, 59					; 0000003bH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 578  : 		typename _Alty::template rebind<_Container_proxy>::other
; 579  : 			_Alproxy(_Getal());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<PushTile,std::allocator<PushTile> > >::_Getal
	push	eax
	lea	ecx, DWORD PTR __Alproxy$[ebp]
	call	??$?0AAU?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAU?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::_Wrap_alloc<std::allocator<std::_Container_proxy> ><std::_Wrap_alloc<std::allocator<PushTile> > &>

; 580  : 		_Myproxy() = _Unfancy(_Alproxy.allocate(1));

	push	1
	lea	ecx, DWORD PTR __Alproxy$[ebp]
	call	?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::allocate
	push	eax
	call	??$_Unfancy@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@PAU10@@Z ; std::_Unfancy<std::_Container_proxy>
	add	esp, 4
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myproxy@?$_Vector_alloc@U?$_Vec_base_types@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<PushTile,std::allocator<PushTile> > >::_Myproxy
	mov	DWORD PTR [eax], esi

; 581  : 		_Alproxy.construct(_Myproxy(), _Container_proxy());

	lea	ecx, DWORD PTR $T1[ebp]
	call	??0_Container_proxy@std@@QAE@XZ		; std::_Container_proxy::_Container_proxy
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myproxy@?$_Vector_alloc@U?$_Vec_base_types@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<PushTile,std::allocator<PushTile> > >::_Myproxy
	mov	eax, DWORD PTR [eax]
	push	eax
	lea	ecx, DWORD PTR __Alproxy$[ebp]
	call	??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::construct<std::_Container_proxy,std::_Container_proxy>

; 582  : 		_Myproxy()->_Mycont = &_Get_data();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<PushTile,std::allocator<PushTile> > >::_Get_data
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myproxy@?$_Vector_alloc@U?$_Vec_base_types@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<PushTile,std::allocator<PushTile> > >::_Myproxy
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [eax], esi

; 583  : 		}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@Alloc_prox
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 236				; 000000ecH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN5@Alloc_prox:
	DD	1
	DD	$LN4@Alloc_prox
$LN4@Alloc_prox:
	DD	-21					; ffffffebH
	DD	1
	DD	$LN3@Alloc_prox
$LN3@Alloc_prox:
	DB	95					; 0000005fH
	DB	65					; 00000041H
	DB	108					; 0000006cH
	DB	112					; 00000070H
	DB	114					; 00000072H
	DB	111					; 0000006fH
	DB	120					; 00000078H
	DB	121					; 00000079H
	DB	0
?_Alloc_proxy@?$_Vector_alloc@U?$_Vec_base_types@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@std@@QAEXXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<PushTile,std::allocator<PushTile> > >::_Alloc_proxy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??1?$_Vector_alloc@U?$_Vec_base_types@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Vector_alloc@U?$_Vec_base_types@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<PushTile,std::allocator<PushTile> > >::~_Vector_alloc<std::_Vec_base_types<PushTile,std::allocator<PushTile> > >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy proxy

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Vector_alloc@U?$_Vec_base_types@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 559  : 		_Free_proxy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Free_proxy@?$_Vector_alloc@U?$_Vec_base_types@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<std::_Vec_base_types<PushTile,std::allocator<PushTile> > >::_Free_proxy

; 560  : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@2@$00@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$_Vector_alloc@U?$_Vec_base_types@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Vector_alloc@U?$_Vec_base_types@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Vector_alloc@U?$_Vec_base_types@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<PushTile,std::allocator<PushTile> > >::~_Vector_alloc<std::_Vec_base_types<PushTile,std::allocator<PushTile> > >
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@std@@QBEIU_Nil@2@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___formal$ = 8						; size = 1
?max_size@?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@std@@QBEIU_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<PushTile> >::max_size, COMDAT
; _this$ = ecx

; 1007 : 		{	// get maximum size

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1008 : 		return (_Mytraits::max_size(*this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?max_size@?$allocator_traits@V?$allocator@UPushTile@@@std@@@std@@SAIABV?$allocator@UPushTile@@@2@@Z ; std::allocator_traits<std::allocator<PushTile> >::max_size
	add	esp, 4

; 1009 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?max_size@?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@std@@QBEIU_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<PushTile> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@std@@QAEXPAUPushTile@@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@std@@QAEXPAUPushTile@@I@Z PROC ; std::_Wrap_alloc<std::allocator<PushTile> >::deallocate, COMDAT
; _this$ = ecx

; 986  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 987  : 		_Mybase::deallocate(_Ptr, _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?deallocate@?$allocator@UPushTile@@@std@@QAEXPAUPushTile@@I@Z ; std::allocator<PushTile>::deallocate

; 988  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@std@@QAEXPAUPushTile@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<PushTile> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@std@@QAEPAUPushTile@@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@std@@QAEPAUPushTile@@I@Z PROC ; std::_Wrap_alloc<std::allocator<PushTile> >::allocate, COMDAT
; _this$ = ecx

; 975  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 976  : 		return (_Mybase::allocate(_Count));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?allocate@?$allocator@UPushTile@@@std@@QAEPAUPushTile@@I@Z ; std::allocator<PushTile>::allocate

; 977  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@std@@QAEPAUPushTile@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<PushTile> >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@std@@QAE@$$QAU01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
??0?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@std@@QAE@$$QAU01@@Z PROC ; std::_Wrap_alloc<std::allocator<PushTile> >::_Wrap_alloc<std::allocator<PushTile> >, COMDAT
; _this$ = ecx

; 946  : 		{	// construct by moving

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 945  : 		: _Mybase(_STD move(_Right))

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	call	??$move@AAU?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@std@@@std@@YA$$QAU?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@0@AAU10@@Z ; std::move<std::_Wrap_alloc<std::allocator<PushTile> > &>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$allocator@UPushTile@@@std@@QAE@ABV01@@Z ; std::allocator<PushTile>::allocator<PushTile>

; 947  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@std@@QAE@$$QAU01@@Z ENDP ; std::_Wrap_alloc<std::allocator<PushTile> >::_Wrap_alloc<std::allocator<PushTile> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@std@@QBE?AU12@U_Nil@2@@Z
_TEXT	SEGMENT
$T1 = -209						; size = 1
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
___formal$ = 12						; size = 1
?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@std@@QBE?AU12@U_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<PushTile> >::select_on_container_copy_construction, COMDAT
; _this$ = ecx

; 912  : 		{	// get allocator to use

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 913  : 		return (_Mytraits::select_on_container_copy_construction(*this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	lea	ecx, DWORD PTR $T1[ebp]
	push	ecx
	call	?select_on_container_copy_construction@?$allocator_traits@V?$allocator@UPushTile@@@std@@@std@@SA?AV?$allocator@UPushTile@@@2@ABV32@@Z ; std::allocator_traits<std::allocator<PushTile> >::select_on_container_copy_construction
	add	esp, 8
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??$?0V?$allocator@UPushTile@@@std@@@?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@std@@QAE@$$QAV?$allocator@UPushTile@@@1@@Z ; std::_Wrap_alloc<std::allocator<PushTile> >::_Wrap_alloc<std::allocator<PushTile> ><std::allocator<PushTile> >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 914  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?select_on_container_copy_construction@?$_Wrap_alloc@V?$allocator@UPushTile@@@std@@@std@@QBE?AU12@U_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<PushTile> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$allocator_traits@V?$allocator@UPushTile@@@std@@@std@@SA?AV?$allocator@UPushTile@@@2@ABV32@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
__Al$ = 12						; size = 4
?select_on_container_copy_construction@?$allocator_traits@V?$allocator@UPushTile@@@std@@@std@@SA?AV?$allocator@UPushTile@@@2@ABV32@@Z PROC ; std::allocator_traits<std::allocator<PushTile> >::select_on_container_copy_construction, COMDAT

; 874  : 		{	// get allocator to use

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 875  : 		return (_Al);

	mov	eax, DWORD PTR __Al$[ebp]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$allocator@UPushTile@@@std@@QAE@ABV01@@Z ; std::allocator<PushTile>::allocator<PushTile>
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 876  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?select_on_container_copy_construction@?$allocator_traits@V?$allocator@UPushTile@@@std@@@std@@SA?AV?$allocator@UPushTile@@@2@ABV32@@Z ENDP ; std::allocator_traits<std::allocator<PushTile> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@UPushTile@@@std@@@std@@SAIABV?$allocator@UPushTile@@@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@UPushTile@@@std@@@std@@SAIABV?$allocator@UPushTile@@@2@@Z PROC ; std::allocator_traits<std::allocator<PushTile> >::max_size, COMDAT

; 868  : 		{	// get maximum size

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 869  : 		return (_Al.max_size());

	mov	ecx, DWORD PTR __Al$[ebp]
	call	?max_size@?$allocator@UPushTile@@@std@@QBEIXZ ; std::allocator<PushTile>::max_size

; 870  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator_traits@V?$allocator@UPushTile@@@std@@@std@@SAIABV?$allocator@UPushTile@@@2@@Z ENDP ; std::allocator_traits<std::allocator<PushTile> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@UPushTile@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?max_size@?$allocator@UPushTile@@@std@@QBEIXZ PROC	; std::allocator<PushTile>::max_size, COMDAT
; _this$ = ecx

; 748  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 749  : 		return ((size_t)(-1) / sizeof (_Ty));

	mov	eax, 89478485				; 05555555H

; 750  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@UPushTile@@@std@@QBEIXZ ENDP	; std::allocator<PushTile>::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@UPushTile@@@std@@QAEPAUPushTile@@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@UPushTile@@@std@@QAEPAUPushTile@@I@Z PROC ; std::allocator<PushTile>::allocate, COMDAT
; _this$ = ecx

; 724  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

	push	1
	push	48					; 00000030H
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	?_Allocate@std@@YAPAXII_N@Z		; std::_Allocate
	add	esp, 12					; 0000000cH

; 726  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@UPushTile@@@std@@QAEPAUPushTile@@I@Z ENDP ; std::allocator<PushTile>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@UPushTile@@@std@@QAEXPAUPushTile@@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@UPushTile@@@std@@QAEXPAUPushTile@@I@Z PROC ; std::allocator<PushTile>::deallocate, COMDAT
; _this$ = ecx

; 719  : 		{	// deallocate object at _Ptr

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	48					; 00000030H
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH

; 721  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@UPushTile@@@std@@QAEXPAUPushTile@@I@Z ENDP ; std::allocator<PushTile>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@UPushTile@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___formal$ = 8						; size = 4
??0?$allocator@UPushTile@@@std@@QAE@ABV01@@Z PROC	; std::allocator<PushTile>::allocator<PushTile>, COMDAT
; _this$ = ecx

; 703  : 	allocator(const allocator<_Ty>&) _THROW0()

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 704  : 		{	// construct by copying (do nothing)
; 705  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$allocator@UPushTile@@@std@@QAE@ABV01@@Z ENDP	; std::allocator<PushTile>::allocator<PushTile>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File g:\projects\lotion\lotion\environment.h
;	COMDAT ?GetDirection@PushTile@@QAEHV?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@Z
_TEXT	SEGMENT
$T2 = -436						; size = 4
$T3 = -424						; size = 4
$T4 = -412						; size = 4
$T5 = -400						; size = 4
$T6 = -388						; size = 4
$T7 = -376						; size = 4
$T8 = -364						; size = 4
$T9 = -352						; size = 4
$T10 = -340						; size = 4
$T11 = -328						; size = 4
$T12 = -316						; size = 4
$T13 = -304						; size = 4
$T14 = -292						; size = 4
_otherTile$15 = -88					; size = 4
_<end>$L0$16 = -76					; size = 12
_<begin>$L0$17 = -56					; size = 12
_<range>$L0$18 = -36					; size = 4
_this$ = -24						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_tileMap$ = 8						; size = 16
?GetDirection@PushTile@@QAEHV?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@Z PROC ; PushTile::GetDirection, COMDAT
; _this$ = ecx

; 105  : 	inline int GetDirection(std::vector<PushTile> tileMap) {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?GetDirection@PushTile@@QAEHV?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 428				; 000001acH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-440]
	mov	ecx, 107				; 0000006bH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 106  : 		for (auto &otherTile : tileMap) {

	lea	eax, DWORD PTR _tileMap$[ebp]
	mov	DWORD PTR _<range>$L0$18[ebp], eax
	push	12					; 0000000cH
	lea	ecx, DWORD PTR _<begin>$L0$17[ebp]
	call	?__autoclassinit2@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@QAEXI@Z
	lea	eax, DWORD PTR _<begin>$L0$17[ebp]
	push	eax
	mov	ecx, DWORD PTR _<range>$L0$18[ebp]
	call	?begin@?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@2@XZ ; std::vector<PushTile,std::allocator<PushTile> >::begin
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	push	12					; 0000000cH
	lea	ecx, DWORD PTR _<end>$L0$16[ebp]
	call	?__autoclassinit2@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@QAEXI@Z
	lea	eax, DWORD PTR _<end>$L0$16[ebp]
	push	eax
	mov	ecx, DWORD PTR _<range>$L0$18[ebp]
	call	?end@?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@2@XZ ; std::vector<PushTile,std::allocator<PushTile> >::end
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	jmp	SHORT $LN4@GetDirecti
$LN2@GetDirecti:
	lea	ecx, DWORD PTR _<begin>$L0$17[ebp]
	call	??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<PushTile> > >::operator++
$LN4@GetDirecti:
	lea	eax, DWORD PTR _<end>$L0$16[ebp]
	push	eax
	lea	ecx, DWORD PTR _<begin>$L0$17[ebp]
	call	??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<PushTile> > >::operator!=
	movzx	ecx, al
	test	ecx, ecx
	je	$LN3@GetDirecti
	lea	ecx, DWORD PTR _<begin>$L0$17[ebp]
	call	??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@QBEAAUPushTile@@XZ ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<PushTile> > >::operator*
	mov	DWORD PTR _otherTile$15[ebp], eax

; 107  : 			//othertile = left
; 108  : 			if (otherTile.tile.position.x == (tile.position.x - tile.width) && (otherTile.tile.position.y == tile.position.y)) {

	mov	eax, DWORD PTR _this$[ebp]
	cvtsi2sd xmm0, DWORD PTR [eax+16]
	mov	ecx, DWORD PTR _this$[ebp]
	movsd	xmm1, QWORD PTR [ecx]
	subsd	xmm1, xmm0
	mov	edx, DWORD PTR _otherTile$15[ebp]
	movsd	xmm0, QWORD PTR [edx]
	ucomisd	xmm0, xmm1
	lahf
	test	ah, 68					; 00000044H
	jp	$LN8@GetDirecti
	mov	eax, DWORD PTR _otherTile$15[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movsd	xmm0, QWORD PTR [eax+8]
	ucomisd	xmm0, QWORD PTR [ecx+8]
	lahf
	test	ah, 68					; 00000044H
	jp	$LN8@GetDirecti

; 109  : 				if (end == true) return 2;

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+44]
	cmp	ecx, 1
	jne	SHORT $LN6@GetDirecti
	mov	DWORD PTR $T14[ebp], 2
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _<end>$L0$16[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _<begin>$L0$17[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tileMap$[ebp]
	call	??1?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@QAE@XZ ; std::vector<PushTile,std::allocator<PushTile> >::~vector<PushTile,std::allocator<PushTile> >
	mov	eax, DWORD PTR $T14[ebp]
	jmp	$LN1@GetDirecti
$LN6@GetDirecti:

; 110  : 				otherTile.initialDirection = 2;

	mov	eax, DWORD PTR _otherTile$15[ebp]
	mov	DWORD PTR [eax+40], 2

; 111  : 				if (initialDirection == -1) return 3;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+40], -1
	jne	SHORT $LN7@GetDirecti
	mov	DWORD PTR $T13[ebp], 3
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _<end>$L0$16[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _<begin>$L0$17[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tileMap$[ebp]
	call	??1?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@QAE@XZ ; std::vector<PushTile,std::allocator<PushTile> >::~vector<PushTile,std::allocator<PushTile> >
	mov	eax, DWORD PTR $T13[ebp]
	jmp	$LN1@GetDirecti
$LN7@GetDirecti:

; 112  : 				if (initialDirection != 2) return 3;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+40], 2
	je	SHORT $LN8@GetDirecti
	mov	DWORD PTR $T12[ebp], 3
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _<end>$L0$16[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _<begin>$L0$17[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tileMap$[ebp]
	call	??1?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@QAE@XZ ; std::vector<PushTile,std::allocator<PushTile> >::~vector<PushTile,std::allocator<PushTile> >
	mov	eax, DWORD PTR $T12[ebp]
	jmp	$LN1@GetDirecti
$LN8@GetDirecti:

; 113  : 			}
; 114  : 			//othertile = right
; 115  : 			if (otherTile.tile.position.x == (tile.position.x + tile.width) && (otherTile.tile.position.y == tile.position.y)) {

	mov	eax, DWORD PTR _this$[ebp]
	cvtsi2sd xmm0, DWORD PTR [eax+16]
	mov	ecx, DWORD PTR _this$[ebp]
	addsd	xmm0, QWORD PTR [ecx]
	mov	edx, DWORD PTR _otherTile$15[ebp]
	movsd	xmm1, QWORD PTR [edx]
	ucomisd	xmm1, xmm0
	lahf
	test	ah, 68					; 00000044H
	jp	$LN12@GetDirecti
	mov	eax, DWORD PTR _otherTile$15[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movsd	xmm0, QWORD PTR [eax+8]
	ucomisd	xmm0, QWORD PTR [ecx+8]
	lahf
	test	ah, 68					; 00000044H
	jp	$LN12@GetDirecti

; 116  : 				if (end == true) return 3;

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+44]
	cmp	ecx, 1
	jne	SHORT $LN10@GetDirecti
	mov	DWORD PTR $T11[ebp], 3
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _<end>$L0$16[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _<begin>$L0$17[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tileMap$[ebp]
	call	??1?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@QAE@XZ ; std::vector<PushTile,std::allocator<PushTile> >::~vector<PushTile,std::allocator<PushTile> >
	mov	eax, DWORD PTR $T11[ebp]
	jmp	$LN1@GetDirecti
$LN10@GetDirecti:

; 117  : 				otherTile.initialDirection = 3;

	mov	eax, DWORD PTR _otherTile$15[ebp]
	mov	DWORD PTR [eax+40], 3

; 118  : 				if (initialDirection == -1) return 2;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+40], -1
	jne	SHORT $LN11@GetDirecti
	mov	DWORD PTR $T10[ebp], 2
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _<end>$L0$16[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _<begin>$L0$17[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tileMap$[ebp]
	call	??1?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@QAE@XZ ; std::vector<PushTile,std::allocator<PushTile> >::~vector<PushTile,std::allocator<PushTile> >
	mov	eax, DWORD PTR $T10[ebp]
	jmp	$LN1@GetDirecti
$LN11@GetDirecti:

; 119  : 				if (initialDirection != 3) return 2;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+40], 3
	je	SHORT $LN12@GetDirecti
	mov	DWORD PTR $T9[ebp], 2
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _<end>$L0$16[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _<begin>$L0$17[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tileMap$[ebp]
	call	??1?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@QAE@XZ ; std::vector<PushTile,std::allocator<PushTile> >::~vector<PushTile,std::allocator<PushTile> >
	mov	eax, DWORD PTR $T9[ebp]
	jmp	$LN1@GetDirecti
$LN12@GetDirecti:

; 120  : 			}
; 121  : 			//othertile = down
; 122  : 			if (otherTile.tile.position.y == (tile.position.y - tile.height) && (otherTile.tile.position.x == tile.position.x)) {

	mov	eax, DWORD PTR _this$[ebp]
	cvtsi2sd xmm0, DWORD PTR [eax+20]
	mov	ecx, DWORD PTR _this$[ebp]
	movsd	xmm1, QWORD PTR [ecx+8]
	subsd	xmm1, xmm0
	mov	edx, DWORD PTR _otherTile$15[ebp]
	movsd	xmm0, QWORD PTR [edx+8]
	ucomisd	xmm0, xmm1
	lahf
	test	ah, 68					; 00000044H
	jp	$LN16@GetDirecti
	mov	eax, DWORD PTR _otherTile$15[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movsd	xmm0, QWORD PTR [eax]
	ucomisd	xmm0, QWORD PTR [ecx]
	lahf
	test	ah, 68					; 00000044H
	jp	$LN16@GetDirecti

; 123  : 				if (end == true) return 0;

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+44]
	cmp	ecx, 1
	jne	SHORT $LN14@GetDirecti
	mov	DWORD PTR $T8[ebp], 0
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _<end>$L0$16[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _<begin>$L0$17[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tileMap$[ebp]
	call	??1?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@QAE@XZ ; std::vector<PushTile,std::allocator<PushTile> >::~vector<PushTile,std::allocator<PushTile> >
	mov	eax, DWORD PTR $T8[ebp]
	jmp	$LN1@GetDirecti
$LN14@GetDirecti:

; 124  : 				otherTile.initialDirection = 0;

	mov	eax, DWORD PTR _otherTile$15[ebp]
	mov	DWORD PTR [eax+40], 0

; 125  : 				if (initialDirection == -1) return 1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+40], -1
	jne	SHORT $LN15@GetDirecti
	mov	DWORD PTR $T7[ebp], 1
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _<end>$L0$16[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _<begin>$L0$17[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tileMap$[ebp]
	call	??1?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@QAE@XZ ; std::vector<PushTile,std::allocator<PushTile> >::~vector<PushTile,std::allocator<PushTile> >
	mov	eax, DWORD PTR $T7[ebp]
	jmp	$LN1@GetDirecti
$LN15@GetDirecti:

; 126  : 				if (initialDirection != 0) return 1;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+40], 0
	je	SHORT $LN16@GetDirecti
	mov	DWORD PTR $T6[ebp], 1
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _<end>$L0$16[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _<begin>$L0$17[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tileMap$[ebp]
	call	??1?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@QAE@XZ ; std::vector<PushTile,std::allocator<PushTile> >::~vector<PushTile,std::allocator<PushTile> >
	mov	eax, DWORD PTR $T6[ebp]
	jmp	$LN1@GetDirecti
$LN16@GetDirecti:

; 127  : 			}
; 128  : 			//othertile = up
; 129  : 			if (otherTile.tile.position.y == (tile.position.y + tile.height) && (otherTile.tile.position.x == tile.position.x)) {

	mov	eax, DWORD PTR _this$[ebp]
	cvtsi2sd xmm0, DWORD PTR [eax+20]
	mov	ecx, DWORD PTR _this$[ebp]
	addsd	xmm0, QWORD PTR [ecx+8]
	mov	edx, DWORD PTR _otherTile$15[ebp]
	movsd	xmm1, QWORD PTR [edx+8]
	ucomisd	xmm1, xmm0
	lahf
	test	ah, 68					; 00000044H
	jp	$LN20@GetDirecti
	mov	eax, DWORD PTR _otherTile$15[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	movsd	xmm0, QWORD PTR [eax]
	ucomisd	xmm0, QWORD PTR [ecx]
	lahf
	test	ah, 68					; 00000044H
	jp	$LN20@GetDirecti

; 130  : 				if (end == true) return 1;

	mov	eax, DWORD PTR _this$[ebp]
	movzx	ecx, BYTE PTR [eax+44]
	cmp	ecx, 1
	jne	SHORT $LN18@GetDirecti
	mov	DWORD PTR $T5[ebp], 1
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _<end>$L0$16[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _<begin>$L0$17[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tileMap$[ebp]
	call	??1?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@QAE@XZ ; std::vector<PushTile,std::allocator<PushTile> >::~vector<PushTile,std::allocator<PushTile> >
	mov	eax, DWORD PTR $T5[ebp]
	jmp	$LN1@GetDirecti
$LN18@GetDirecti:

; 131  : 				otherTile.initialDirection = 1;

	mov	eax, DWORD PTR _otherTile$15[ebp]
	mov	DWORD PTR [eax+40], 1

; 132  : 				if (initialDirection == -1) return 0;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+40], -1
	jne	SHORT $LN19@GetDirecti
	mov	DWORD PTR $T4[ebp], 0
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _<end>$L0$16[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _<begin>$L0$17[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tileMap$[ebp]
	call	??1?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@QAE@XZ ; std::vector<PushTile,std::allocator<PushTile> >::~vector<PushTile,std::allocator<PushTile> >
	mov	eax, DWORD PTR $T4[ebp]
	jmp	SHORT $LN1@GetDirecti
$LN19@GetDirecti:

; 133  : 				if (initialDirection != 1) return 0;

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+40], 1
	je	SHORT $LN20@GetDirecti
	mov	DWORD PTR $T3[ebp], 0
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _<end>$L0$16[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _<begin>$L0$17[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tileMap$[ebp]
	call	??1?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@QAE@XZ ; std::vector<PushTile,std::allocator<PushTile> >::~vector<PushTile,std::allocator<PushTile> >
	mov	eax, DWORD PTR $T3[ebp]
	jmp	SHORT $LN1@GetDirecti
$LN20@GetDirecti:

; 134  : 			}

	jmp	$LN2@GetDirecti
$LN3@GetDirecti:

; 135  : 		}

	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR _<end>$L0$16[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR _<begin>$L0$17[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@QAE@XZ

; 136  : 
; 137  : 		return -1;

	mov	DWORD PTR $T2[ebp], -1
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR _tileMap$[ebp]
	call	??1?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@QAE@XZ ; std::vector<PushTile,std::allocator<PushTile> >::~vector<PushTile,std::allocator<PushTile> >
	mov	eax, DWORD PTR $T2[ebp]
$LN1@GetDirecti:

; 138  : 	};

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN29@GetDirecti
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 440				; 000001b8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN29@GetDirecti:
	DD	2
	DD	$LN28@GetDirecti
$LN28@GetDirecti:
	DD	-56					; ffffffc8H
	DD	12					; 0000000cH
	DD	$LN25@GetDirecti
	DD	-76					; ffffffb4H
	DD	12					; 0000000cH
	DD	$LN26@GetDirecti
$LN26@GetDirecti:
	DB	60					; 0000003cH
	DB	101					; 00000065H
	DB	110					; 0000006eH
	DB	100					; 00000064H
	DB	62					; 0000003eH
	DB	36					; 00000024H
	DB	76					; 0000004cH
	DB	48					; 00000030H
	DB	0
$LN25@GetDirecti:
	DB	60					; 0000003cH
	DB	98					; 00000062H
	DB	101					; 00000065H
	DB	103					; 00000067H
	DB	105					; 00000069H
	DB	110					; 0000006eH
	DB	62					; 0000003eH
	DB	36					; 00000024H
	DB	76					; 0000004cH
	DB	48					; 00000030H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?GetDirection@PushTile@@QAEHV?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@Z$0:
	lea	ecx, DWORD PTR _tileMap$[ebp]
	jmp	??1?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@QAE@XZ ; std::vector<PushTile,std::allocator<PushTile> >::~vector<PushTile,std::allocator<PushTile> >
__unwindfunclet$?GetDirection@PushTile@@QAEHV?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@Z$1:
	lea	ecx, DWORD PTR _<begin>$L0$17[ebp]
	jmp	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$?GetDirection@PushTile@@QAEHV?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@Z$2:
	lea	ecx, DWORD PTR _<end>$L0$16[ebp]
	jmp	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UPushTile@@@std@@@std@@@std@@QAE@XZ
__ehhandler$?GetDirection@PushTile@@QAEHV?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-444]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?GetDirection@PushTile@@QAEHV?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?GetDirection@PushTile@@QAEHV?$vector@UPushTile@@V?$allocator@UPushTile@@@std@@@std@@@Z ENDP ; PushTile::GetDirection
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?__autoclassinit2@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_classSize$ = 8						; size = 4
?__autoclassinit2@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAEXI@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Tile> > >::__autoclassinit2, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _classSize$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?__autoclassinit2@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAEXI@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Tile> > >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___that$ = 8						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAE@ABV01@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Tile> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<Tile> > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Tile> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<Tile> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Tile> > >::~_Vector_iterator<std::_Vector_val<std::_Simple_types<Tile> > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAE@XZ
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Tile> > >::~_Vector_iterator<std::_Vector_val<std::_Simple_types<Tile> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Tile> > >::operator++, COMDAT
; _this$ = ecx

; 340  : 		{	// preincrement

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 341  : 		++*(_Mybase *)this;

	mov	ecx, DWORD PTR _this$[ebp]
	call	??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAEAAV01@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Tile> > >::operator++

; 342  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 343  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??E?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Tile> > >::operator++
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QBEAAUTile@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QBEAAUTile@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Tile> > >::operator*, COMDAT
; _this$ = ecx

; 330  : 		{	// return designated object

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 331  : 		return ((reference)**(_Mybase *)this);

	mov	ecx, DWORD PTR _this$[ebp]
	call	??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QBEABUTile@@XZ ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Tile> > >::operator*

; 332  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??D?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QBEAAUTile@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Tile> > >::operator*
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QBEPAUTile@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QBEPAUTile@@XZ PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Tile> > >::_Unchecked, COMDAT
; _this$ = ecx

; 325  : 		{	// make an unchecked iterator

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 326  : 		return (this->_Ptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]

; 327  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?_Unchecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QBEPAUTile@@XZ ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Tile> > >::_Unchecked
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Rechecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAEAAV12@PAUTile@@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
?_Rechecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAEAAV12@PAUTile@@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Tile> > >::_Rechecked, COMDAT
; _this$ = ecx

; 319  : 		{	// reset from unchecked iterator

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 320  : 		this->_Ptr = _Right;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 321  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 322  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
?_Rechecked@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAEAAV12@PAUTile@@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Tile> > >::_Rechecked
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAE@PAUTile@@PBU_Container_base12@1@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAE@PAUTile@@PBU_Container_base12@1@@Z PROC ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Tile> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<Tile> > >, COMDAT
; _this$ = ecx

; 313  : 		{	// construct with pointer _Parg

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 312  : 		: _Mybase(_Parg, _Pvector)

	mov	eax, DWORD PTR __Pvector$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Parg$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAE@PAUTile@@PBU_Container_base12@1@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Tile> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Tile> > >

; 314  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAE@PAUTile@@PBU_Container_base12@1@@Z ENDP ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Tile> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<Tile> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAE@$$QAV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___that$ = 8						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAE@$$QAV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Tile> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Tile> > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Iterator012@Urandom_access_iterator_tag@std@@UTile@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@$$QAU01@@Z
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAE@$$QAV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Tile> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Tile> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAE@ABV01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___that$ = 8						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAE@ABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Tile> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Tile> > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Iterator012@Urandom_access_iterator_tag@std@@UTile@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR ___that$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax+8], edx
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAE@ABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Tile> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Tile> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Tile> > >::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Tile> > >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Iterator012@Urandom_access_iterator_tag@std@@UTile@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Tile> > >::~_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Tile> > >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QBEXABV12@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QBEXABV12@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Tile> > >::_Compat, COMDAT
; _this$ = ecx

; 245  : 		{	// test for compatible iterator pair

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 246  : 		if (this->_Getcont() != _Right._Getcont())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
	mov	esi, eax
	mov	ecx, DWORD PTR __Right$[ebp]
	call	?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
	cmp	esi, eax
	je	$LN1@Compat

; 247  : 			{
; 248  : 			_DEBUG_ERROR("vector iterators incompatible");

	mov	esi, esp
	push	248					; 000000f8H
	push	OFFSET ??_C@_1IM@NCODKBJH@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	OFFSET ??_C@_1DM@HINDPMBP@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AAs?$AA?5?$AAi?$AAn?$AAc?$AAo?$AAm?$AAp?$AAa?$AAt?$AAi?$AAb?$AAl?$AAe?$AA?$AA@
	call	DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 249  : 			_SCL_SECURE_INVALID_ARGUMENT;

	mov	eax, OFFSET ??_C@_0CI@FNPHFCCM@Standard?5C?$CL?$CL?5Libraries?5Invalid?5A@
	test	eax, eax
	je	SHORT $LN4@Compat
	xor	ecx, ecx
	jne	SHORT $LN5@Compat
$LN4@Compat:
	mov	esi, esp
	push	OFFSET ??_C@_1FO@GJIHNDLM@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAI?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5@
	push	OFFSET ??_C@_17CNPHIMPH@?$AA?$CF?$AAl?$AAs?$AA?$AA@
	push	0
	push	249					; 000000f9H
	push	OFFSET ??_C@_1IM@NCODKBJH@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	2
	call	DWORD PTR __imp___CrtDbgReportW
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN5@Compat
	int	3
$LN5@Compat:
	mov	esi, esp
	push	0
	push	249					; 000000f9H
	push	OFFSET ??_C@_1IM@NCODKBJH@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	OFFSET ??_C@_1MO@FIOFHBNA@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
	push	OFFSET ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN1@Compat:

; 250  : 			}
; 251  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QBEXABV12@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Tile> > >::_Compat
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??M?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv69 = -208						; size = 4
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
??M?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Tile> > >::operator<, COMDAT
; _this$ = ecx

; 223  : 		{	// test if this < _Right

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 224  : 		_Compat(_Right);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Tile> > >::_Compat

; 225  : 		return (_Ptr < _Right._Ptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+8]
	jae	SHORT $LN3@operator
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv69[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv69[ebp]

; 226  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??M?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Tile> > >::operator<
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv69 = -208						; size = 4
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Tile> > >::operator!=, COMDAT
; _this$ = ecx

; 218  : 		{	// test for iterator inequality

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 219  : 		return (!(*this == _Right));

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Tile> > >::operator==
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv69[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv69[ebp]

; 220  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Tile> > >::operator!=
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QBE_NABV01@@Z
_TEXT	SEGMENT
tv69 = -208						; size = 4
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QBE_NABV01@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Tile> > >::operator==, COMDAT
; _this$ = ecx

; 212  : 		{	// test for iterator equality

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 213  : 		_Compat(_Right);

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Compat@?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QBEXABV12@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Tile> > >::_Compat

; 214  : 		return (_Ptr == _Right._Ptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+8]
	jne	SHORT $LN3@operator
	mov	DWORD PTR tv69[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv69[ebp], 0
$LN4@operator:
	mov	al, BYTE PTR tv69[ebp]

; 215  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QBE_NABV01@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Tile> > >::operator==
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAEAAV01@XZ
_TEXT	SEGMENT
__Mycont$ = -20						; size = 4
_this$ = -8						; size = 4
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAEAAV01@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Tile> > >::operator++, COMDAT
; _this$ = ecx

; 95   : 		{	// preincrement

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 96   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 97   : 		const auto _Mycont = static_cast<const _Myvec *>(this->_Getcont());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
	mov	DWORD PTR __Mycont$[ebp], eax

; 98   : 		if (_Mycont == 0
; 99   : 			|| _Ptr == nullptr_t{}
; 100  : 			|| _Mycont->_Mylast <= _Ptr)

	cmp	DWORD PTR __Mycont$[ebp], 0
	je	SHORT $LN3@operator
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN3@operator
	mov	eax, DWORD PTR __Mycont$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+8]
	ja	SHORT $LN2@operator
$LN3@operator:

; 101  : 			{	// report error
; 102  : 			_DEBUG_ERROR("vector iterator not incrementable");

	mov	esi, esp
	push	102					; 00000066H
	push	OFFSET ??_C@_1IM@NCODKBJH@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	OFFSET ??_C@_1EE@EJDKCLKB@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAi?$AAn?$AAc?$AAr?$AAe?$AAm?$AAe?$AAn?$AAt?$AAa?$AAb?$AAl@
	call	DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 103  : 			_SCL_SECURE_OUT_OF_RANGE;

	mov	eax, OFFSET ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@
	test	eax, eax
	je	SHORT $LN5@operator
	xor	ecx, ecx
	jne	SHORT $LN6@operator
$LN5@operator:
	mov	esi, esp
	push	OFFSET ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@
	push	OFFSET ??_C@_17CNPHIMPH@?$AA?$CF?$AAl?$AAs?$AA?$AA@
	push	0
	push	103					; 00000067H
	push	OFFSET ??_C@_1IM@NCODKBJH@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	2
	call	DWORD PTR __imp___CrtDbgReportW
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN6@operator
	int	3
$LN6@operator:
	mov	esi, esp
	push	0
	push	103					; 00000067H
	push	OFFSET ??_C@_1IM@NCODKBJH@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	OFFSET ??_C@_1NG@NCMKFBLG@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
	push	OFFSET ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@operator:

; 104  : 			}
; 105  : 
; 106  :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 107  : 		_SCL_SECURE_VALIDATE(_Ptr != _Tptr());
; 108  : 		const auto _Mycont = static_cast<const _Myvec *>(this->_Getcont());
; 109  : 		_SCL_SECURE_VALIDATE(_Mycont != 0);
; 110  : 		_SCL_SECURE_VALIDATE_RANGE(_Ptr < _Mycont->_Mylast);
; 111  :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 112  : 
; 113  : 		++_Ptr;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	add	ecx, 32					; 00000020H
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [edx+8], ecx

; 114  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 115  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??E?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAEAAV01@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Tile> > >::operator++
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QBEABUTile@@XZ
_TEXT	SEGMENT
__Mycont$ = -20						; size = 4
_this$ = -8						; size = 4
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QBEABUTile@@XZ PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Tile> > >::operator*, COMDAT
; _this$ = ecx

; 65   : 		{	// return designated object

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 66   :  #if _ITERATOR_DEBUG_LEVEL == 2
; 67   : 		const auto _Mycont = static_cast<const _Myvec *>(this->_Getcont());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
	mov	DWORD PTR __Mycont$[ebp], eax

; 68   : 		if (_Mycont == 0
; 69   : 			|| _Ptr == _Tptr()
; 70   : 			|| _Ptr < _Mycont->_Myfirst
; 71   : 			|| _Mycont->_Mylast <= _Ptr)

	cmp	DWORD PTR __Mycont$[ebp], 0
	je	SHORT $LN3@operator
	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN3@operator
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Mycont$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+4]
	jb	SHORT $LN3@operator
	mov	eax, DWORD PTR __Mycont$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [eax+8]
	cmp	edx, DWORD PTR [ecx+8]
	ja	SHORT $LN2@operator
$LN3@operator:

; 72   : 			{	// report error
; 73   : 			_DEBUG_ERROR("vector iterator not dereferencable");

	mov	esi, esp
	push	73					; 00000049H
	push	OFFSET ??_C@_1IM@NCODKBJH@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	OFFSET ??_C@_1EG@FOHJJHAC@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAn?$AAo?$AAt?$AA?5?$AAd?$AAe?$AAr?$AAe?$AAf?$AAe?$AAr?$AAe?$AAn?$AAc?$AAa?$AAb@
	call	DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp

; 74   : 			_SCL_SECURE_OUT_OF_RANGE;

	mov	eax, OFFSET ??_C@_0CE@OFMIGAMM@Standard?5C?$CL?$CL?5Libraries?5Out?5of?5Ra@
	test	eax, eax
	je	SHORT $LN5@operator
	xor	ecx, ecx
	jne	SHORT $LN6@operator
$LN5@operator:
	mov	esi, esp
	push	OFFSET ??_C@_1FG@IBPIFFN@?$AA?$CC?$AAS?$AAt?$AAa?$AAn?$AAd?$AAa?$AAr?$AAd?$AA?5?$AAC?$AA?$CL?$AA?$CL?$AA?5?$AAL?$AAi?$AAb?$AAr?$AAa?$AAr?$AAi?$AAe?$AAs?$AA?5?$AAO?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAR@
	push	OFFSET ??_C@_17CNPHIMPH@?$AA?$CF?$AAl?$AAs?$AA?$AA@
	push	0
	push	74					; 0000004aH
	push	OFFSET ??_C@_1IM@NCODKBJH@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	2
	call	DWORD PTR __imp___CrtDbgReportW
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN6@operator
	int	3
$LN6@operator:
	mov	esi, esp
	push	0
	push	74					; 0000004aH
	push	OFFSET ??_C@_1IM@NCODKBJH@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	OFFSET ??_C@_1NE@MNCPAIHH@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAV?$AAe?$AAc?$AAt?$AAo?$AAr?$AA_?$AAc?$AAo?$AAn?$AAs?$AAt?$AA_?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?$DM?$AAc?$AAl?$AAa?$AAs@
	push	OFFSET ??_C@_1BO@MEPPHOO@?$AA?$CC?$AAo?$AAu?$AAt?$AA?5?$AAo?$AAf?$AA?5?$AAr?$AAa?$AAn?$AAg?$AAe?$AA?$CC?$AA?$AA@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@operator:

; 75   : 			}
; 76   : 
; 77   :  #elif _ITERATOR_DEBUG_LEVEL == 1
; 78   : 		_SCL_SECURE_VALIDATE(_Ptr != _Tptr());
; 79   : 		const auto _Mycont = static_cast<const _Myvec *>(this->_Getcont());
; 80   : 		_SCL_SECURE_VALIDATE(_Mycont != 0);
; 81   : 		_SCL_SECURE_VALIDATE_RANGE(_Mycont->_Myfirst <= _Ptr && _Ptr < _Mycont->_Mylast);
; 82   :  #endif /* _ITERATOR_DEBUG_LEVEL */
; 83   : 
; 84   : 		_Analysis_assume_(_Ptr != _Tptr());
; 85   : 
; 86   : 		return (*_Ptr);

	mov	eax, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR [eax+8]

; 87   : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??D?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QBEABUTile@@XZ ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Tile> > >::operator*
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAE@PAUTile@@PBU_Container_base12@1@@Z
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
__Parg$ = 8						; size = 4
__Pvector$ = 12						; size = 4
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAE@PAUTile@@PBU_Container_base12@1@@Z PROC ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Tile> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Tile> > >, COMDAT
; _this$ = ecx

; 47   : 		{	// construct with pointer _Parg

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAE@PAUTile@@PBU_Container_base12@1@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Iterator012@Urandom_access_iterator_tag@std@@UTile@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 46   : 		: _Ptr(_Parg)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Parg$[ebp]
	mov	DWORD PTR [eax+8], ecx

; 48   : 		this->_Adopt(_Pvector);

	mov	eax, DWORD PTR __Pvector$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt

; 49   : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAE@PAUTile@@PBU_Container_base12@1@@Z$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Iterator012@Urandom_access_iterator_tag@std@@UTile@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ
__ehhandler$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAE@PAUTile@@PBU_Container_base12@1@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAE@PAUTile@@PBU_Container_base12@1@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAE@PAUTile@@PBU_Container_base12@1@@Z ENDP ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Tile> > >::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Tile> > >
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??0?$_Iterator012@Urandom_access_iterator_tag@std@@UTile@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@$$QAU01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___that$ = 8						; size = 4
??0?$_Iterator012@Urandom_access_iterator_tag@std@@UTile@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@$$QAU01@@Z PROC ; std::_Iterator012<std::random_access_iterator_tag,Tile,int,Tile const *,Tile const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,Tile,int,Tile const *,Tile const &,std::_Iterator_base12>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Iterator_base12@std@@QAE@ABU01@@Z	; std::_Iterator_base12::_Iterator_base12
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_Iterator012@Urandom_access_iterator_tag@std@@UTile@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@$$QAU01@@Z ENDP ; std::_Iterator012<std::random_access_iterator_tag,Tile,int,Tile const *,Tile const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,Tile,int,Tile const *,Tile const &,std::_Iterator_base12>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??0?$_Iterator012@Urandom_access_iterator_tag@std@@UTile@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___that$ = 8						; size = 4
??0?$_Iterator012@Urandom_access_iterator_tag@std@@UTile@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z PROC ; std::_Iterator012<std::random_access_iterator_tag,Tile,int,Tile const *,Tile const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,Tile,int,Tile const *,Tile const &,std::_Iterator_base12>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR ___that$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Iterator_base12@std@@QAE@ABU01@@Z	; std::_Iterator_base12::_Iterator_base12
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0?$_Iterator012@Urandom_access_iterator_tag@std@@UTile@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@ABU01@@Z ENDP ; std::_Iterator012<std::random_access_iterator_tag,Tile,int,Tile const *,Tile const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,Tile,int,Tile const *,Tile const &,std::_Iterator_base12>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1?$_Iterator012@Urandom_access_iterator_tag@std@@UTile@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$_Iterator012@Urandom_access_iterator_tag@std@@UTile@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ PROC ; std::_Iterator012<std::random_access_iterator_tag,Tile,int,Tile const *,Tile const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,Tile,int,Tile const *,Tile const &,std::_Iterator_base12>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Iterator_base12@std@@QAE@XZ		; std::_Iterator_base12::~_Iterator_base12
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Iterator012@Urandom_access_iterator_tag@std@@UTile@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ ENDP ; std::_Iterator012<std::random_access_iterator_tag,Tile,int,Tile const *,Tile const &,std::_Iterator_base12>::~_Iterator012<std::random_access_iterator_tag,Tile,int,Tile const *,Tile const &,std::_Iterator_base12>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??0?$_Iterator012@Urandom_access_iterator_tag@std@@UTile@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$_Iterator012@Urandom_access_iterator_tag@std@@UTile@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ PROC ; std::_Iterator012<std::random_access_iterator_tag,Tile,int,Tile const *,Tile const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,Tile,int,Tile const *,Tile const &,std::_Iterator_base12>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Iterator_base12@std@@QAE@XZ		; std::_Iterator_base12::_Iterator_base12
	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Iterator012@Urandom_access_iterator_tag@std@@UTile@@HPBU3@ABU3@U_Iterator_base12@2@@std@@QAE@XZ ENDP ; std::_Iterator012<std::random_access_iterator_tag,Tile,int,Tile const *,Tile const &,std::_Iterator_base12>::_Iterator012<std::random_access_iterator_tag,Tile,int,Tile const *,Tile const &,std::_Iterator_base12>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ?__autoclassinit2@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
_classSize$ = 8						; size = 4
?__autoclassinit2@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QAEXI@Z PROC ; std::vector<Tile,std::allocator<Tile> >::__autoclassinit2, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _classSize$[ebp]
	push	eax
	push	0
	mov	ecx, DWORD PTR _this$[ebp]
	push	ecx
	call	_memset
	add	esp, 12					; 0000000cH
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?__autoclassinit2@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QAEXI@Z ENDP ; std::vector<Tile,std::allocator<Tile> >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Orphan_range@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@IBEXPAUTile@@0@Z
_TEXT	SEGMENT
__Pnext$ = -48						; size = 4
__Lock$ = -36						; size = 4
_this$ = -24						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Orphan_range@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@IBEXPAUTile@@0@Z PROC ; std::vector<Tile,std::allocator<Tile> >::_Orphan_range, COMDAT
; _this$ = ecx

; 1775 : 		{	// orphan iterators within specified (inclusive) range

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Orphan_range@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@IBEXPAUTile@@0@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-244]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1776 : 		_Lockit _Lock(_LOCK_DEBUG);

	mov	esi, esp
	push	3
	lea	ecx, DWORD PTR __Lock$[ebp]
	call	DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1777 : 		const_iterator **_Pnext = (const_iterator **)this->_Getpfirst();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getpfirst@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QBEPAPAU_Iterator_base12@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Getpfirst
	mov	DWORD PTR __Pnext$[ebp], eax

; 1778 : 		if (_Pnext != 0)

	cmp	DWORD PTR __Pnext$[ebp], 0
	je	SHORT $LN4@Orphan_ran
$LN2@Orphan_ran:

; 1779 : 			{	// test an iterator
; 1780 : 			while (*_Pnext != 0)

	mov	eax, DWORD PTR __Pnext$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN4@Orphan_ran

; 1781 : 				if ((*_Pnext)->_Ptr < _First || _Last < (*_Pnext)->_Ptr)

	mov	eax, DWORD PTR __Pnext$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx+8]
	cmp	edx, DWORD PTR __First$[ebp]
	jb	SHORT $LN7@Orphan_ran
	mov	eax, DWORD PTR __Pnext$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Last$[ebp]
	cmp	edx, DWORD PTR [ecx+8]
	jae	SHORT $LN5@Orphan_ran
$LN7@Orphan_ran:

; 1782 : 					_Pnext = (const_iterator **)(*_Pnext)->_Getpnext();

	mov	eax, DWORD PTR __Pnext$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ ; std::_Iterator_base12::_Getpnext
	mov	DWORD PTR __Pnext$[ebp], eax

; 1783 : 				else

	jmp	SHORT $LN6@Orphan_ran
$LN5@Orphan_ran:

; 1784 : 					{	// orphan the iterator
; 1785 : 					(*_Pnext)->_Clrcont();

	mov	eax, DWORD PTR __Pnext$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?_Clrcont@_Iterator_base12@std@@QAEXXZ	; std::_Iterator_base12::_Clrcont

; 1786 : 					*_Pnext = *(const_iterator **)(*_Pnext)->_Getpnext();

	mov	eax, DWORD PTR __Pnext$[ebp]
	mov	ecx, DWORD PTR [eax]
	call	?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ ; std::_Iterator_base12::_Getpnext
	mov	ecx, DWORD PTR __Pnext$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], edx
$LN6@Orphan_ran:

; 1787 : 					}

	jmp	SHORT $LN2@Orphan_ran
$LN4@Orphan_ran:

; 1788 : 			}
; 1789 : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	esi, esp
	lea	ecx, DWORD PTR __Lock$[ebp]
	call	DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN13@Orphan_ran
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 244				; 000000f4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
$LN13@Orphan_ran:
	DD	1
	DD	$LN12@Orphan_ran
$LN12@Orphan_ran:
	DD	-36					; ffffffdcH
	DD	4
	DD	$LN10@Orphan_ran
$LN10@Orphan_ran:
	DB	95					; 0000005fH
	DB	76					; 0000004cH
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	107					; 0000006bH
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Orphan_range@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@IBEXPAUTile@@0@Z$0:
	mov	esi, esp
	lea	ecx, DWORD PTR __Lock$[ebp]
	call	DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
	cmp	esi, esp
	jmp	__RTC_CheckEsp
__ehhandler$?_Orphan_range@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@IBEXPAUTile@@0@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-248]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Orphan_range@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@IBEXPAUTile@@0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Orphan_range@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@IBEXPAUTile@@0@Z ENDP ; std::vector<Tile,std::allocator<Tile> >::_Orphan_range
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Xlen@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@IBEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Xlen@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@IBEXXZ PROC ; std::vector<Tile,std::allocator<Tile> >::_Xlen, COMDAT
; _this$ = ecx

; 1764 : 		{	// report a length_error

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1765 : 		_Xlength_error("vector<T> too long");

	mov	esi, esp
	push	OFFSET ??_C@_0BD@OLBABOEK@vector?$DMT?$DO?5too?5long?$AA@
	call	DWORD PTR __imp_?_Xlength_error@std@@YAXPBD@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@Xlen:

; 1766 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Xlen@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@IBEXXZ ENDP ; std::vector<Tile,std::allocator<Tile> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Tidy@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@IAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Tidy@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@IAEXXZ PROC ; std::vector<Tile,std::allocator<Tile> >::_Tidy, COMDAT
; _this$ = ecx

; 1636 : 		{	// free all storage

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1637 : 		if (this->_Myfirst() != pointer())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAEAAPAUTile@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Myfirst
	cmp	DWORD PTR [eax], 0
	je	$LN1@Tidy

; 1638 : 			{	// something to free, destroy and deallocate it
; 1639 : 			this->_Orphan_all();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Orphan_all

; 1640 : 			_Destroy(this->_Myfirst(), this->_Mylast());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAEAAPAUTile@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Mylast
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAEAAPAUTile@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Myfirst
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@IAEXPAUTile@@0@Z ; std::vector<Tile,std::allocator<Tile> >::_Destroy

; 1641 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myend@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAEAAPAUTile@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Myend
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAEAAPAUTile@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Myfirst
	mov	ecx, DWORD PTR [esi]
	sub	ecx, DWORD PTR [eax]
	sar	ecx, 5
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAEAAPAUTile@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Myfirst
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@UTile@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Getal
	mov	ecx, eax
	call	?deallocate@?$_Wrap_alloc@V?$allocator@UTile@@@std@@@std@@QAEXPAUTile@@I@Z ; std::_Wrap_alloc<std::allocator<Tile> >::deallocate

; 1642 : 				this->_Myend() - this->_Myfirst());
; 1643 : 			this->_Myfirst() = pointer();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAEAAPAUTile@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Myfirst
	mov	DWORD PTR [eax], 0

; 1644 : 			this->_Mylast() = pointer();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAEAAPAUTile@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Mylast
	mov	DWORD PTR [eax], 0

; 1645 : 			this->_Myend() = pointer();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myend@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAEAAPAUTile@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Myend
	mov	DWORD PTR [eax], 0
$LN1@Tidy:

; 1646 : 			}
; 1647 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Tidy@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@IAEXXZ ENDP ; std::vector<Tile,std::allocator<Tile> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Reserve@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Count$ = 8						; size = 4
?_Reserve@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@IAEXI@Z PROC ; std::vector<Tile,std::allocator<Tile> >::_Reserve, COMDAT
; _this$ = ecx

; 1626 : 		{	// ensure room for _Count new elements, grow exponentially

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1627 : 		if (_Unused_capacity() < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Unused_capacity@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QBEIXZ ; std::vector<Tile,std::allocator<Tile> >::_Unused_capacity
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	SHORT $LN4@Reserve

; 1628 : 			{	// need more room, try to get it
; 1629 : 			if (max_size() - size() < _Count)

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QBEIXZ ; std::vector<Tile,std::allocator<Tile> >::max_size
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QBEIXZ ; std::vector<Tile,std::allocator<Tile> >::size
	sub	esi, eax
	cmp	esi, DWORD PTR __Count$[ebp]
	jae	SHORT $LN3@Reserve

; 1630 : 				_Xlen();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Xlen@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@IBEXXZ ; std::vector<Tile,std::allocator<Tile> >::_Xlen
$LN3@Reserve:

; 1631 : 			_Reallocate(_Grow_to(size() + _Count));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QBEIXZ ; std::vector<Tile,std::allocator<Tile> >::size
	add	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Grow_to@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@IBEII@Z ; std::vector<Tile,std::allocator<Tile> >::_Grow_to
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Reallocate@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@IAEXI@Z ; std::vector<Tile,std::allocator<Tile> >::_Reallocate
$LN4@Reserve:

; 1632 : 			}
; 1633 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?_Reserve@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@IAEXI@Z ENDP ; std::vector<Tile,std::allocator<Tile> >::_Reserve
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Reallocate@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@IAEXI@Z
_TEXT	SEGMENT
__Size$ = -48						; size = 4
__Ptr$ = -36						; size = 4
_this$ = -24						; size = 4
__$EHRec$ = -16						; size = 16
__Count$ = 8						; size = 4
?_Reallocate@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@IAEXI@Z PROC ; std::vector<Tile,std::allocator<Tile> >::_Reallocate, COMDAT
; _this$ = ecx

; 1601 : 		{	// move to array of exactly _Count elements

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Reallocate@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@IAEXI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ecx
	sub	esp, 228				; 000000e4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-244]
	mov	ecx, 57					; 00000039H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	DWORD PTR _this$[ebp], ecx

; 1602 : 		pointer _Ptr = this->_Getal().allocate(_Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@UTile@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Getal
	mov	ecx, eax
	call	?allocate@?$_Wrap_alloc@V?$allocator@UTile@@@std@@@std@@QAEPAUTile@@I@Z ; std::_Wrap_alloc<std::allocator<Tile> >::allocate
	mov	DWORD PTR __Ptr$[ebp], eax

; 1603 : 
; 1604 : 		_TRY_BEGIN

	mov	DWORD PTR __$EHRec$[ebp+12], 0

; 1605 : 		_Umove(this->_Myfirst(), this->_Mylast(), _Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAEAAPAUTile@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Mylast
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAEAAPAUTile@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Myfirst
	mov	edx, DWORD PTR [eax]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$_Umove@PAUTile@@@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@IAEPAUTile@@PAU2@00@Z ; std::vector<Tile,std::allocator<Tile> >::_Umove<Tile *>
	jmp	SHORT $LN5@Reallocate
__catch$?_Reallocate@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@IAEXI@Z$0:

; 1606 : 		_CATCH_ALL
; 1607 : 		this->_Getal().deallocate(_Ptr, _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@UTile@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Getal
	mov	ecx, eax
	call	?deallocate@?$_Wrap_alloc@V?$allocator@UTile@@@std@@@std@@QAEXPAUTile@@I@Z ; std::_Wrap_alloc<std::allocator<Tile> >::deallocate

; 1608 : 		_RERAISE;

	push	0
	push	0
	call	__CxxThrowException@8

; 1609 : 		_CATCH_END

	mov	eax, $LN8@Reallocate
	ret	0
$LN5@Reallocate:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	jmp	SHORT __tryend$?_Reallocate@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@IAEXI@Z$1
$LN8@Reallocate:
	mov	DWORD PTR __$EHRec$[ebp+12], -1
__tryend$?_Reallocate@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@IAEXI@Z$1:

; 1610 : 
; 1611 : 		size_type _Size = size();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?size@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QBEIXZ ; std::vector<Tile,std::allocator<Tile> >::size
	mov	DWORD PTR __Size$[ebp], eax

; 1612 : 		if (this->_Myfirst() != pointer())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAEAAPAUTile@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Myfirst
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@Reallocate

; 1613 : 			{	// destroy and deallocate old array
; 1614 : 			_Destroy(this->_Myfirst(), this->_Mylast());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAEAAPAUTile@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Mylast
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAEAAPAUTile@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Myfirst
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@IAEXPAUTile@@0@Z ; std::vector<Tile,std::allocator<Tile> >::_Destroy

; 1615 : 			this->_Getal().deallocate(this->_Myfirst(),

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAEAAPAUTile@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Myfirst
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myend@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAEAAPAUTile@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Myend
	mov	eax, DWORD PTR [eax]
	sub	eax, DWORD PTR [esi]
	sar	eax, 5
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAEAAPAUTile@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Myfirst
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@UTile@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Getal
	mov	ecx, eax
	call	?deallocate@?$_Wrap_alloc@V?$allocator@UTile@@@std@@@std@@QAEXPAUTile@@I@Z ; std::_Wrap_alloc<std::allocator<Tile> >::deallocate
$LN3@Reallocate:

; 1616 : 				this->_Myend() - this->_Myfirst());
; 1617 : 			}
; 1618 : 
; 1619 : 		this->_Orphan_all();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Orphan_all

; 1620 : 		this->_Myend() = _Ptr + _Count;

	mov	esi, DWORD PTR __Count$[ebp]
	shl	esi, 5
	add	esi, DWORD PTR __Ptr$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myend@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAEAAPAUTile@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Myend
	mov	DWORD PTR [eax], esi

; 1621 : 		this->_Mylast() = _Ptr + _Size;

	mov	esi, DWORD PTR __Size$[ebp]
	shl	esi, 5
	add	esi, DWORD PTR __Ptr$[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAEAAPAUTile@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Mylast
	mov	DWORD PTR [eax], esi

; 1622 : 		this->_Myfirst() = _Ptr;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAEAAPAUTile@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Myfirst
	mov	ecx, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [eax], ecx
$LN4@Reallocate:

; 1623 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 244				; 000000f4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?_Reallocate@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@IAEXI@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-248]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Reallocate@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@IAEXI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Reallocate@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@IAEXI@Z ENDP ; std::vector<Tile,std::allocator<Tile> >::_Reallocate
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Inside@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@IBE_NPBUTile@@@Z
_TEXT	SEGMENT
tv82 = -208						; size = 4
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
?_Inside@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@IBE_NPBUTile@@@Z PROC ; std::vector<Tile,std::allocator<Tile> >::_Inside, COMDAT
; _this$ = ecx

; 1596 : 		{	// test if _Ptr points inside vector

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1597 : 		return (_Ptr < _Unfancy(this->_Mylast()) && _Unfancy(this->_Myfirst()) <= _Ptr);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QBEABQAUTile@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Mylast
	mov	eax, DWORD PTR [eax]
	push	eax
	call	??$_Unfancy@UTile@@@std@@YAPAUTile@@PAU1@@Z ; std::_Unfancy<Tile>
	add	esp, 4
	cmp	DWORD PTR __Ptr$[ebp], eax
	jae	SHORT $LN3@Inside
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QBEABQAUTile@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Myfirst
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	??$_Unfancy@UTile@@@std@@YAPAUTile@@PAU1@@Z ; std::_Unfancy<Tile>
	add	esp, 4
	cmp	eax, DWORD PTR __Ptr$[ebp]
	ja	SHORT $LN3@Inside
	mov	DWORD PTR tv82[ebp], 1
	jmp	SHORT $LN4@Inside
$LN3@Inside:
	mov	DWORD PTR tv82[ebp], 0
$LN4@Inside:
	mov	al, BYTE PTR tv82[ebp]

; 1598 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 208				; 000000d0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?_Inside@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@IBE_NPBUTile@@@Z ENDP ; std::vector<Tile,std::allocator<Tile> >::_Inside
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Grow_to@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@IBEII@Z
_TEXT	SEGMENT
tv73 = -220						; size = 4
__Capacity$ = -20					; size = 4
_this$ = -8						; size = 4
__Count$ = 8						; size = 4
?_Grow_to@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@IBEII@Z PROC ; std::vector<Tile,std::allocator<Tile> >::_Grow_to, COMDAT
; _this$ = ecx

; 1585 : 		{	// grow by 50% or at least to _Count

	push	ebp
	mov	ebp, esp
	sub	esp, 220				; 000000dcH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-220]
	mov	ecx, 55					; 00000037H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1586 : 		size_type _Capacity = capacity();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?capacity@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QBEIXZ ; std::vector<Tile,std::allocator<Tile> >::capacity
	mov	DWORD PTR __Capacity$[ebp], eax

; 1587 : 
; 1588 : 		_Capacity = max_size() - _Capacity / 2 < _Capacity

	mov	ecx, DWORD PTR _this$[ebp]
	call	?max_size@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QBEIXZ ; std::vector<Tile,std::allocator<Tile> >::max_size
	mov	ecx, DWORD PTR __Capacity$[ebp]
	shr	ecx, 1
	sub	eax, ecx
	cmp	eax, DWORD PTR __Capacity$[ebp]
	jae	SHORT $LN4@Grow_to
	mov	DWORD PTR tv73[ebp], 0
	jmp	SHORT $LN5@Grow_to
$LN4@Grow_to:
	mov	edx, DWORD PTR __Capacity$[ebp]
	shr	edx, 1
	add	edx, DWORD PTR __Capacity$[ebp]
	mov	DWORD PTR tv73[ebp], edx
$LN5@Grow_to:
	mov	eax, DWORD PTR tv73[ebp]
	mov	DWORD PTR __Capacity$[ebp], eax

; 1589 : 			? 0 : _Capacity + _Capacity / 2;	// try to grow by 50%
; 1590 : 		if (_Capacity < _Count)

	mov	eax, DWORD PTR __Capacity$[ebp]
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	SHORT $LN2@Grow_to

; 1591 : 			_Capacity = _Count;

	mov	eax, DWORD PTR __Count$[ebp]
	mov	DWORD PTR __Capacity$[ebp], eax
$LN2@Grow_to:

; 1592 : 		return (_Capacity);

	mov	eax, DWORD PTR __Capacity$[ebp]

; 1593 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 220				; 000000dcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?_Grow_to@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@IBEII@Z ENDP ; std::vector<Tile,std::allocator<Tile> >::_Grow_to
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Destroy@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@IAEXPAUTile@@0@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__First$ = 8						; size = 4
__Last$ = 12						; size = 4
?_Destroy@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@IAEXPAUTile@@0@Z PROC ; std::vector<Tile,std::allocator<Tile> >::_Destroy, COMDAT
; _this$ = ecx

; 1580 : 		{	// destroy [_First, _Last) using allocator

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1581 : 		_Destroy_range(_First, _Last, this->_Getal());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@UTile@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Getal
	push	eax
	mov	eax, DWORD PTR __Last$[ebp]
	push	eax
	mov	ecx, DWORD PTR __First$[ebp]
	push	ecx
	call	??$_Destroy_range@V?$allocator@UTile@@@std@@PAUTile@@@std@@YAXPAUTile@@0AAU?$_Wrap_alloc@V?$allocator@UTile@@@std@@@0@@Z ; std::_Destroy_range<std::allocator<Tile>,Tile *>
	add	esp, 12					; 0000000cH

; 1582 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?_Destroy@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@IAEXPAUTile@@0@Z ENDP ; std::vector<Tile,std::allocator<Tile> >::_Destroy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?clear@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
?clear@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QAEXXZ PROC ; std::vector<Tile,std::allocator<Tile> >::clear, COMDAT
; _this$ = ecx

; 1539 : 		{	// erase all

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?clear@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1540 : 		this->_Orphan_all();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Orphan_all

; 1541 : 		_Destroy(this->_Myfirst(), this->_Mylast());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAEAAPAUTile@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Mylast
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAEAAPAUTile@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Myfirst
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@IAEXPAUTile@@0@Z ; std::vector<Tile,std::allocator<Tile> >::_Destroy

; 1542 : 		this->_Mylast() = this->_Myfirst();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAEAAPAUTile@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Myfirst
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAEAAPAUTile@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Mylast
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax], ecx

; 1543 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?clear@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?clear@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?clear@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QAEXXZ ENDP ; std::vector<Tile,std::allocator<Tile> >::clear
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?erase@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@2@0@Z
_TEXT	SEGMENT
tv94 = -392						; size = 4
tv324 = -388						; size = 4
tv350 = -384						; size = 4
tv339 = -380						; size = 4
tv335 = -380						; size = 4
tv331 = -380						; size = 4
tv319 = -380						; size = 4
tv346 = -376						; size = 4
tv338 = -376						; size = 4
tv334 = -376						; size = 4
tv330 = -376						; size = 4
$T2 = -368						; size = 4
$T3 = -356						; size = 4
$T4 = -344						; size = 4
$T5 = -332						; size = 4
$T6 = -320						; size = 12
$T7 = -300						; size = 12
$T8 = -277						; size = 1
__Ptr$9 = -76						; size = 4
__Last$10 = -64						; size = 12
__First$11 = -44					; size = 12
_this$ = -24						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__First_arg$ = 12					; size = 12
__Last_arg$ = 24					; size = 12
?erase@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@2@0@Z PROC ; std::vector<Tile,std::allocator<Tile> >::erase, COMDAT
; _this$ = ecx

; 1495 : 		{	// erase [_First, _Last)

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?erase@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@2@0@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 380				; 0000017cH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-392]
	mov	ecx, 95					; 0000005fH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T2[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 1496 : 		if (_First_arg == begin() && _Last_arg == end())

	lea	eax, DWORD PTR $T7[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?begin@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@2@XZ ; std::vector<Tile,std::allocator<Tile> >::begin
	mov	DWORD PTR tv346[ebp], eax
	mov	ecx, DWORD PTR tv346[ebp]
	mov	DWORD PTR tv319[ebp], ecx
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	edx, DWORD PTR $T2[ebp]
	or	edx, 1
	mov	DWORD PTR $T2[ebp], edx
	mov	eax, DWORD PTR tv319[ebp]
	push	eax
	lea	ecx, DWORD PTR __First_arg$[ebp]
	call	??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Tile> > >::operator==
	movzx	ecx, al
	test	ecx, ecx
	je	SHORT $LN9@erase
	lea	edx, DWORD PTR $T6[ebp]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?end@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@2@XZ ; std::vector<Tile,std::allocator<Tile> >::end
	mov	DWORD PTR tv350[ebp], eax
	mov	eax, DWORD PTR tv350[ebp]
	mov	DWORD PTR tv324[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 3
	mov	ecx, DWORD PTR $T2[ebp]
	or	ecx, 2
	mov	DWORD PTR $T2[ebp], ecx
	mov	edx, DWORD PTR tv324[ebp]
	push	edx
	lea	ecx, DWORD PTR __Last_arg$[ebp]
	call	??8?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Tile> > >::operator==
	movzx	eax, al
	test	eax, eax
	je	SHORT $LN9@erase
	mov	DWORD PTR tv94[ebp], 1
	jmp	SHORT $LN10@erase
$LN9@erase:
	mov	DWORD PTR tv94[ebp], 0
$LN10@erase:
	mov	cl, BYTE PTR tv94[ebp]
	mov	BYTE PTR $T8[ebp], cl
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	mov	edx, DWORD PTR $T2[ebp]
	and	edx, 2
	je	SHORT $LN17@erase
	and	DWORD PTR $T2[ebp], -3			; fffffffdH
	lea	ecx, DWORD PTR $T6[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAE@XZ
$LN17@erase:
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	mov	eax, DWORD PTR $T2[ebp]
	and	eax, 1
	je	SHORT $LN18@erase
	and	DWORD PTR $T2[ebp], -2			; fffffffeH
	lea	ecx, DWORD PTR $T7[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAE@XZ
$LN18@erase:
	movzx	ecx, BYTE PTR $T8[ebp]
	test	ecx, ecx
	je	SHORT $LN2@erase

; 1497 : 			clear();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?clear@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QAEXXZ ; std::vector<Tile,std::allocator<Tile> >::clear
	jmp	$LN3@erase
$LN2@erase:

; 1498 : 		else if (_First_arg != _Last_arg)

	lea	eax, DWORD PTR __Last_arg$[ebp]
	push	eax
	lea	ecx, DWORD PTR __First_arg$[ebp]
	call	??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Tile> > >::operator!=
	movzx	ecx, al
	test	ecx, ecx
	je	$LN3@erase

; 1499 : 			{	// clear partial
; 1500 : 			iterator _First = _Make_iter(_First_arg);

	push	12					; 0000000cH
	lea	ecx, DWORD PTR __First$11[ebp]
	call	?__autoclassinit2@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAEXI@Z
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T5[ebp], esp
	lea	eax, DWORD PTR __First_arg$[ebp]
	push	eax
	call	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv330[ebp], eax
	lea	ecx, DWORD PTR __First$11[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@2@@Z ; std::vector<Tile,std::allocator<Tile> >::_Make_iter
	mov	DWORD PTR tv331[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 4

; 1501 : 			iterator _Last = _Make_iter(_Last_arg);

	push	12					; 0000000cH
	lea	ecx, DWORD PTR __Last$10[ebp]
	call	?__autoclassinit2@?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAEXI@Z
	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T4[ebp], esp
	lea	eax, DWORD PTR __Last_arg$[ebp]
	push	eax
	call	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv334[ebp], eax
	lea	ecx, DWORD PTR __Last$10[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@2@@Z ; std::vector<Tile,std::allocator<Tile> >::_Make_iter
	mov	DWORD PTR tv335[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 5

; 1502 : 
; 1503 : 			if (_First != _Last)

	lea	eax, DWORD PTR __Last$10[ebp]
	push	eax
	lea	ecx, DWORD PTR __First$11[ebp]
	call	??9?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Tile> > >::operator!=
	movzx	ecx, al
	test	ecx, ecx
	je	$LN5@erase

; 1504 : 				{	// worth doing, copy down over hole
; 1505 :  #if _ITERATOR_DEBUG_LEVEL == 2
; 1506 : 				if (_Last < _First || _VICONT(_First) != &this->_Get_data()
; 1507 : 					|| _VIPTR(_First) < this->_Myfirst()
; 1508 : 					|| this->_Mylast() < _VIPTR(_Last))

	lea	eax, DWORD PTR __First$11[ebp]
	push	eax
	lea	ecx, DWORD PTR __Last$10[ebp]
	call	??M?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QBE_NABV01@@Z ; std::_Vector_const_iterator<std::_Vector_val<std::_Simple_types<Tile> > >::operator<
	movzx	ecx, al
	test	ecx, ecx
	jne	SHORT $LN7@erase
	lea	ecx, DWORD PTR __First$11[ebp]
	call	?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ; std::_Iterator_base12::_Getcont
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UTile@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Get_data
	cmp	esi, eax
	jne	SHORT $LN7@erase
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAEAAPAUTile@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Myfirst
	mov	ecx, DWORD PTR __First$11[ebp+8]
	cmp	ecx, DWORD PTR [eax]
	jb	SHORT $LN7@erase
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAEAAPAUTile@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Mylast
	mov	eax, DWORD PTR [eax]
	cmp	eax, DWORD PTR __Last$10[ebp+8]
	jae	SHORT $LN6@erase
$LN7@erase:

; 1509 : 					_DEBUG_ERROR("vector erase iterator outside range");

	mov	esi, esp
	push	1509					; 000005e5H
	push	OFFSET ??_C@_1IM@NCODKBJH@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	OFFSET ??_C@_1EI@HGIDLLCM@?$AAv?$AAe?$AAc?$AAt?$AAo?$AAr?$AA?5?$AAe?$AAr?$AAa?$AAs?$AAe?$AA?5?$AAi?$AAt?$AAe?$AAr?$AAa?$AAt?$AAo?$AAr?$AA?5?$AAo?$AAu?$AAt?$AAs?$AAi?$AAd?$AAe?$AA?5?$AAr?$AAa@
	call	DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN6@erase:

; 1510 : 				pointer _Ptr = _Move_unchecked(_VIPTR(_Last), this->_Mylast(),

	mov	eax, DWORD PTR __First$11[ebp+8]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAEAAPAUTile@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Mylast
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	edx, DWORD PTR __Last$10[ebp+8]
	push	edx
	call	??$_Move_unchecked@PAUTile@@PAU1@@std@@YAPAUTile@@PAU1@00@Z ; std::_Move_unchecked<Tile *,Tile *>
	add	esp, 12					; 0000000cH
	mov	DWORD PTR __Ptr$9[ebp], eax

; 1511 : 					_VIPTR(_First));
; 1512 : 				_Orphan_range(_VIPTR(_First), this->_Mylast());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAEAAPAUTile@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Mylast
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR __First$11[ebp+8]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_range@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@IBEXPAUTile@@0@Z ; std::vector<Tile,std::allocator<Tile> >::_Orphan_range

; 1513 : 
; 1514 :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1515 : 				pointer _Ptr = _Move_unchecked(_VIPTR(_Last), this->_Mylast(),
; 1516 : 					_VIPTR(_First));
; 1517 :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 1518 : 
; 1519 : 				_Destroy(_Ptr, this->_Mylast());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAEAAPAUTile@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Mylast
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR __Ptr$9[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Destroy@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@IAEXPAUTile@@0@Z ; std::vector<Tile,std::allocator<Tile> >::_Destroy

; 1520 : 				this->_Mylast() = _Ptr;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAEAAPAUTile@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Mylast
	mov	ecx, DWORD PTR __Ptr$9[ebp]
	mov	DWORD PTR [eax], ecx
$LN5@erase:

; 1521 : 				}
; 1522 : 			}

	mov	BYTE PTR __$EHRec$[ebp+8], 4
	lea	ecx, DWORD PTR __Last$10[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAE@XZ
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	lea	ecx, DWORD PTR __First$11[ebp]
	call	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAE@XZ
$LN3@erase:

; 1523 : 		return (_Make_iter(_First_arg));

	sub	esp, 12					; 0000000cH
	mov	ecx, esp
	mov	DWORD PTR $T3[ebp], esp
	lea	eax, DWORD PTR __First_arg$[ebp]
	push	eax
	call	??0?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAE@ABV01@@Z
	mov	DWORD PTR tv338[ebp], eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Make_iter@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@2@@Z ; std::vector<Tile,std::allocator<Tile> >::_Make_iter
	mov	DWORD PTR tv339[ebp], eax
	mov	edx, DWORD PTR $T2[ebp]
	or	edx, 4
	mov	DWORD PTR $T2[ebp], edx
	mov	BYTE PTR __$EHRec$[ebp+8], 0
	lea	ecx, DWORD PTR __First_arg$[ebp]
	call	??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAE@XZ
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Last_arg$[ebp]
	call	??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1524 : 		}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN30@erase
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 392				; 00000188H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
	npad	1
$LN30@erase:
	DD	2
	DD	$LN29@erase
$LN29@erase:
	DD	-44					; ffffffd4H
	DD	12					; 0000000cH
	DD	$LN26@erase
	DD	-64					; ffffffc0H
	DD	12					; 0000000cH
	DD	$LN27@erase
$LN27@erase:
	DB	95					; 0000005fH
	DB	76					; 0000004cH
	DB	97					; 00000061H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	0
$LN26@erase:
	DB	95					; 0000005fH
	DB	70					; 00000046H
	DB	105					; 00000069H
	DB	114					; 00000072H
	DB	115					; 00000073H
	DB	116					; 00000074H
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?erase@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@2@0@Z$0:
	lea	ecx, DWORD PTR __Last_arg$[ebp]
	jmp	??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$?erase@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@2@0@Z$1:
	lea	ecx, DWORD PTR __First_arg$[ebp]
	jmp	??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$?erase@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@2@0@Z$2:
	mov	eax, DWORD PTR $T2[ebp]
	and	eax, 1
	je	$LN14@erase
	and	DWORD PTR $T2[ebp], -2			; fffffffeH
	lea	ecx, DWORD PTR $T7[ebp]
	jmp	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAE@XZ
$LN14@erase:
	ret	0
__unwindfunclet$?erase@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@2@0@Z$3:
	mov	eax, DWORD PTR $T2[ebp]
	and	eax, 2
	je	$LN16@erase
	and	DWORD PTR $T2[ebp], -3			; fffffffdH
	lea	ecx, DWORD PTR $T6[ebp]
	jmp	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAE@XZ
$LN16@erase:
	ret	0
__unwindfunclet$?erase@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@2@0@Z$5:
	lea	ecx, DWORD PTR __First$11[ebp]
	jmp	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAE@XZ
__unwindfunclet$?erase@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@2@0@Z$7:
	lea	ecx, DWORD PTR __Last$10[ebp]
	jmp	??1?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAE@XZ
__ehhandler$?erase@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@2@0@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-396]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?erase@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@2@0@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?erase@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@2@0@Z ENDP ; std::vector<Tile,std::allocator<Tile> >::erase
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?push_back@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QAEXABUTile@@@Z
_TEXT	SEGMENT
tv231 = -220						; size = 4
tv176 = -220						; size = 4
__Idx$1 = -20						; size = 4
_this$ = -8						; size = 4
__Val$ = 8						; size = 4
?push_back@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QAEXABUTile@@@Z PROC ; std::vector<Tile,std::allocator<Tile> >::push_back, COMDAT
; _this$ = ecx

; 1276 : 		{	// insert element at end

	push	ebp
	mov	ebp, esp
	sub	esp, 220				; 000000dcH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-220]
	mov	ecx, 55					; 00000037H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1277 : 		if (_Inside(_STD addressof(_Val)))

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	call	??$addressof@$$CBUTile@@@std@@YAPBUTile@@ABU1@@Z ; std::addressof<Tile const >
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Inside@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@IBE_NPBUTile@@@Z ; std::vector<Tile,std::allocator<Tile> >::_Inside
	movzx	ecx, al
	test	ecx, ecx
	je	$LN2@push_back

; 1278 : 			{	// push back an element
; 1279 : 			size_type _Idx = _STD addressof(_Val) - _Unfancy(this->_Myfirst());

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	call	??$addressof@$$CBUTile@@@std@@YAPBUTile@@ABU1@@Z ; std::addressof<Tile const >
	add	esp, 4
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAEAAPAUTile@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Myfirst
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	??$_Unfancy@UTile@@@std@@YAPAUTile@@PAU1@@Z ; std::_Unfancy<Tile>
	add	esp, 4
	sub	esi, eax
	sar	esi, 5
	mov	DWORD PTR __Idx$1[ebp], esi

; 1280 : 			if (this->_Mylast() == this->_Myend())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAEAAPAUTile@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Mylast
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myend@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAEAAPAUTile@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Myend
	mov	ecx, DWORD PTR [esi]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN4@push_back

; 1281 : 				_Reserve(1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Reserve@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@IAEXI@Z ; std::vector<Tile,std::allocator<Tile> >::_Reserve
$LN4@push_back:

; 1282 : 			_Orphan_range(this->_Mylast(), this->_Mylast());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAEAAPAUTile@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Mylast
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAEAAPAUTile@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Mylast
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_range@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@IBEXPAUTile@@0@Z ; std::vector<Tile,std::allocator<Tile> >::_Orphan_range

; 1283 : 			this->_Getal().construct(_Unfancy(this->_Mylast()),

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAEAAPAUTile@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Myfirst
	mov	ecx, DWORD PTR __Idx$1[ebp]
	shl	ecx, 5
	add	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAEAAPAUTile@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Mylast
	mov	edx, DWORD PTR [eax]
	push	edx
	call	??$_Unfancy@UTile@@@std@@YAPAUTile@@PAU1@@Z ; std::_Unfancy<Tile>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@UTile@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Getal
	mov	ecx, eax
	call	??$construct@UTile@@AAU1@@?$_Wrap_alloc@V?$allocator@UTile@@@std@@@std@@QAEXPAUTile@@AAU2@@Z ; std::_Wrap_alloc<std::allocator<Tile> >::construct<Tile,Tile &>

; 1284 : 				this->_Myfirst()[_Idx]);
; 1285 : 			++this->_Mylast();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAEAAPAUTile@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Mylast
	mov	DWORD PTR tv176[ebp], eax
	mov	eax, DWORD PTR tv176[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 32					; 00000020H
	mov	edx, DWORD PTR tv176[ebp]
	mov	DWORD PTR [edx], ecx

; 1286 : 			}
; 1287 : 		else

	jmp	$LN1@push_back
$LN2@push_back:

; 1288 : 			{	// push back a non-element
; 1289 : 			if (this->_Mylast() == this->_Myend())

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAEAAPAUTile@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Mylast
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myend@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAEAAPAUTile@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Myend
	mov	ecx, DWORD PTR [esi]
	cmp	ecx, DWORD PTR [eax]
	jne	SHORT $LN5@push_back

; 1290 : 				_Reserve(1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Reserve@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@IAEXI@Z ; std::vector<Tile,std::allocator<Tile> >::_Reserve
$LN5@push_back:

; 1291 : 			_Orphan_range(this->_Mylast(), this->_Mylast());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAEAAPAUTile@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Mylast
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAEAAPAUTile@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Mylast
	mov	ecx, DWORD PTR [eax]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_range@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@IBEXPAUTile@@0@Z ; std::vector<Tile,std::allocator<Tile> >::_Orphan_range

; 1292 : 			this->_Getal().construct(_Unfancy(this->_Mylast()),

	mov	eax, DWORD PTR __Val$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAEAAPAUTile@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Mylast
	mov	ecx, DWORD PTR [eax]
	push	ecx
	call	??$_Unfancy@UTile@@@std@@YAPAUTile@@PAU1@@Z ; std::_Unfancy<Tile>
	add	esp, 4
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@UTile@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Getal
	mov	ecx, eax
	call	??$construct@UTile@@ABU1@@?$_Wrap_alloc@V?$allocator@UTile@@@std@@@std@@QAEXPAUTile@@ABU2@@Z ; std::_Wrap_alloc<std::allocator<Tile> >::construct<Tile,Tile const &>

; 1293 : 				_Val);
; 1294 : 			++this->_Mylast();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAEAAPAUTile@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Mylast
	mov	DWORD PTR tv231[ebp], eax
	mov	eax, DWORD PTR tv231[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 32					; 00000020H
	mov	edx, DWORD PTR tv231[ebp]
	mov	DWORD PTR [edx], ecx
$LN1@push_back:

; 1295 : 			}
; 1296 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 220				; 000000dcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?push_back@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QAEXABUTile@@@Z ENDP ; std::vector<Tile,std::allocator<Tile> >::push_back
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?max_size@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
$T1 = -209						; size = 1
_this$ = -8						; size = 4
?max_size@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QBEIXZ PROC ; std::vector<Tile,std::allocator<Tile> >::max_size, COMDAT
; _this$ = ecx

; 1184 : 		{	// return maximum possible length of sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1185 : 		return (this->_Getal().max_size());

	movzx	eax, BYTE PTR $T1[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@UTile@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Getal
	mov	ecx, eax
	call	?max_size@?$_Wrap_alloc@V?$allocator@UTile@@@std@@@std@@QBEIU_Nil@2@@Z ; std::_Wrap_alloc<std::allocator<Tile> >::max_size

; 1186 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QBEIXZ ENDP ; std::vector<Tile,std::allocator<Tile> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?size@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?size@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QBEIXZ PROC ; std::vector<Tile,std::allocator<Tile> >::size, COMDAT
; _this$ = ecx

; 1179 : 		{	// return length of sequence

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1180 : 		return (this->_Mylast() - this->_Myfirst());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QBEABQAUTile@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Mylast
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QBEABQAUTile@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Myfirst
	mov	ecx, DWORD PTR [esi]
	sub	ecx, DWORD PTR [eax]
	sar	ecx, 5
	mov	eax, ecx

; 1181 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?size@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QBEIXZ ENDP ; std::vector<Tile,std::allocator<Tile> >::size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Make_iter@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@2@@Z
_TEXT	SEGMENT
$T2 = -224						; size = 4
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
__Where$ = 12						; size = 12
?_Make_iter@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@2@@Z PROC ; std::vector<Tile,std::allocator<Tile> >::_Make_iter, COMDAT
; _this$ = ecx

; 1077 : 		{	// make iterator from const_iterator

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Make_iter@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx
	mov	DWORD PTR $T2[ebp], 0
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 1078 : 		return (iterator(_Where._Ptr, &this->_Get_data()));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@UTile@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Get_data
	push	eax
	mov	eax, DWORD PTR __Where$[ebp+8]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAE@PAUTile@@PBU_Container_base12@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Tile> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<Tile> > >
	mov	ecx, DWORD PTR $T2[ebp]
	or	ecx, 1
	mov	DWORD PTR $T2[ebp], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	lea	ecx, DWORD PTR __Where$[ebp]
	call	??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1079 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Make_iter@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@2@@Z$0:
	lea	ecx, DWORD PTR __Where$[ebp]
	jmp	??1?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAE@XZ
__ehhandler$?_Make_iter@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-232]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Make_iter@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Make_iter@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QBE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@2@V?$_Vector_const_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@2@@Z ENDP ; std::vector<Tile,std::allocator<Tile> >::_Make_iter
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?end@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
?end@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@2@XZ PROC ; std::vector<Tile,std::allocator<Tile> >::end, COMDAT
; _this$ = ecx

; 1067 : 		{	// return iterator for end of mutable sequence

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?end@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@2@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1068 : 		return (iterator(this->_Mylast(), &this->_Get_data()));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UTile@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Get_data
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAEAAPAUTile@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Mylast
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAE@PAUTile@@PBU_Container_base12@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Tile> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<Tile> > >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1069 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?end@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@2@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?end@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@2@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?end@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@2@XZ ENDP ; std::vector<Tile,std::allocator<Tile> >::end
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?begin@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
?begin@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@2@XZ PROC ; std::vector<Tile,std::allocator<Tile> >::begin, COMDAT
; _this$ = ecx

; 1057 : 		{	// return iterator for beginning of mutable sequence

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?begin@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@2@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 1058 : 		return (iterator(this->_Myfirst(), &this->_Get_data()));

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UTile@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Get_data
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAEAAPAUTile@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Myfirst
	mov	eax, DWORD PTR [eax]
	push	eax
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@std@@QAE@PAUTile@@PBU_Container_base12@1@@Z ; std::_Vector_iterator<std::_Vector_val<std::_Simple_types<Tile> > >::_Vector_iterator<std::_Vector_val<std::_Simple_types<Tile> > >
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 1059 : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$?begin@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@2@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?begin@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@2@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?begin@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QAE?AV?$_Vector_iterator@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@@2@XZ ENDP ; std::vector<Tile,std::allocator<Tile> >::begin
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Unused_capacity@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Unused_capacity@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QBEIXZ PROC ; std::vector<Tile,std::allocator<Tile> >::_Unused_capacity, COMDAT
; _this$ = ecx

; 1047 : 		{	// micro-optimization for capacity() - size()

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1048 : 		return (this->_Myend() - this->_Mylast());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myend@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QBEABQAUTile@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Myend
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QBEABQAUTile@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Mylast
	mov	ecx, DWORD PTR [esi]
	sub	ecx, DWORD PTR [eax]
	sar	ecx, 5
	mov	eax, ecx

; 1049 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Unused_capacity@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QBEIXZ ENDP ; std::vector<Tile,std::allocator<Tile> >::_Unused_capacity
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?capacity@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?capacity@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QBEIXZ PROC ; std::vector<Tile,std::allocator<Tile> >::capacity, COMDAT
; _this$ = ecx

; 1042 : 		{	// return current length of allocated storage

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1043 : 		return (this->_Myend() - this->_Myfirst());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myend@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QBEABQAUTile@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Myend
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QBEABQAUTile@@XZ ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Myfirst
	mov	ecx, DWORD PTR [esi]
	sub	ecx, DWORD PTR [eax]
	sar	ecx, 5
	mov	eax, ecx

; 1044 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?capacity@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QBEIXZ ENDP ; std::vector<Tile,std::allocator<Tile> >::capacity
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??1?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??1?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QAE@XZ PROC ; std::vector<Tile,std::allocator<Tile> >::~vector<Tile,std::allocator<Tile> >, COMDAT
; _this$ = ecx

; 975  : 		{	// destroy the object

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 976  : 		_Tidy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Tidy@?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@IAEXXZ ; std::vector<Tile,std::allocator<Tile> >::_Tidy

; 977  : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::~_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QAE@XZ ENDP ; std::vector<Tile,std::allocator<Tile> >::~vector<Tile,std::allocator<Tile> >
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??0?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QAE@XZ PROC ; std::vector<Tile,std::allocator<Tile> >::vector<Tile,std::allocator<Tile> >, COMDAT
; _this$ = ecx

; 707  : 		{	// construct empty vector

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 706  : 		: _Mybase()

	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAE@XZ ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >

; 708  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??0?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$vector@UTile@@V?$allocator@UTile@@@std@@@std@@QAE@XZ ENDP ; std::vector<Tile,std::allocator<Tile> >::vector<Tile,std::allocator<Tile> >
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UTile@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@2@$00@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UTile@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@2@$00@std@@QAE@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Tile> >,std::_Vector_val<std::_Simple_types<Tile> >,1>::~_Compressed_pair<std::_Wrap_alloc<std::allocator<Tile> >,std::_Vector_val<std::_Simple_types<Tile> >,1>, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@QAE@XZ
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UTile@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@2@$00@std@@QAE@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Tile> >,std::_Vector_val<std::_Simple_types<Tile> >,1>::~_Compressed_pair<std::_Wrap_alloc<std::allocator<Tile> >,std::_Vector_val<std::_Simple_types<Tile> >,1>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UTile@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@UTile@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UTile@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@UTile@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Tile> >,std::_Vector_val<std::_Simple_types<Tile> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 319  : 		{	// return const reference to second

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 320  : 		return (_Myval2);

	mov	eax, DWORD PTR _this$[ebp]

; 321  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UTile@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@UTile@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Tile> >,std::_Vector_val<std::_Simple_types<Tile> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UTile@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UTile@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UTile@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UTile@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Tile> >,std::_Vector_val<std::_Simple_types<Tile> >,1>::_Get_second, COMDAT
; _this$ = ecx

; 314  : 		{	// return reference to second

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 315  : 		return (_Myval2);

	mov	eax, DWORD PTR _this$[ebp]

; 316  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UTile@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UTile@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Tile> >,std::_Vector_val<std::_Simple_types<Tile> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UTile@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@UTile@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UTile@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@UTile@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Tile> >,std::_Vector_val<std::_Simple_types<Tile> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 299  : 		{	// return const reference to first

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 300  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 301  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UTile@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@UTile@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Tile> >,std::_Vector_val<std::_Simple_types<Tile> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UTile@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@UTile@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UTile@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@UTile@@@std@@@2@XZ PROC ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Tile> >,std::_Vector_val<std::_Simple_types<Tile> >,1>::_Get_first, COMDAT
; _this$ = ecx

; 294  : 		{	// return reference to first

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 295  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 296  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UTile@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@UTile@@@std@@@2@XZ ENDP ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Tile> >,std::_Vector_val<std::_Simple_types<Tile> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
;	COMDAT ??1?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??1?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<Tile> >::~_Vector_val<std::_Simple_types<Tile> >, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??1_Container_base12@std@@QAE@XZ	; std::_Container_base12::~_Container_base12
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??1?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<Tile> >::~_Vector_val<std::_Simple_types<Tile> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@QAE@XZ PROC ; std::_Vector_val<std::_Simple_types<Tile> >::_Vector_val<std::_Simple_types<Tile> >, COMDAT
; _this$ = ecx

; 488  : 		{	// initialize values

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	??0_Container_base12@std@@QAE@XZ	; std::_Container_base12::_Container_base12

; 485  : 		: _Myfirst(),

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 486  : 		_Mylast(),

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+8], 0

; 487  : 		_Myend()

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+12], 0

; 489  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Vector_val@U?$_Simple_types@UTile@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_val<std::_Simple_types<Tile> >::_Vector_val<std::_Simple_types<Tile> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QBEABQAUTile@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QBEABQAUTile@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Myend, COMDAT
; _this$ = ecx

; 667  : 		{	// return const reference to _Myend

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 668  : 		return (_Get_data()._Myend);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@UTile@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Get_data
	add	eax, 12					; 0000000cH

; 669  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QBEABQAUTile@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Myend
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myend@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAEAAPAUTile@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAEAAPAUTile@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Myend, COMDAT
; _this$ = ecx

; 662  : 		{	// return reference to _Myend

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 663  : 		return (_Get_data()._Myend);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UTile@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Get_data
	add	eax, 12					; 0000000cH

; 664  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Myend@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAEAAPAUTile@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Myend
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QBEABQAUTile@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QBEABQAUTile@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Mylast, COMDAT
; _this$ = ecx

; 657  : 		{	// return const reference to _Mylast

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 658  : 		return (_Get_data()._Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@UTile@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Get_data
	add	eax, 8

; 659  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QBEABQAUTile@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAEAAPAUTile@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAEAAPAUTile@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Mylast, COMDAT
; _this$ = ecx

; 652  : 		{	// return reference to _Mylast

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 653  : 		return (_Get_data()._Mylast);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UTile@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Get_data
	add	eax, 8

; 654  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Mylast@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAEAAPAUTile@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Mylast
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QBEABQAUTile@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QBEABQAUTile@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Myfirst, COMDAT
; _this$ = ecx

; 647  : 		{	// return const reference to _Myfirst

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 648  : 		return (_Get_data()._Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@UTile@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Get_data
	add	eax, 4

; 649  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QBEABQAUTile@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAEAAPAUTile@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAEAAPAUTile@@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Myfirst, COMDAT
; _this$ = ecx

; 642  : 		{	// return reference to _Myfirst

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 643  : 		return (_Get_data()._Myfirst);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UTile@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Get_data
	add	eax, 4

; 644  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Myfirst@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAEAAPAUTile@@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Myfirst
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@UTile@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@UTile@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Get_data, COMDAT
; _this$ = ecx

; 637  : 		{	// return const reference to _Vector_val

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 638  : 		return (_Mypair._Get_second());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UTile@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@2@$00@std@@QBEABV?$_Vector_val@U?$_Simple_types@UTile@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Tile> >,std::_Vector_val<std::_Simple_types<Tile> >,1>::_Get_second

; 639  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@UTile@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UTile@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UTile@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Get_data, COMDAT
; _this$ = ecx

; 632  : 		{	// return reference to _Vector_val

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 633  : 		return (_Mypair._Get_second());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_second@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UTile@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@2@$00@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UTile@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Tile> >,std::_Vector_val<std::_Simple_types<Tile> >,1>::_Get_second

; 634  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UTile@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@UTile@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@UTile@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Getal, COMDAT
; _this$ = ecx

; 627  : 		{	// return const reference to allocator

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 628  : 		return (_Mypair._Get_first());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UTile@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@2@$00@std@@QBEABU?$_Wrap_alloc@V?$allocator@UTile@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Tile> >,std::_Vector_val<std::_Simple_types<Tile> >,1>::_Get_first

; 629  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QBEABU?$_Wrap_alloc@V?$allocator@UTile@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Getal@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@UTile@@@std@@@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@UTile@@@std@@@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Getal, COMDAT
; _this$ = ecx

; 622  : 		{	// return reference to allocator

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 623  : 		return (_Mypair._Get_first());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_first@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UTile@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@2@$00@std@@QAEAAU?$_Wrap_alloc@V?$allocator@UTile@@@std@@@2@XZ ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Tile> >,std::_Vector_val<std::_Simple_types<Tile> >,1>::_Get_first

; 624  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Getal@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@UTile@@@std@@@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAEXXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Orphan_all, COMDAT
; _this$ = ecx

; 612  : 		{	// orphan all iterators

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 613  : 		_Get_data()._Orphan_all();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UTile@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Get_data
	mov	ecx, eax
	call	?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all

; 614  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAEXXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Myproxy@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Myproxy@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Myproxy, COMDAT
; _this$ = ecx

; 601  : 		{	// return reference to _Myproxy

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 602  : 		return (_Get_data()._Myproxy);

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UTile@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Get_data

; 603  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Myproxy@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Myproxy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Getpfirst@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QBEPAPAU_Iterator_base12@2@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Getpfirst@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QBEPAPAU_Iterator_base12@2@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Getpfirst, COMDAT
; _this$ = ecx

; 596  : 		{	// get address of iterator chain

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 597  : 		return (_Get_data()._Getpfirst());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QBEABV?$_Vector_val@U?$_Simple_types@UTile@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Get_data
	mov	ecx, eax
	call	?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ ; std::_Container_base12::_Getpfirst

; 598  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Getpfirst@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QBEPAPAU_Iterator_base12@2@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Getpfirst
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Free_proxy@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
__Alproxy$ = -21					; size = 1
_this$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
?_Free_proxy@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAEXXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Free_proxy, COMDAT
; _this$ = ecx

; 586  : 		{	// destroy proxy

	push	ebp
	mov	ebp, esp
	sub	esp, 220				; 000000dcH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-220]
	mov	ecx, 55					; 00000037H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 587  : 		typename _Alty::template rebind<_Container_proxy>::other
; 588  : 			_Alproxy(_Getal());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@UTile@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Getal
	push	eax
	lea	ecx, DWORD PTR __Alproxy$[ebp]
	call	??$?0AAU?$_Wrap_alloc@V?$allocator@UTile@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAU?$_Wrap_alloc@V?$allocator@UTile@@@std@@@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::_Wrap_alloc<std::allocator<std::_Container_proxy> ><std::_Wrap_alloc<std::allocator<Tile> > &>

; 589  : 		_Orphan_all();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_all@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Orphan_all

; 590  : 		_Alproxy.destroy(_Myproxy());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myproxy@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Myproxy
	mov	eax, DWORD PTR [eax]
	push	eax
	lea	ecx, DWORD PTR __Alproxy$[ebp]
	call	??$destroy@U_Container_proxy@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::destroy<std::_Container_proxy>

; 591  : 		_Alproxy.deallocate(_Alproxy.address(*_Myproxy()), 1);

	push	1
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myproxy@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Myproxy
	mov	eax, DWORD PTR [eax]
	push	eax
	lea	ecx, DWORD PTR __Alproxy$[ebp]
	call	?address@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QBEPAU_Container_proxy@2@AAU32@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::address
	push	eax
	lea	ecx, DWORD PTR __Alproxy$[ebp]
	call	?deallocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::deallocate

; 592  : 		_Myproxy() = 0;

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myproxy@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Myproxy
	mov	DWORD PTR [eax], 0

; 593  : 		}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@Free_proxy
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 220				; 000000dcH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@Free_proxy:
	DD	1
	DD	$LN4@Free_proxy
$LN4@Free_proxy:
	DD	-21					; ffffffebH
	DD	1
	DD	$LN3@Free_proxy
$LN3@Free_proxy:
	DB	95					; 0000005fH
	DB	65					; 00000041H
	DB	108					; 0000006cH
	DB	112					; 00000070H
	DB	114					; 00000072H
	DB	111					; 0000006fH
	DB	120					; 00000078H
	DB	121					; 00000079H
	DB	0
?_Free_proxy@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAEXXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Free_proxy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ?_Alloc_proxy@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAEXXZ
_TEXT	SEGMENT
$T1 = -232						; size = 8
__Alproxy$ = -21					; size = 1
_this$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
?_Alloc_proxy@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAEXXZ PROC ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Alloc_proxy, COMDAT
; _this$ = ecx

; 577  : 		{	// construct proxy

	push	ebp
	mov	ebp, esp
	sub	esp, 236				; 000000ecH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-236]
	mov	ecx, 59					; 0000003bH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 578  : 		typename _Alty::template rebind<_Container_proxy>::other
; 579  : 			_Alproxy(_Getal());

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Getal@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAEAAU?$_Wrap_alloc@V?$allocator@UTile@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Getal
	push	eax
	lea	ecx, DWORD PTR __Alproxy$[ebp]
	call	??$?0AAU?$_Wrap_alloc@V?$allocator@UTile@@@std@@@std@@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAE@AAU?$_Wrap_alloc@V?$allocator@UTile@@@std@@@1@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::_Wrap_alloc<std::allocator<std::_Container_proxy> ><std::_Wrap_alloc<std::allocator<Tile> > &>

; 580  : 		_Myproxy() = _Unfancy(_Alproxy.allocate(1));

	push	1
	lea	ecx, DWORD PTR __Alproxy$[ebp]
	call	?allocate@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEPAU_Container_proxy@2@I@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::allocate
	push	eax
	call	??$_Unfancy@U_Container_proxy@std@@@std@@YAPAU_Container_proxy@0@PAU10@@Z ; std::_Unfancy<std::_Container_proxy>
	add	esp, 4
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myproxy@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Myproxy
	mov	DWORD PTR [eax], esi

; 581  : 		_Alproxy.construct(_Myproxy(), _Container_proxy());

	lea	ecx, DWORD PTR $T1[ebp]
	call	??0_Container_proxy@std@@QAE@XZ		; std::_Container_proxy::_Container_proxy
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myproxy@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Myproxy
	mov	eax, DWORD PTR [eax]
	push	eax
	lea	ecx, DWORD PTR __Alproxy$[ebp]
	call	??$construct@U_Container_proxy@std@@U12@@?$_Wrap_alloc@V?$allocator@U_Container_proxy@std@@@std@@@std@@QAEXPAU_Container_proxy@1@$$QAU21@@Z ; std::_Wrap_alloc<std::allocator<std::_Container_proxy> >::construct<std::_Container_proxy,std::_Container_proxy>

; 582  : 		_Myproxy()->_Mycont = &_Get_data();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Get_data@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAEAAV?$_Vector_val@U?$_Simple_types@UTile@@@std@@@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Get_data
	mov	esi, eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Myproxy@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAEAAPAU_Container_proxy@2@XZ ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Myproxy
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [eax], esi

; 583  : 		}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN5@Alloc_prox
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 236				; 000000ecH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN5@Alloc_prox:
	DD	1
	DD	$LN4@Alloc_prox
$LN4@Alloc_prox:
	DD	-21					; ffffffebH
	DD	1
	DD	$LN3@Alloc_prox
$LN3@Alloc_prox:
	DB	95					; 0000005fH
	DB	65					; 00000041H
	DB	108					; 0000006cH
	DB	112					; 00000070H
	DB	114					; 00000072H
	DB	111					; 0000006fH
	DB	120					; 00000078H
	DB	121					; 00000079H
	DB	0
?_Alloc_proxy@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAEXXZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Alloc_proxy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??1?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??1?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::~_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >, COMDAT
; _this$ = ecx

; 558  : 		{	// destroy proxy

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 559  : 		_Free_proxy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Free_proxy@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Free_proxy

; 560  : 		}

	mov	ecx, DWORD PTR _this$[ebp]
	call	??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UTile@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@2@$00@std@@QAE@XZ
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::~_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vector
;	COMDAT ??0?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
$T2 = -221						; size = 1
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??0?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAE@XZ PROC ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >, COMDAT
; _this$ = ecx

; 544  : 		{	// default construct allocator

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??0?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-228]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 543  : 		: _Mypair(_Zero_then_variadic_args_t())

	movzx	eax, BYTE PTR $T2[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??$?0$$V@?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UTile@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@2@$00@std@@QAE@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::_Wrap_alloc<std::allocator<Tile> >,std::_Vector_val<std::_Simple_types<Tile> >,1>::_Compressed_pair<std::_Wrap_alloc<std::allocator<Tile> >,std::_Vector_val<std::_Simple_types<Tile> >,1><>
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 545  : 		_Alloc_proxy();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Alloc_proxy@?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAEXXZ ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Alloc_proxy

; 546  : 		}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 228				; 000000e4H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??0?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAE@XZ$0:
	mov	ecx, DWORD PTR _this$[ebp]
	jmp	??1?$_Compressed_pair@U?$_Wrap_alloc@V?$allocator@UTile@@@std@@@std@@V?$_Vector_val@U?$_Simple_types@UTile@@@std@@@2@$00@std@@QAE@XZ
__ehhandler$??0?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-232]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??0?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??0?$_Vector_alloc@U?$_Vec_base_types@UTile@@V?$allocator@UTile@@@std@@@std@@@std@@QAE@XZ ENDP ; std::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >::_Vector_alloc<std::_Vec_base_types<Tile,std::allocator<Tile> > >
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$_Wrap_alloc@V?$allocator@UTile@@@std@@@std@@QBEIU_Nil@2@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
___formal$ = 8						; size = 1
?max_size@?$_Wrap_alloc@V?$allocator@UTile@@@std@@@std@@QBEIU_Nil@2@@Z PROC ; std::_Wrap_alloc<std::allocator<Tile> >::max_size, COMDAT
; _this$ = ecx

; 1007 : 		{	// get maximum size

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 1008 : 		return (_Mytraits::max_size(*this));

	mov	eax, DWORD PTR _this$[ebp]
	push	eax
	call	?max_size@?$allocator_traits@V?$allocator@UTile@@@std@@@std@@SAIABV?$allocator@UTile@@@2@@Z ; std::allocator_traits<std::allocator<Tile> >::max_size
	add	esp, 4

; 1009 : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?max_size@?$_Wrap_alloc@V?$allocator@UTile@@@std@@@std@@QBEIU_Nil@2@@Z ENDP ; std::_Wrap_alloc<std::allocator<Tile> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$_Wrap_alloc@V?$allocator@UTile@@@std@@@std@@QAEXPAUTile@@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$_Wrap_alloc@V?$allocator@UTile@@@std@@@std@@QAEXPAUTile@@I@Z PROC ; std::_Wrap_alloc<std::allocator<Tile> >::deallocate, COMDAT
; _this$ = ecx

; 986  : 		{	// deallocate object at _Ptr, ignore size

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 987  : 		_Mybase::deallocate(_Ptr, _Count);

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?deallocate@?$allocator@UTile@@@std@@QAEXPAUTile@@I@Z ; std::allocator<Tile>::deallocate

; 988  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$_Wrap_alloc@V?$allocator@UTile@@@std@@@std@@QAEXPAUTile@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<Tile> >::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$_Wrap_alloc@V?$allocator@UTile@@@std@@@std@@QAEPAUTile@@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Count$ = 8						; size = 4
?allocate@?$_Wrap_alloc@V?$allocator@UTile@@@std@@@std@@QAEPAUTile@@I@Z PROC ; std::_Wrap_alloc<std::allocator<Tile> >::allocate, COMDAT
; _this$ = ecx

; 975  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 976  : 		return (_Mybase::allocate(_Count));

	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	?allocate@?$allocator@UTile@@@std@@QAEPAUTile@@I@Z ; std::allocator<Tile>::allocate

; 977  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$_Wrap_alloc@V?$allocator@UTile@@@std@@@std@@QAEPAUTile@@I@Z ENDP ; std::_Wrap_alloc<std::allocator<Tile> >::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$_Wrap_alloc@V?$allocator@UTile@@@std@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$_Wrap_alloc@V?$allocator@UTile@@@std@@@std@@QAE@XZ PROC ; std::_Wrap_alloc<std::allocator<Tile> >::_Wrap_alloc<std::allocator<Tile> >, COMDAT
; _this$ = ecx

; 936  : 		{	// construct default allocator (do nothing)

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 935  : 		: _Mybase()

	mov	ecx, DWORD PTR _this$[ebp]
	call	??0?$allocator@UTile@@@std@@QAE@XZ	; std::allocator<Tile>::allocator<Tile>

; 937  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$_Wrap_alloc@V?$allocator@UTile@@@std@@@std@@QAE@XZ ENDP ; std::_Wrap_alloc<std::allocator<Tile> >::_Wrap_alloc<std::allocator<Tile> >
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator_traits@V?$allocator@UTile@@@std@@@std@@SAIABV?$allocator@UTile@@@2@@Z
_TEXT	SEGMENT
__Al$ = 8						; size = 4
?max_size@?$allocator_traits@V?$allocator@UTile@@@std@@@std@@SAIABV?$allocator@UTile@@@2@@Z PROC ; std::allocator_traits<std::allocator<Tile> >::max_size, COMDAT

; 868  : 		{	// get maximum size

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 869  : 		return (_Al.max_size());

	mov	ecx, DWORD PTR __Al$[ebp]
	call	?max_size@?$allocator@UTile@@@std@@QBEIXZ ; std::allocator<Tile>::max_size

; 870  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator_traits@V?$allocator@UTile@@@std@@@std@@SAIABV?$allocator@UTile@@@2@@Z ENDP ; std::allocator_traits<std::allocator<Tile> >::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?max_size@?$allocator@UTile@@@std@@QBEIXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?max_size@?$allocator@UTile@@@std@@QBEIXZ PROC		; std::allocator<Tile>::max_size, COMDAT
; _this$ = ecx

; 748  : 		{	// estimate maximum array size

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 749  : 		return ((size_t)(-1) / sizeof (_Ty));

	mov	eax, 134217727				; 07ffffffH

; 750  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?max_size@?$allocator@UTile@@@std@@QBEIXZ ENDP		; std::allocator<Tile>::max_size
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?allocate@?$allocator@UTile@@@std@@QAEPAUTile@@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Count$ = 8						; size = 4
?allocate@?$allocator@UTile@@@std@@QAEPAUTile@@I@Z PROC	; std::allocator<Tile>::allocate, COMDAT
; _this$ = ecx

; 724  : 		{	// allocate array of _Count elements

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 725  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof (_Ty))));

	push	1
	push	32					; 00000020H
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	call	?_Allocate@std@@YAPAXII_N@Z		; std::_Allocate
	add	esp, 12					; 0000000cH

; 726  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?allocate@?$allocator@UTile@@@std@@QAEPAUTile@@I@Z ENDP	; std::allocator<Tile>::allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?deallocate@?$allocator@UTile@@@std@@QAEXPAUTile@@I@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
?deallocate@?$allocator@UTile@@@std@@QAEXPAUTile@@I@Z PROC ; std::allocator<Tile>::deallocate, COMDAT
; _this$ = ecx

; 719  : 		{	// deallocate object at _Ptr

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 720  : 		_Deallocate(_Ptr, _Count, sizeof (_Ty));

	push	32					; 00000020H
	mov	eax, DWORD PTR __Count$[ebp]
	push	eax
	mov	ecx, DWORD PTR __Ptr$[ebp]
	push	ecx
	call	?_Deallocate@std@@YAXPAXII@Z		; std::_Deallocate
	add	esp, 12					; 0000000cH

; 721  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	8
?deallocate@?$allocator@UTile@@@std@@QAEXPAUTile@@I@Z ENDP ; std::allocator<Tile>::deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ??0?$allocator@UTile@@@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0?$allocator@UTile@@@std@@QAE@XZ PROC			; std::allocator<Tile>::allocator<Tile>, COMDAT
; _this$ = ecx

; 699  : 	allocator() _THROW0()

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 700  : 		{	// construct default allocator (do nothing)
; 701  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0?$allocator@UTile@@@std@@QAE@XZ ENDP			; std::allocator<Tile>::allocator<Tile>
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File g:\projects\lotion\lotion\environment.h
;	COMDAT ?right@Tile@@QAENXZ
_TEXT	SEGMENT
tv73 = -212						; size = 8
_this$ = -8						; size = 4
?right@Tile@@QAENXZ PROC				; Tile::right, COMDAT
; _this$ = ecx

; 25   : 	inline double right() { return position.x + width; }

	push	ebp
	mov	ebp, esp
	sub	esp, 212				; 000000d4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-212]
	mov	ecx, 53					; 00000035H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	cvtsi2sd xmm0, DWORD PTR [eax+16]
	mov	ecx, DWORD PTR _this$[ebp]
	addsd	xmm0, QWORD PTR [ecx]
	movsd	QWORD PTR tv73[ebp], xmm0
	fld	QWORD PTR tv73[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?right@Tile@@QAENXZ ENDP				; Tile::right
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File g:\projects\lotion\lotion\environment.h
;	COMDAT ?left@Tile@@QAENXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?left@Tile@@QAENXZ PROC					; Tile::left, COMDAT
; _this$ = ecx

; 24   : 	inline double left() { return position.x; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	QWORD PTR [eax]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?left@Tile@@QAENXZ ENDP					; Tile::left
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File g:\projects\lotion\lotion\environment.h
;	COMDAT ?bottom@Tile@@QAENXZ
_TEXT	SEGMENT
tv73 = -212						; size = 8
_this$ = -8						; size = 4
?bottom@Tile@@QAENXZ PROC				; Tile::bottom, COMDAT
; _this$ = ecx

; 23   : 	inline double bottom() { return position.y + height; }

	push	ebp
	mov	ebp, esp
	sub	esp, 212				; 000000d4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-212]
	mov	ecx, 53					; 00000035H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	cvtsi2sd xmm0, DWORD PTR [eax+20]
	mov	ecx, DWORD PTR _this$[ebp]
	addsd	xmm0, QWORD PTR [ecx+8]
	movsd	QWORD PTR tv73[ebp], xmm0
	fld	QWORD PTR tv73[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?bottom@Tile@@QAENXZ ENDP				; Tile::bottom
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File g:\projects\lotion\lotion\environment.h
;	COMDAT ?top@Tile@@QAENXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?top@Tile@@QAENXZ PROC					; Tile::top, COMDAT
; _this$ = ecx

; 22   : 	inline double top() { return position.y; }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	fld	QWORD PTR [eax+8]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?top@Tile@@QAENXZ ENDP					; Tile::top
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File g:\projects\lotion\lotion\environment.h
;	COMDAT ??8Tile@@QBEHABU0@@Z
_TEXT	SEGMENT
tv74 = -208						; size = 4
_this$ = -8						; size = 4
_tile$ = 8						; size = 4
??8Tile@@QBEHABU0@@Z PROC				; Tile::operator==, COMDAT
; _this$ = ecx

; 18   : 	int operator==(const Tile& tile)const {

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 19   : 		return (position.x == tile.position.x) && (position.y == tile.position.y);

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR _tile$[ebp]
	movsd	xmm0, QWORD PTR [eax]
	ucomisd	xmm0, QWORD PTR [ecx]
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN3@operator
	mov	edx, DWORD PTR _this$[ebp]
	mov	eax, DWORD PTR _tile$[ebp]
	movsd	xmm0, QWORD PTR [edx+8]
	ucomisd	xmm0, QWORD PTR [eax+8]
	lahf
	test	ah, 68					; 00000044H
	jp	SHORT $LN3@operator
	mov	DWORD PTR tv74[ebp], 1
	jmp	SHORT $LN4@operator
$LN3@operator:
	mov	DWORD PTR tv74[ebp], 0
$LN4@operator:
	mov	eax, DWORD PTR tv74[ebp]

; 20   : 	}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
??8Tile@@QBEHABU0@@Z ENDP				; Tile::operator==
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File g:\projects\lotion\lotion\environment.h
;	COMDAT ?midpoint@Tile@@QAE?AVVector2@@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
___$ReturnUdt$ = 8					; size = 4
?midpoint@Tile@@QAE?AVVector2@@XZ PROC			; Tile::midpoint, COMDAT
; _this$ = ecx

; 16   : 	inline Vector2 midpoint() { return Vector2(position.x + (position.x / 2), position.y + (position.y / 2)); }

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx
	mov	eax, DWORD PTR _this$[ebp]
	movsd	xmm0, QWORD PTR [eax+8]
	divsd	xmm0, QWORD PTR __real@4000000000000000
	mov	ecx, DWORD PTR _this$[ebp]
	addsd	xmm0, QWORD PTR [ecx+8]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	mov	edx, DWORD PTR _this$[ebp]
	movsd	xmm0, QWORD PTR [edx]
	divsd	xmm0, QWORD PTR __real@4000000000000000
	mov	eax, DWORD PTR _this$[ebp]
	addsd	xmm0, QWORD PTR [eax]
	sub	esp, 8
	movsd	QWORD PTR [esp], xmm0
	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	call	??0Vector2@@QAE@NN@Z			; Vector2::Vector2
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
?midpoint@Tile@@QAE?AVVector2@@XZ ENDP			; Tile::midpoint
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?_Deallocate@std@@YAXPAXII@Z
_TEXT	SEGMENT
__Ptr_container$1 = -44					; size = 4
__Ptr_ptr$2 = -32					; size = 4
__Ptr_user$3 = -20					; size = 4
__User_size$ = -8					; size = 4
__Ptr$ = 8						; size = 4
__Count$ = 12						; size = 4
__Sz$ = 16						; size = 4
?_Deallocate@std@@YAXPAXII@Z PROC			; std::_Deallocate, COMDAT

; 92   : 	{	// deallocate storage for _Count elements of size _Sz

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 93   :  #if defined(_M_IX86) || defined(_M_X64)
; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Count <= (size_t)(-1) / _Sz);

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Sz$[ebp]
	cmp	DWORD PTR __Count$[ebp], eax
	jbe	SHORT $LN2@Deallocate
	mov	eax, OFFSET ??_C@_0BN@HMCJOMKN@_Count?5?$DM?$DN?5?$CIsize_t?$CJ?$CI?91?$CJ?5?1?5_Sz?$AA@
	test	eax, eax
	je	SHORT $LN10@Deallocate
	xor	ecx, ecx
	jne	SHORT $LN11@Deallocate
$LN10@Deallocate:
	mov	esi, esp
	push	OFFSET ??_C@_1EI@MLOBABC@?$AA?$CC?$AA_?$AAC?$AAo?$AAu?$AAn?$AAt?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA?$CI?$AAs?$AAi?$AAz?$AAe?$AA_?$AAt?$AA?$CJ?$AA?$CI?$AA?9?$AA1?$AA?$CJ?$AA?5?$AA?1?$AA?5?$AA_?$AAS?$AAz?$AA?$CC?$AA?5?$AA?$CG@
	push	OFFSET ??_C@_17CNPHIMPH@?$AA?$CF?$AAl?$AAs?$AA?$AA@
	push	0
	mov	edx, DWORD PTR ?__LINE__Var@?0??_Deallocate@std@@YAXPAXII@Z@4JA
	add	edx, 2
	push	edx
	push	OFFSET ??_C@_1JA@DKOIEICI@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	2
	call	DWORD PTR __imp___CrtDbgReportW
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN11@Deallocate
	int	3
$LN11@Deallocate:
	mov	esi, esp
	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??_Deallocate@std@@YAXPAXII@Z@4JA
	add	eax, 2
	push	eax
	push	OFFSET ??_C@_1JA@DKOIEICI@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	OFFSET ??_C@_1CC@LOFJFFDB@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAD?$AAe?$AAa?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAe?$AA?$AA@
	push	OFFSET ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN2@Deallocate:

; 95   : 	const size_t _User_size = _Count * _Sz;

	mov	eax, DWORD PTR __Count$[ebp]
	imul	eax, DWORD PTR __Sz$[ebp]
	mov	DWORD PTR __User_size$[ebp], eax

; 96   : 	if (_BIG_ALLOCATION_THRESHOLD <= _User_size)

	cmp	DWORD PTR __User_size$[ebp], 4096	; 00001000H
	jb	$LN3@Deallocate

; 97   : 		{	// deallocate large block
; 98   : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR __Ptr_user$3[ebp], eax

; 99   : 		_SCL_SECURE_ALWAYS_VALIDATE(

	mov	eax, DWORD PTR __Ptr_user$3[ebp]
	and	eax, 31					; 0000001fH
	je	SHORT $LN4@Deallocate
	mov	eax, OFFSET ??_C@_0DD@GBGGGKGG@?$CI_Ptr_user?5?$CG?5?$CI_BIG_ALLOCATION_AL@
	test	eax, eax
	je	SHORT $LN12@Deallocate
	xor	ecx, ecx
	jne	SHORT $LN13@Deallocate
$LN12@Deallocate:
	mov	esi, esp
	push	OFFSET ??_C@_1HE@CDMBFOKC@?$AA?$CC?$AA?$CI?$AA_?$AAP?$AAt?$AAr?$AA_?$AAu?$AAs?$AAe?$AAr?$AA?5?$AA?$CG?$AA?5?$AA?$CI?$AA_?$AAB?$AAI?$AAG?$AA_?$AAA?$AAL?$AAL?$AAO?$AAC?$AAA?$AAT?$AAI?$AAO?$AAN?$AA_?$AAA@
	push	OFFSET ??_C@_17CNPHIMPH@?$AA?$CF?$AAl?$AAs?$AA?$AA@
	push	0
	mov	edx, DWORD PTR ?__LINE__Var@?0??_Deallocate@std@@YAXPAXII@Z@4JA
	add	edx, 8
	push	edx
	push	OFFSET ??_C@_1JA@DKOIEICI@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	2
	call	DWORD PTR __imp___CrtDbgReportW
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN13@Deallocate
	int	3
$LN13@Deallocate:
	mov	esi, esp
	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??_Deallocate@std@@YAXPAXII@Z@4JA
	add	eax, 8
	push	eax
	push	OFFSET ??_C@_1JA@DKOIEICI@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	OFFSET ??_C@_1CC@LOFJFFDB@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAD?$AAe?$AAa?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAe?$AA?$AA@
	push	OFFSET ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN4@Deallocate:

; 100  : 			(_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) == 0);
; 101  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);

	mov	eax, DWORD PTR __Ptr_user$3[ebp]
	sub	eax, 4
	mov	DWORD PTR __Ptr_ptr$2[ebp], eax

; 102  : 		const uintptr_t _Ptr_container =
; 103  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

	mov	eax, DWORD PTR __Ptr_ptr$2[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Ptr_container$1[ebp], ecx

; 104  : 
; 105  :  #ifdef _DEBUG
; 106  : 		// If the following asserts, it likely means that we are performing
; 107  : 		// an aligned delete on memory coming from an unaligned allocation.
; 108  : 		_SCL_SECURE_ALWAYS_VALIDATE(

	mov	eax, 4
	imul	ecx, eax, -1
	mov	edx, DWORD PTR __Ptr_ptr$2[ebp]
	cmp	DWORD PTR [edx+ecx], -84215046		; fafafafaH
	je	SHORT $LN5@Deallocate
	mov	eax, OFFSET ??_C@_0EI@NOJHEJCJ@reinterpret_cast?$DMuintptr_t?5?$CK?$DO?$CI_P@
	test	eax, eax
	je	SHORT $LN14@Deallocate
	xor	ecx, ecx
	jne	SHORT $LN15@Deallocate
$LN14@Deallocate:
	mov	esi, esp
	push	OFFSET ??_C@_1JO@EKLKIEHP@?$AA?$CC?$AAr?$AAe?$AAi?$AAn?$AAt?$AAe?$AAr?$AAp?$AAr?$AAe?$AAt?$AA_?$AAc?$AAa?$AAs?$AAt?$AA?$DM?$AAu?$AAi?$AAn?$AAt?$AAp?$AAt?$AAr?$AA_?$AAt?$AA?5?$AA?$CK?$AA?$DO?$AA?$CI?$AA_@
	push	OFFSET ??_C@_17CNPHIMPH@?$AA?$CF?$AAl?$AAs?$AA?$AA@
	push	0
	mov	edx, DWORD PTR ?__LINE__Var@?0??_Deallocate@std@@YAXPAXII@Z@4JA
	add	edx, 18					; 00000012H
	push	edx
	push	OFFSET ??_C@_1JA@DKOIEICI@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	2
	call	DWORD PTR __imp___CrtDbgReportW
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN15@Deallocate
	int	3
$LN15@Deallocate:
	mov	esi, esp
	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??_Deallocate@std@@YAXPAXII@Z@4JA
	add	eax, 18					; 00000012H
	push	eax
	push	OFFSET ??_C@_1JA@DKOIEICI@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	OFFSET ??_C@_1CC@LOFJFFDB@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAD?$AAe?$AAa?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAe?$AA?$AA@
	push	OFFSET ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN5@Deallocate:

; 109  : 			reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] ==
; 110  : 				_BIG_ALLOCATION_SENTINEL);
; 111  :  #endif /* _DEBUG */
; 112  : 
; 113  : 		// Extra paranoia on aligned allocation/deallocation
; 114  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container < _Ptr_user);

	mov	eax, DWORD PTR __Ptr_container$1[ebp]
	cmp	eax, DWORD PTR __Ptr_user$3[ebp]
	jb	SHORT $LN6@Deallocate
	mov	eax, OFFSET ??_C@_0BL@OCKMEJON@_Ptr_container?5?$DM?5_Ptr_user?$AA@
	test	eax, eax
	je	SHORT $LN16@Deallocate
	xor	ecx, ecx
	jne	SHORT $LN17@Deallocate
$LN16@Deallocate:
	mov	esi, esp
	push	OFFSET ??_C@_1EE@PDHAHDDC@?$AA?$CC?$AA_?$AAP?$AAt?$AAr?$AA_?$AAc?$AAo?$AAn?$AAt?$AAa?$AAi?$AAn?$AAe?$AAr?$AA?5?$AA?$DM?$AA?5?$AA_?$AAP?$AAt?$AAr?$AA_?$AAu?$AAs?$AAe?$AAr?$AA?$CC?$AA?5?$AA?$CG?$AA?$CG?$AA?5@
	push	OFFSET ??_C@_17CNPHIMPH@?$AA?$CF?$AAl?$AAs?$AA?$AA@
	push	0
	mov	edx, DWORD PTR ?__LINE__Var@?0??_Deallocate@std@@YAXPAXII@Z@4JA
	add	edx, 22					; 00000016H
	push	edx
	push	OFFSET ??_C@_1JA@DKOIEICI@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	2
	call	DWORD PTR __imp___CrtDbgReportW
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN17@Deallocate
	int	3
$LN17@Deallocate:
	mov	esi, esp
	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??_Deallocate@std@@YAXPAXII@Z@4JA
	add	eax, 22					; 00000016H
	push	eax
	push	OFFSET ??_C@_1JA@DKOIEICI@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	OFFSET ??_C@_1CC@LOFJFFDB@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAD?$AAe?$AAa?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAe?$AA?$AA@
	push	OFFSET ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN6@Deallocate:

; 115  : 
; 116  :  #ifdef _DEBUG
; 117  : 		_SCL_SECURE_ALWAYS_VALIDATE(2 * sizeof(void *)

	mov	eax, DWORD PTR __Ptr_user$3[ebp]
	sub	eax, DWORD PTR __Ptr_container$1[ebp]
	cmp	eax, 8
	jae	SHORT $LN7@Deallocate
	mov	eax, OFFSET ??_C@_0DB@GLFJLNCE@2?5?$CK?5sizeof?$CIvoid?5?$CK?$CJ?5?$DM?$DN?5_Ptr_user?5@
	test	eax, eax
	je	SHORT $LN18@Deallocate
	xor	ecx, ecx
	jne	SHORT $LN19@Deallocate
$LN18@Deallocate:
	mov	esi, esp
	push	OFFSET ??_C@_1HA@NAPGMHAO@?$AA?$CC?$AA2?$AA?5?$AA?$CK?$AA?5?$AAs?$AAi?$AAz?$AAe?$AAo?$AAf?$AA?$CI?$AAv?$AAo?$AAi?$AAd?$AA?5?$AA?$CK?$AA?$CJ?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA_?$AAP?$AAt?$AAr?$AA_?$AAu?$AAs?$AAe?$AAr@
	push	OFFSET ??_C@_17CNPHIMPH@?$AA?$CF?$AAl?$AAs?$AA?$AA@
	push	0
	mov	edx, DWORD PTR ?__LINE__Var@?0??_Deallocate@std@@YAXPAXII@Z@4JA
	add	edx, 26					; 0000001aH
	push	edx
	push	OFFSET ??_C@_1JA@DKOIEICI@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	2
	call	DWORD PTR __imp___CrtDbgReportW
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN19@Deallocate
	int	3
$LN19@Deallocate:
	mov	esi, esp
	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??_Deallocate@std@@YAXPAXII@Z@4JA
	add	eax, 26					; 0000001aH
	push	eax
	push	OFFSET ??_C@_1JA@DKOIEICI@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	OFFSET ??_C@_1CC@LOFJFFDB@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAD?$AAe?$AAa?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAe?$AA?$AA@
	push	OFFSET ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN7@Deallocate:

; 118  : 			<= _Ptr_user - _Ptr_container);
; 119  : 
; 120  :  #else /* _DEBUG */
; 121  : 		_SCL_SECURE_ALWAYS_VALIDATE(sizeof(void *)
; 122  : 			<= _Ptr_user - _Ptr_container);
; 123  :  #endif /* _DEBUG */
; 124  : 
; 125  : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_user - _Ptr_container

	mov	eax, DWORD PTR __Ptr_user$3[ebp]
	sub	eax, DWORD PTR __Ptr_container$1[ebp]
	cmp	eax, 39					; 00000027H
	jbe	SHORT $LN8@Deallocate
	mov	eax, OFFSET ??_C@_0CN@BLHJCAL@_Ptr_user?5?9?5_Ptr_container?5?$DM?$DN?5_N@
	test	eax, eax
	je	SHORT $LN20@Deallocate
	xor	ecx, ecx
	jne	SHORT $LN21@Deallocate
$LN20@Deallocate:
	mov	esi, esp
	push	OFFSET ??_C@_1GI@DHJGPFNI@?$AA?$CC?$AA_?$AAP?$AAt?$AAr?$AA_?$AAu?$AAs?$AAe?$AAr?$AA?5?$AA?9?$AA?5?$AA_?$AAP?$AAt?$AAr?$AA_?$AAc?$AAo?$AAn?$AAt?$AAa?$AAi?$AAn?$AAe?$AAr?$AA?5?$AA?$DM?$AA?$DN?$AA?5?$AA_@
	push	OFFSET ??_C@_17CNPHIMPH@?$AA?$CF?$AAl?$AAs?$AA?$AA@
	push	0
	mov	edx, DWORD PTR ?__LINE__Var@?0??_Deallocate@std@@YAXPAXII@Z@4JA
	add	edx, 34					; 00000022H
	push	edx
	push	OFFSET ??_C@_1JA@DKOIEICI@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	2
	call	DWORD PTR __imp___CrtDbgReportW
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN21@Deallocate
	int	3
$LN21@Deallocate:
	mov	esi, esp
	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??_Deallocate@std@@YAXPAXII@Z@4JA
	add	eax, 34					; 00000022H
	push	eax
	push	OFFSET ??_C@_1JA@DKOIEICI@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	OFFSET ??_C@_1CC@LOFJFFDB@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAD?$AAe?$AAa?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAe?$AA?$AA@
	push	OFFSET ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN8@Deallocate:

; 126  : 			<= _NON_USER_SIZE);
; 127  : 
; 128  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

	mov	eax, DWORD PTR __Ptr_container$1[ebp]
	mov	DWORD PTR __Ptr$[ebp], eax
$LN3@Deallocate:

; 129  : 		}
; 130  :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 131  : 
; 132  : 	::operator delete(_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	push	eax
	call	??3@YAXPAX@Z				; operator delete
	add	esp, 4

; 133  : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Deallocate@std@@YAXPAXII@Z ENDP			; std::_Deallocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xmemory0
;	COMDAT ?_Allocate@std@@YAPAXII_N@Z
_TEXT	SEGMENT
__Ptr_container$1 = -44					; size = 4
__Block_size$2 = -32					; size = 4
__User_size$ = -20					; size = 4
__Ptr$ = -8						; size = 4
__Count$ = 8						; size = 4
__Sz$ = 12						; size = 4
__Try_aligned_allocation$ = 16				; size = 1
?_Allocate@std@@YAPAXII_N@Z PROC			; std::_Allocate, COMDAT

; 48   : 	{	// allocate storage for _Count elements of size _Sz

	push	ebp
	mov	ebp, esp
	sub	esp, 240				; 000000f0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-240]
	mov	ecx, 60					; 0000003cH
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 49   : 	void *_Ptr = 0;

	mov	DWORD PTR __Ptr$[ebp], 0

; 50   : 
; 51   : 	if (_Count == 0)

	cmp	DWORD PTR __Count$[ebp], 0
	jne	SHORT $LN2@Allocate

; 52   : 		return (_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
	jmp	$LN9@Allocate
$LN2@Allocate:

; 53   : 
; 54   : 	// check overflow of multiply
; 55   : 	if ((size_t)(-1) / _Sz < _Count)

	or	eax, -1
	xor	edx, edx
	div	DWORD PTR __Sz$[ebp]
	cmp	eax, DWORD PTR __Count$[ebp]
	jae	SHORT $LN3@Allocate

; 56   : 		_Xbad_alloc();	// report no memory

	mov	esi, esp
	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@Allocate:

; 57   : 	const size_t _User_size = _Count * _Sz;

	mov	eax, DWORD PTR __Count$[ebp]
	imul	eax, DWORD PTR __Sz$[ebp]
	mov	DWORD PTR __User_size$[ebp], eax

; 58   : 
; 59   :  #if defined(_M_IX86) || defined(_M_X64)
; 60   : 	if (_Try_aligned_allocation
; 61   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

	movzx	eax, BYTE PTR __Try_aligned_allocation$[ebp]
	test	eax, eax
	je	$LN4@Allocate
	cmp	DWORD PTR __User_size$[ebp], 4096	; 00001000H
	jb	$LN4@Allocate

; 62   : 		{	// allocate large block
; 63   : 		static_assert(sizeof (void *) < _BIG_ALLOCATION_ALIGNMENT,
; 64   : 			"Big allocations should at least match vector register size");
; 65   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

	mov	eax, DWORD PTR __User_size$[ebp]
	add	eax, 39					; 00000027H
	mov	DWORD PTR __Block_size$2[ebp], eax

; 66   : 		if (_Block_size <= _User_size)

	mov	eax, DWORD PTR __Block_size$2[ebp]
	cmp	eax, DWORD PTR __User_size$[ebp]
	ja	SHORT $LN6@Allocate

; 67   : 			_Xbad_alloc();	// report no memory

	mov	esi, esp
	call	DWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN6@Allocate:

; 68   : 		const uintptr_t _Ptr_container =
; 69   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

	mov	eax, DWORD PTR __Block_size$2[ebp]
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR __Ptr_container$1[ebp], eax

; 70   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);

	cmp	DWORD PTR __Ptr_container$1[ebp], 0
	jne	SHORT $LN7@Allocate
	mov	eax, OFFSET ??_C@_0BE@LMNLACIC@_Ptr_container?5?$CB?$DN?50?$AA@
	test	eax, eax
	je	SHORT $LN10@Allocate
	xor	ecx, ecx
	jne	SHORT $LN11@Allocate
$LN10@Allocate:
	mov	esi, esp
	push	OFFSET ??_C@_1DG@HGDKEBPG@?$AA?$CC?$AA_?$AAP?$AAt?$AAr?$AA_?$AAc?$AAo?$AAn?$AAt?$AAa?$AAi?$AAn?$AAe?$AAr?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0?$AA?$CC?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA0?$AA?$AA@
	push	OFFSET ??_C@_17CNPHIMPH@?$AA?$CF?$AAl?$AAs?$AA?$AA@
	push	0
	mov	edx, DWORD PTR ?__LINE__Var@?0??_Allocate@std@@YAPAXII_N@Z@4JA
	add	edx, 22					; 00000016H
	push	edx
	push	OFFSET ??_C@_1JA@DKOIEICI@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	2
	call	DWORD PTR __imp___CrtDbgReportW
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN11@Allocate
	int	3
$LN11@Allocate:
	mov	esi, esp
	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??_Allocate@std@@YAPAXII_N@Z@4JA
	add	eax, 22					; 00000016H
	push	eax
	push	OFFSET ??_C@_1JA@DKOIEICI@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	OFFSET ??_C@_1BO@NKFMJPA@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAe?$AA?$AA@
	push	OFFSET ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN7@Allocate:

; 71   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

	mov	eax, DWORD PTR __Ptr_container$1[ebp]
	add	eax, 39					; 00000027H
	and	eax, -32				; ffffffe0H
	mov	DWORD PTR __Ptr$[ebp], eax

; 72   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 73   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

	mov	eax, 4
	imul	ecx, eax, -1
	mov	edx, DWORD PTR __Ptr$[ebp]
	mov	eax, DWORD PTR __Ptr_container$1[ebp]
	mov	DWORD PTR [edx+ecx], eax

; 74   : 
; 75   :  #ifdef _DEBUG
; 76   : 		static_cast<uintptr_t *>(_Ptr)[-2] = _BIG_ALLOCATION_SENTINEL;

	mov	eax, 4
	imul	ecx, eax, -2
	mov	edx, DWORD PTR __Ptr$[ebp]
	mov	DWORD PTR [edx+ecx], -84215046		; fafafafaH

; 77   :  #endif /* _DEBUG */
; 78   : 		}
; 79   : 	else

	jmp	$LN5@Allocate
$LN4@Allocate:

; 80   :  #endif /* defined(_M_IX86) || defined(_M_X64) */
; 81   : 
; 82   : 		{	// allocate normal block
; 83   : 		_Ptr = ::operator new(_User_size);

	mov	eax, DWORD PTR __User_size$[ebp]
	push	eax
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR __Ptr$[ebp], eax

; 84   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);

	cmp	DWORD PTR __Ptr$[ebp], 0
	jne	SHORT $LN5@Allocate
	mov	eax, OFFSET ??_C@_09GLJCAGLP@_Ptr?5?$CB?$DN?50?$AA@
	test	eax, eax
	je	SHORT $LN12@Allocate
	xor	ecx, ecx
	jne	SHORT $LN13@Allocate
$LN12@Allocate:
	mov	esi, esp
	push	OFFSET ??_C@_1CC@GKJLLHIM@?$AA?$CC?$AA_?$AAP?$AAt?$AAr?$AA?5?$AA?$CB?$AA?$DN?$AA?5?$AA0?$AA?$CC?$AA?5?$AA?$CG?$AA?$CG?$AA?5?$AA0?$AA?$AA@
	push	OFFSET ??_C@_17CNPHIMPH@?$AA?$CF?$AAl?$AAs?$AA?$AA@
	push	0
	mov	edx, DWORD PTR ?__LINE__Var@?0??_Allocate@std@@YAPAXII_N@Z@4JA
	add	edx, 36					; 00000024H
	push	edx
	push	OFFSET ??_C@_1JA@DKOIEICI@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	2
	call	DWORD PTR __imp___CrtDbgReportW
	add	esp, 24					; 00000018H
	cmp	esi, esp
	call	__RTC_CheckEsp
	cmp	eax, 1
	jne	SHORT $LN13@Allocate
	int	3
$LN13@Allocate:
	mov	esi, esp
	push	0
	mov	eax, DWORD PTR ?__LINE__Var@?0??_Allocate@std@@YAPAXII_N@Z@4JA
	add	eax, 36					; 00000024H
	push	eax
	push	OFFSET ??_C@_1JA@DKOIEICI@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	OFFSET ??_C@_1BO@NKFMJPA@?$AAs?$AAt?$AAd?$AA?3?$AA?3?$AA_?$AAA?$AAl?$AAl?$AAo?$AAc?$AAa?$AAt?$AAe?$AA?$AA@
	push	OFFSET ??_C@_1CG@JNLFBNGN@?$AA?$CC?$AAi?$AAn?$AAv?$AAa?$AAl?$AAi?$AAd?$AA?5?$AAa?$AAr?$AAg?$AAu?$AAm?$AAe?$AAn?$AAt?$AA?$CC?$AA?$AA@
	call	DWORD PTR __imp___invalid_parameter
	add	esp, 20					; 00000014H
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN5@Allocate:

; 85   : 		}
; 86   : 	return (_Ptr);

	mov	eax, DWORD PTR __Ptr$[ebp]
$LN9@Allocate:

; 87   : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 240				; 000000f0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Allocate@std@@YAPAXII_N@Z ENDP			; std::_Allocate
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Orphan_me@_Iterator_base12@std@@QAEXXZ
_TEXT	SEGMENT
__Pnext$1 = -20						; size = 4
_this$ = -8						; size = 4
?_Orphan_me@_Iterator_base12@std@@QAEXXZ PROC		; std::_Iterator_base12::_Orphan_me, COMDAT
; _this$ = ecx

; 193  : 		{	// cut ties with parent

	push	ebp
	mov	ebp, esp
	sub	esp, 216				; 000000d8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 54					; 00000036H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 194  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 195  : 		if (_Myproxy != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN1@Orphan_me

; 196  : 			{	// adopted, remove self from list
; 197  : 			_Iterator_base12 **_Pnext = &_Myproxy->_Myfirstiter;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 4
	mov	DWORD PTR __Pnext$1[ebp], ecx
$LN2@Orphan_me:

; 198  : 			while (*_Pnext != 0 && *_Pnext != this)

	mov	eax, DWORD PTR __Pnext$1[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@Orphan_me
	mov	eax, DWORD PTR __Pnext$1[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR _this$[ebp]
	je	SHORT $LN3@Orphan_me

; 199  : 				_Pnext = &(*_Pnext)->_Mynextiter;

	mov	eax, DWORD PTR __Pnext$1[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 4
	mov	DWORD PTR __Pnext$1[ebp], ecx
	jmp	SHORT $LN2@Orphan_me
$LN3@Orphan_me:

; 200  : 
; 201  : 			if (*_Pnext == 0)

	mov	eax, DWORD PTR __Pnext$1[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN5@Orphan_me

; 202  : 				_DEBUG_ERROR("ITERATOR LIST CORRUPTED!");

	mov	esi, esp
	push	202					; 000000caH
	push	OFFSET ??_C@_1JA@MHADJNIL@?$AAc?$AA?3?$AA?2?$AAp?$AAr?$AAo?$AAg?$AAr?$AAa?$AAm?$AA?5?$AAf?$AAi?$AAl?$AAe?$AAs?$AA?5?$AA?$CI?$AAx?$AA8?$AA6?$AA?$CJ?$AA?2?$AAm?$AAi?$AAc?$AAr?$AAo?$AAs?$AAo?$AAf?$AAt@
	push	OFFSET ??_C@_1DC@POOIKBAO@?$AAI?$AAT?$AAE?$AAR?$AAA?$AAT?$AAO?$AAR?$AA?5?$AAL?$AAI?$AAS?$AAT?$AA?5?$AAC?$AAO?$AAR?$AAR?$AAU?$AAP?$AAT?$AAE?$AAD?$AA?$CB?$AA?$AA@
	call	DWORD PTR __imp_?_Debug_message@std@@YAXPB_W0I@Z
	add	esp, 12					; 0000000cH
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN5@Orphan_me:

; 203  : 			*_Pnext = _Mynextiter;

	mov	eax, DWORD PTR __Pnext$1[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx

; 204  : 			_Myproxy = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
$LN1@Orphan_me:

; 205  : 			}
; 206  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 207  : 		}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?_Orphan_me@_Iterator_base12@std@@QAEXXZ ENDP		; std::_Iterator_base12::_Orphan_me
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ PROC	; std::_Iterator_base12::_Getpnext, COMDAT
; _this$ = ecx

; 188  : 		{	// get address of remaining iterator chain

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 189  : 		return (&_Mynextiter);

	mov	eax, DWORD PTR _this$[ebp]
	add	eax, 4

; 190  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?_Getpnext@_Iterator_base12@std@@QAEPAPAU12@XZ ENDP	; std::_Iterator_base12::_Getpnext
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ
_TEXT	SEGMENT
tv68 = -208						; size = 4
_this$ = -8						; size = 4
?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ PROC ; std::_Iterator_base12::_Getcont, COMDAT
; _this$ = ecx

; 183  : 		{	// get owning container

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 184  : 		return (_Myproxy == 0 ? 0 : _Myproxy->_Mycont);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN3@Getcont
	mov	DWORD PTR tv68[ebp], 0
	jmp	SHORT $LN4@Getcont
$LN3@Getcont:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR tv68[ebp], eax
$LN4@Getcont:
	mov	eax, DWORD PTR tv68[ebp]

; 185  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?_Getcont@_Iterator_base12@std@@QBEPBU_Container_base12@2@XZ ENDP ; std::_Iterator_base12::_Getcont
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Clrcont@_Iterator_base12@std@@QAEXXZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
?_Clrcont@_Iterator_base12@std@@QAEXXZ PROC		; std::_Iterator_base12::_Clrcont, COMDAT
; _this$ = ecx

; 178  : 		{	// disown owning container

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 179  : 		_Myproxy = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 180  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?_Clrcont@_Iterator_base12@std@@QAEXXZ ENDP		; std::_Iterator_base12::_Clrcont
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z
_TEXT	SEGMENT
__Lock$2 = -60						; size = 4
__Parent_proxy$3 = -48					; size = 4
__Lock$4 = -36						; size = 4
_this$ = -24						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__Parent$ = 8						; size = 4
?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z PROC ; std::_Iterator_base12::_Adopt, COMDAT
; _this$ = ecx

; 149  : 		{	// adopt this iterator by parent

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 244				; 000000f4H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-256]
	mov	ecx, 61					; 0000003dH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 150  : 		if (_Parent == 0)

	cmp	DWORD PTR __Parent$[ebp], 0
	jne	SHORT $LN2@Adopt

; 151  : 			{	// no future parent, just disown current parent
; 152  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 153  : 			_Lockit _Lock(_LOCK_DEBUG);

	mov	esi, esp
	push	3
	lea	ecx, DWORD PTR __Lock$4[ebp]
	call	DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 154  : 			_Orphan_me();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me

; 155  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 156  : 			}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	esi, esp
	lea	ecx, DWORD PTR __Lock$4[ebp]
	call	DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp

; 157  : 		else

	jmp	SHORT $LN1@Adopt
$LN2@Adopt:

; 158  : 			{	// have a parent, do adoption
; 159  : 			_Container_proxy *_Parent_proxy = _Parent->_Myproxy;

	mov	eax, DWORD PTR __Parent$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR __Parent_proxy$3[ebp], ecx

; 160  : 
; 161  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 162  : 			if (_Myproxy != _Parent_proxy)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	cmp	ecx, DWORD PTR __Parent_proxy$3[ebp]
	je	SHORT $LN1@Adopt

; 163  : 				{	// change parentage
; 164  : 				_Lockit _Lock(_LOCK_DEBUG);

	mov	esi, esp
	push	3
	lea	ecx, DWORD PTR __Lock$2[ebp]
	call	DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR __$EHRec$[ebp+8], 1

; 165  : 				_Orphan_me();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me

; 166  : 				_Mynextiter = _Parent_proxy->_Myfirstiter;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Parent_proxy$3[ebp]
	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx

; 167  : 				_Parent_proxy->_Myfirstiter = this;

	mov	eax, DWORD PTR __Parent_proxy$3[ebp]
	mov	ecx, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 168  : 				_Myproxy = _Parent_proxy;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Parent_proxy$3[ebp]
	mov	DWORD PTR [eax], ecx

; 169  : 				}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	esi, esp
	lea	ecx, DWORD PTR __Lock$2[ebp]
	call	DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN1@Adopt:

; 170  : 
; 171  :  #else /* _ITERATOR_DEBUG_LEVEL == 2 */
; 172  : 			_Myproxy = _Parent_proxy;
; 173  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 174  : 			}
; 175  : 		}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN12@Adopt
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 256				; 00000100H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
$LN12@Adopt:
	DD	2
	DD	$LN11@Adopt
$LN11@Adopt:
	DD	-36					; ffffffdcH
	DD	4
	DD	$LN8@Adopt
	DD	-60					; ffffffc4H
	DD	4
	DD	$LN9@Adopt
$LN9@Adopt:
	DB	95					; 0000005fH
	DB	76					; 0000004cH
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	107					; 0000006bH
	DB	0
$LN8@Adopt:
	DB	95					; 0000005fH
	DB	76					; 0000004cH
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	107					; 0000006bH
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z$0:
	mov	esi, esp
	lea	ecx, DWORD PTR __Lock$4[ebp]
	call	DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
	cmp	esi, esp
	jmp	__RTC_CheckEsp
__unwindfunclet$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z$1:
	mov	esi, esp
	lea	ecx, DWORD PTR __Lock$2[ebp]
	call	DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
	cmp	esi, esp
	jmp	__RTC_CheckEsp
__ehhandler$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-260]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ENDP ; std::_Iterator_base12::_Adopt
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??1_Iterator_base12@std@@QAE@XZ
_TEXT	SEGMENT
__Lock$ = -36						; size = 4
_this$ = -24						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
??1_Iterator_base12@std@@QAE@XZ PROC			; std::_Iterator_base12::~_Iterator_base12, COMDAT
; _this$ = ecx

; 141  : 		{	// destroy the iterator

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1_Iterator_base12@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 220				; 000000dcH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-232]
	mov	ecx, 55					; 00000037H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 142  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 143  : 		_Lockit _Lock(_LOCK_DEBUG);

	mov	esi, esp
	push	3
	lea	ecx, DWORD PTR __Lock$[ebp]
	call	DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z
	cmp	esi, esp
	call	__RTC_CheckEsp

; 144  : 		_Orphan_me();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me

; 145  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 146  : 		}

	mov	esi, esp
	lea	ecx, DWORD PTR __Lock$[ebp]
	call	DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN6@Iterator_b
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 232				; 000000e8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN6@Iterator_b:
	DD	1
	DD	$LN5@Iterator_b
$LN5@Iterator_b:
	DD	-36					; ffffffdcH
	DD	4
	DD	$LN3@Iterator_b
$LN3@Iterator_b:
	DB	95					; 0000005fH
	DB	76					; 0000004cH
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	107					; 0000006bH
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1_Iterator_base12@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-236]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1_Iterator_base12@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1_Iterator_base12@std@@QAE@XZ ENDP			; std::_Iterator_base12::~_Iterator_base12
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z
_TEXT	SEGMENT
__Lock$2 = -36						; size = 4
_this$ = -24						; size = 4
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
__Right$ = 8						; size = 4
??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z PROC		; std::_Iterator_base12::operator=, COMDAT
; _this$ = ecx

; 124  : 		{	// assign an iterator

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 220				; 000000dcH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-232]
	mov	ecx, 55					; 00000037H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 125  : 		if (_Myproxy == _Right._Myproxy)

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR __Right$[ebp]
	mov	edx, DWORD PTR [eax]
	cmp	edx, DWORD PTR [ecx]
	jne	SHORT $LN2@operator
	jmp	SHORT $LN3@operator
$LN2@operator:

; 126  : 			;
; 127  : 		else if (_Right._Myproxy != 0)

	mov	eax, DWORD PTR __Right$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN4@operator

; 128  : 			_Adopt(_Right._Myproxy->_Mycont);

	mov	eax, DWORD PTR __Right$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR [ecx]
	push	edx
	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Adopt@_Iterator_base12@std@@QAEXPBU_Container_base12@2@@Z ; std::_Iterator_base12::_Adopt

; 129  : 		else

	jmp	SHORT $LN3@operator
$LN4@operator:

; 130  : 			{	// becoming invalid, disown current parent
; 131  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 132  : 			_Lockit _Lock(_LOCK_DEBUG);

	mov	esi, esp
	push	3
	lea	ecx, DWORD PTR __Lock$2[ebp]
	call	DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z
	cmp	esi, esp
	call	__RTC_CheckEsp
	mov	DWORD PTR __$EHRec$[ebp+8], 0

; 133  : 			_Orphan_me();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_me@_Iterator_base12@std@@QAEXXZ ; std::_Iterator_base12::_Orphan_me

; 134  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 135  : 			}

	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	esi, esp
	lea	ecx, DWORD PTR __Lock$2[ebp]
	call	DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN3@operator:

; 136  : 
; 137  : 		return (*this);

	mov	eax, DWORD PTR _this$[ebp]

; 138  : 		}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN11@operator
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 232				; 000000e8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
$LN11@operator:
	DD	1
	DD	$LN10@operator
$LN10@operator:
	DD	-36					; ffffffdcH
	DD	4
	DD	$LN8@operator
$LN8@operator:
	DB	95					; 0000005fH
	DB	76					; 0000004cH
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	107					; 0000006bH
	DB	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z$0:
	mov	esi, esp
	lea	ecx, DWORD PTR __Lock$2[ebp]
	call	DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
	cmp	esi, esp
	jmp	__RTC_CheckEsp
__ehhandler$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-236]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z ENDP		; std::_Iterator_base12::operator=
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??0_Iterator_base12@std@@QAE@ABU01@@Z
_TEXT	SEGMENT
_this$ = -8						; size = 4
__Right$ = 8						; size = 4
??0_Iterator_base12@std@@QAE@ABU01@@Z PROC		; std::_Iterator_base12::_Iterator_base12, COMDAT
; _this$ = ecx

; 119  : 		{	// copy an iterator

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 118  : 		: _Myproxy(0), _Mynextiter(0)

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 120  : 		*this = _Right;

	mov	eax, DWORD PTR __Right$[ebp]
	push	eax
	mov	ecx, DWORD PTR _this$[ebp]
	call	??4_Iterator_base12@std@@QAEAAU01@ABU01@@Z ; std::_Iterator_base12::operator=

; 121  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 204				; 000000ccH
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	4
??0_Iterator_base12@std@@QAE@ABU01@@Z ENDP		; std::_Iterator_base12::_Iterator_base12
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??0_Iterator_base12@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0_Iterator_base12@std@@QAE@XZ PROC			; std::_Iterator_base12::_Iterator_base12, COMDAT
; _this$ = ecx

; 114  : 		{	// construct orphaned iterator

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 113  : 		: _Myproxy(0), _Mynextiter(0)

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 115  : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Iterator_base12@std@@QAE@XZ ENDP			; std::_Iterator_base12::_Iterator_base12
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Orphan_all@_Container_base12@std@@QAEXXZ
_TEXT	SEGMENT
__Pnext$1 = -36						; size = 4
__Lock$2 = -24						; size = 4
_this$ = -12						; size = 4
__$ArrayPad$ = -4					; size = 4
?_Orphan_all@_Container_base12@std@@QAEXXZ PROC		; std::_Container_base12::_Orphan_all, COMDAT
; _this$ = ecx

; 215  : 	{	// orphan all iterators

	push	ebp
	mov	ebp, esp
	sub	esp, 232				; 000000e8H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-232]
	mov	ecx, 58					; 0000003aH
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	DWORD PTR _this$[ebp], ecx

; 216  :  #if _ITERATOR_DEBUG_LEVEL == 2
; 217  : 	if (_Myproxy != 0)

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN1@Orphan_all

; 218  : 		{	// proxy allocated, drain it
; 219  : 		_Lockit _Lock(_LOCK_DEBUG);

	mov	esi, esp
	push	3
	lea	ecx, DWORD PTR __Lock$2[ebp]
	call	DWORD PTR __imp_??0_Lockit@std@@QAE@H@Z
	cmp	esi, esp
	call	__RTC_CheckEsp

; 220  : 
; 221  : 		for (_Iterator_base12 **_Pnext = &_Myproxy->_Myfirstiter;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 4
	mov	DWORD PTR __Pnext$1[ebp], ecx
	jmp	SHORT $LN4@Orphan_all
$LN2@Orphan_all:

; 222  : 			*_Pnext != 0; *_Pnext = (*_Pnext)->_Mynextiter)

	mov	eax, DWORD PTR __Pnext$1[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	edx, DWORD PTR __Pnext$1[ebp]
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [edx], eax
$LN4@Orphan_all:
	mov	eax, DWORD PTR __Pnext$1[ebp]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN3@Orphan_all

; 223  : 			(*_Pnext)->_Myproxy = 0;

	mov	eax, DWORD PTR __Pnext$1[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [ecx], 0
	jmp	SHORT $LN2@Orphan_all
$LN3@Orphan_all:

; 224  : 		_Myproxy->_Myfirstiter = 0;

	mov	eax, DWORD PTR _this$[ebp]
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR [ecx+4], 0

; 225  : 		}

	mov	esi, esp
	lea	ecx, DWORD PTR __Lock$2[ebp]
	call	DWORD PTR __imp_??1_Lockit@std@@QAE@XZ
	cmp	esi, esp
	call	__RTC_CheckEsp
$LN1@Orphan_all:

; 226  :  #endif /* _ITERATOR_DEBUG_LEVEL == 2 */
; 227  : 	}

	push	edx
	mov	ecx, ebp
	push	eax
	lea	edx, DWORD PTR $LN10@Orphan_all
	call	@_RTC_CheckStackVars@8
	pop	eax
	pop	edx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	add	esp, 232				; 000000e8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
	npad	3
$LN10@Orphan_all:
	DD	1
	DD	$LN9@Orphan_all
$LN9@Orphan_all:
	DD	-24					; ffffffe8H
	DD	4
	DD	$LN8@Orphan_all
$LN8@Orphan_all:
	DB	95					; 0000005fH
	DB	76					; 0000004cH
	DB	111					; 0000006fH
	DB	99					; 00000063H
	DB	107					; 0000006bH
	DB	0
?_Orphan_all@_Container_base12@std@@QAEXXZ ENDP		; std::_Container_base12::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ
_TEXT	SEGMENT
tv68 = -208						; size = 4
_this$ = -8						; size = 4
?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ PROC ; std::_Container_base12::_Getpfirst, COMDAT
; _this$ = ecx

; 99   : 		{	// get address of iterator chain

	push	ebp
	mov	ebp, esp
	sub	esp, 208				; 000000d0H
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-208]
	mov	ecx, 52					; 00000034H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 100  : 		return (_Myproxy == 0 ? 0 : &_Myproxy->_Myfirstiter);

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax], 0
	jne	SHORT $LN3@Getpfirst
	mov	DWORD PTR tv68[ebp], 0
	jmp	SHORT $LN4@Getpfirst
$LN3@Getpfirst:
	mov	ecx, DWORD PTR _this$[ebp]
	mov	edx, DWORD PTR [ecx]
	add	edx, 4
	mov	DWORD PTR tv68[ebp], edx
$LN4@Getpfirst:
	mov	eax, DWORD PTR tv68[ebp]

; 101  : 		}

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?_Getpfirst@_Container_base12@std@@QBEPAPAU_Iterator_base12@2@XZ ENDP ; std::_Container_base12::_Getpfirst
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??1_Container_base12@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -20						; size = 4
__$EHRec$ = -12						; size = 12
??1_Container_base12@std@@QAE@XZ PROC			; std::_Container_base12::~_Container_base12, COMDAT
; _this$ = ecx

; 94   : 		{	// destroy the container

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1_Container_base12@std@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-216]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$[ebp], ecx

; 95   : 		_Orphan_all();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?_Orphan_all@_Container_base12@std@@QAEXXZ ; std::_Container_base12::_Orphan_all

; 96   : 		}

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	add	esp, 216				; 000000d8H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1_Container_base12@std@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-220]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1_Container_base12@std@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1_Container_base12@std@@QAE@XZ ENDP			; std::_Container_base12::~_Container_base12
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??0_Container_base12@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0_Container_base12@std@@QAE@XZ PROC			; std::_Container_base12::_Container_base12, COMDAT
; _this$ = ecx

; 80   : 		{	// construct childless container

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 79   : 		: _Myproxy(0)

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0

; 81   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Container_base12@std@@QAE@XZ ENDP			; std::_Container_base12::_Container_base12
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\xutility
;	COMDAT ??0_Container_proxy@std@@QAE@XZ
_TEXT	SEGMENT
_this$ = -8						; size = 4
??0_Container_proxy@std@@QAE@XZ PROC			; std::_Container_proxy::_Container_proxy, COMDAT
; _this$ = ecx

; 68   : 		{	// construct from pointers

	push	ebp
	mov	ebp, esp
	sub	esp, 204				; 000000ccH
	push	ebx
	push	esi
	push	edi
	push	ecx
	lea	edi, DWORD PTR [ebp-204]
	mov	ecx, 51					; 00000033H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	ecx
	mov	DWORD PTR _this$[ebp], ecx

; 67   : 		: _Mycont(0), _Myfirstiter(0)

	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax], 0
	mov	eax, DWORD PTR _this$[ebp]
	mov	DWORD PTR [eax+4], 0

; 69   : 		}

	mov	eax, DWORD PTR _this$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??0_Container_proxy@std@@QAE@XZ ENDP			; std::_Container_proxy::_Container_proxy
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\vcruntime_new.h
;	COMDAT ??2@YAPAXIPAX@Z
_TEXT	SEGMENT
__Size$ = 8						; size = 4
__Where$ = 12						; size = 4
??2@YAPAXIPAX@Z PROC					; operator new, COMDAT

; 87   :     {

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 88   :         (void)_Size;
; 89   :         return _Where;

	mov	eax, DWORD PTR __Where$[ebp]

; 90   :     }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
??2@YAPAXIPAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File c:\program files (x86)\microsoft visual studio 14.0\vc\include\cmath
;	COMDAT ?abs@@YANN@Z
_TEXT	SEGMENT
__Xx$ = 8						; size = 8
?abs@@YANN@Z PROC					; abs, COMDAT

; 18   : 	{

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd

; 19   : 	return (_CSTD fabs(_Xx));

	sub	esp, 8
	movsd	xmm0, QWORD PTR __Xx$[ebp]
	movsd	QWORD PTR [esp], xmm0
	call	_fabs
	add	esp, 8

; 20   : 	}

	pop	edi
	pop	esi
	pop	ebx
	add	esp, 192				; 000000c0H
	cmp	ebp, esp
	call	__RTC_CheckEsp
	mov	esp, ebp
	pop	ebp
	ret	0
?abs@@YANN@Z ENDP					; abs
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File g:\projects\lotion\lotion\player.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Odtp /RTCsu /ZI
; File g:\projects\lotion\lotion\player.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

	push	ebp
	mov	ebp, esp
	sub	esp, 192				; 000000c0H
	push	ebx
	push	esi
	push	edi
	lea	edi, DWORD PTR [ebp-192]
	mov	ecx, 48					; 00000030H
	mov	eax, -858993460				; ccccccccH
	rep stosd
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
END
